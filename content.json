{"meta":{"title":"Jimmy's Notes","subtitle":"執著 / 不應該自我設限","description":"光電/程式/工藝/設計/哲學","author":"Jimmy Wei","url":"https://jimmywei01.github.io","root":"/"},"pages":[{"title":"分類","date":"2019-05-08T03:05:56.000Z","updated":"2019-05-08T03:09:44.415Z","comments":true,"path":"categories/index.html","permalink":"https://jimmywei01.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2019-05-07T09:18:08.762Z","updated":"2019-05-07T09:18:08.762Z","comments":true,"path":"css/progressbar.css","permalink":"https://jimmywei01.github.io/css/progressbar.css","excerpt":"","text":".pace { -webkit-pointer-events: none; pointer-events: none; -webkit-user-select: none; -moz-user-select: none; user-select: none; } .pace-inactive { display: none; } .pace .pace-progress { background: #3273dc; position: fixed; z-index: 2000; top: 0; right: 100%; width: 100%; height: 2px; }"},{"title":"標籤","date":"2019-05-08T02:59:20.000Z","updated":"2019-05-08T03:09:06.786Z","comments":true,"path":"tags/index.html","permalink":"https://jimmywei01.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2019-05-07T09:18:08.761Z","updated":"2019-05-07T09:18:08.760Z","comments":true,"path":"css/insight.css","permalink":"https://jimmywei01.github.io/css/insight.css","excerpt":"","text":".ins-section-container { position: relative; background: #f7f7f7; } .ins-section { font-size: 14px; line-height: 16px; } .ins-section .ins-section-header, .ins-section .ins-search-item { padding: 8px 15px; } .ins-section .ins-section-header { color: #9a9a9a; border-bottom: 1px solid #e2e2e2; } .ins-section .ins-slug { margin-left: 5px; color: #9a9a9a; } .ins-section .ins-slug:before { content: '('; } .ins-section .ins-slug:after { content: ')'; } .ins-section .ins-search-item header, .ins-section .ins-search-item .ins-search-preview { overflow: hidden; white-space: nowrap; text-overflow: ellipsis; } .ins-section .ins-search-item header .ins-title { margin-left: 8px; } .ins-section .ins-search-item .ins-search-preview { height: 15px; font-size: 12px; color: #9a9a9a; margin: 5px 0 0 20px; } .ins-section .ins-search-item:hover, .ins-section .ins-search-item.active { color: #fff; background: #3273dc; } .ins-section .ins-search-item:hover .ins-slug, .ins-section .ins-search-item.active .ins-slug, .ins-section .ins-search-item:hover .ins-search-preview, .ins-section .ins-search-item.active .ins-search-preview { color: #fff; }"},{"title":"","date":"2019-05-07T09:18:08.759Z","updated":"2019-05-07T09:18:08.752Z","comments":true,"path":"css/back-to-top.css","permalink":"https://jimmywei01.github.io/css/back-to-top.css","excerpt":"","text":"#back-to-top { position: fixed; padding: 8px 0; transition: 0.4s ease opacity, 0.4s ease width, 0.4s ease transform, 0.4s ease border-radius; opacity: 0; line-height: 24px; outline: none; transform: translateY(120px); } #back-to-top.fade-in { opacity: 1; } #back-to-top.rise-up { transform: translateY(0); }"},{"title":"","date":"2019-05-07T09:18:08.763Z","updated":"2019-05-07T09:18:08.763Z","comments":true,"path":"css/search.css","permalink":"https://jimmywei01.github.io/css/search.css","excerpt":"","text":".searchbox { display: none; perspective: 50em; top: 0; left: 0; width: 100%; height: 100%; z-index: 100; background: rgba(0, 0, 0, 0.7); transform-origin: 0%; perspective-origin: top center; } .searchbox.show { display: block; } .searchbox, .searchbox .searchbox-container { position: fixed; } .searchbox .searchbox-container { overflow: hidden; } .searchbox .searchbox-selectable { cursor: pointer; } .searchbox .searchbox-input-wrapper { position: relative; } .searchbox .searchbox-input-wrapper .searchbox-input { width: 100%; border: none; outline: none; font-size: 16px; box-shadow: none; font-weight: 200; border-radius: 0; background: #fff; line-height: 20px; box-sizing: border-box; padding: 12px 28px 12px 20px; border-bottom: 1px solid #e2e2e2; } .searchbox .searchbox-input-wrapper .searchbox-close { top: 50%; right: 6px; width: 20px; height: 20px; line-height: 20px; font-size: 16px; margin-top: -11px; position: absolute; text-align: center; display: inline-block; } .searchbox .searchbox-input-wrapper .searchbox-close:hover { color: #3273dc; } .searchbox .searchbox-result-wrapper { left: 0; right: 0; top: 45px; bottom: 0; overflow-y: auto; position: absolute; } .searchbox .searchbox-container { left: 50%; top: 100px; width: 540px; z-index: 101; bottom: 100px; margin-left: -270px; box-sizing: border-box; } @media screen and (max-width: 559px), screen and (max-height: 479px) { .searchbox .searchbox-container { top: 0; left: 0; margin: 0; width: 100%; height: 100%; background: #f7f7f7; } }"},{"title":"","date":"2019-05-07T09:18:08.759Z","updated":"2019-05-07T09:18:08.754Z","comments":true,"path":"js/animation.js","permalink":"https://jimmywei01.github.io/js/animation.js","excerpt":"","text":"(function () { function $() { return Array.prototype.slice.call(document.querySelectorAll.apply(document, arguments)); } $('body > .navbar, body > .section, body > .footer').forEach(function (element) { element.style.transition = '0s'; element.style.opacity = '0'; }); document.querySelector('body > .navbar').style.transform = 'translateY(-100px)'; ['.column-main > .card', '.column-left > .card, .column-right-shadow > .card', '.column-right > .card'].map(function (selector) { $(selector).forEach(function (element) { element.style.transition = '0s'; element.style.opacity = '0'; element.style.transform = 'scale(0.8)'; element.style.transformOrigin = 'center top'; }); }); setTimeout(function () { $('body > .navbar, body > .section, body > .footer').forEach(function (element) { element.style.opacity = '1'; element.style.transition = 'opacity 0.3s ease-out, transform 0.3s ease-out'; }); document.querySelector('body > .navbar').style.transform = 'translateY(0)'; ['.column-main > .card', '.column-left > .card, .column-right-shadow > .card', '.column-right > .card'].map(function (selector) { var i = 1; $(selector).forEach(function (element) { setTimeout(function () { element.style.opacity = '1'; element.style.transform = ''; element.style.transition = 'opacity 0.3s ease-out, transform 0.3s ease-out'; }, i * 100); i++; }); }); }); })();"},{"title":"","date":"2019-05-07T12:54:51.550Z","updated":"2019-05-07T12:54:51.550Z","comments":true,"path":"css/style.css","permalink":"https://jimmywei01.github.io/css/style.css","excerpt":"","text":"/* --------------------------------- * Override CSS Framework * --------------------------------- */ html { font-size: 14px; } body { background-color: #f7f7f7; } body, button, input, select, textarea { font-family: \"Ubuntu\", \"Roboto\", \"Open Sans\", \"Microsoft YaHei\", sans-serif; } @media screen and (min-width: 1280px) { .is-1-column .container, .is-2-column .container { max-width: 960px; width: 960px; } } @media screen and (min-width: 1472px) { .is-2-column .container { max-width: 1152px; width: 1152px; } .is-1-column .container { max-width: 960px; width: 960px; } } @media screen and (max-width: 768px) { .section { padding: 1.5rem 1rem; } } @media screen and (min-width: 769px) { .column-main.is-sticky, .column-left.is-sticky, .column-right.is-sticky, .column-right-shadow.is-sticky { align-self: flex-start; position: -webkit-sticky; position: sticky; top: 0.75rem; } .column-right-shadow.is-sticky { top: 1.5rem; } } .tag.is-grey { background: #e7e7e7; } .card { border-radius: 4px; box-shadow: 0 4px 10px rgba(0,0,0,0.05), 0 0 1px rgba(0,0,0,0.1); } .card + .card, .card + .column-right-shadow { margin-top: 1.5rem; } .card.card-transparent { box-shadow: none; background: transparent; } .card .card-image { overflow: hidden; border-top-left-radius: 4px; border-top-right-radius: 4px; } img.thumbnail { object-fit: cover; width: 100%; height: 100%; } .navbar-logo img, .footer-logo img { max-height: 1.75rem; } .navbar-main { box-shadow: 0 4px 10px rgba(0,0,0,0.05); } .navbar-main .navbar-menu, .navbar-main .navbar-start, .navbar-main .navbar-end { align-items: stretch; display: flex; padding: 0; flex-shrink: 0; } .navbar-main .navbar-menu { flex-grow: 1; flex-shrink: 0; overflow-x: auto; } .navbar-main .navbar-start { justify-content: flex-start; margin-right: auto; } .navbar-main .navbar-end { justify-content: flex-end; margin-left: auto; } .navbar-main .navbar-item { display: flex; align-items: center; padding: 1.25rem 0.75rem; } .navbar-main .navbar-item.is-active { color: #3273dc; background-color: transparent; } @media screen and (max-width: 1087px) { .navbar-main .navbar-menu { justify-content: center; box-shadow: none; } .navbar-main .navbar-start { margin-right: 0; } .navbar-main .navbar-end { margin-left: 0; } } .footer { background: #fff; } .footer .field .button { background: transparent; } .widget .media { border: none; } .widget .media + .media { margin-top: 0; } .widget .menu-list li ul { margin-right: 0; } .widget .menu-list a.level { display: flex; } .pagination .pagination-link:not(.is-current), .pagination .pagination-previous, .pagination .pagination-next { background: #fff; border: none; } .pagination .pagination-link, .pagination .pagination-previous, .pagination .pagination-next { box-shadow: 0 4px 10px rgba(0,0,0,0.05); } .post-navigation { justify-content: space-around; } .post-navigation .level-item { margin-bottom: 0; } .timeline { margin-left: 1rem; padding-left: 1.5rem; padding-top: 1rem; border-left: 1px solid #dbdbdb; } .timeline .media { position: relative; } .timeline .media:before, .timeline .media:last-child:after { content: ''; display: block; position: absolute; left: calc(-5px - 1.5rem); } .timeline .media:before { width: 9px; height: 9px; top: 1.3rem; background: #dbdbdb; border-radius: 50%; } .timeline .media:first-child:before { top: 0.3rem; } .timeline .media:last-child:after { top: calc(1.3rem + 9px); width: 9px; bottom: 0; background: #fff; } .timeline .media:first-child:last-child:after { top: calc(0.3rem + 9px); } .article .article-meta { margin-bottom: 0.5rem !important; } .article .content { font-size: 1.1rem; } .article .content blockquote.pullquote { float: right; max-width: 50%; font-size: 1.15rem; position: relative; } .rtl { direction: rtl; } .rtl .level .level-item:not(:last-child), .rtl .level.is-mobile .level-item:not(:last-child) { margin-left: 0.75rem; margin-right: 0; } .donate { position: relative; } .donate .qrcode { display: none; position: absolute; z-index: 99; bottom: 2.5em; line-height: 0; overflow: hidden; border-radius: 4px; box-shadow: 0 4px 10px rgba(0,0,0,0.1), 0 0 1px rgba(0,0,0,0.2); overflow: hidden; } .donate .qrcode img { max-width: 280px; } .donate:hover .qrcode { display: block; } .donate:first-child:not(:last-child) .qrcode { left: -0.75rem; } .donate:last-child:not(:first-child) .qrcode { right: -0.75rem; } @media screen and (max-width: 768px) { #toc { display: none; position: fixed; margin: 1rem; left: 0; right: 0; bottom: 0; z-index: 100; max-height: calc(100vh - 2rem); overflow-y: auto; } #toc-mask { display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; z-index: 99; background: rgba(0,0,0,0.7); } #toc.is-active, #toc-mask.is-active { display: block; } } /* --------------------------------- * Custom modifiers * --------------------------------- */ .is-borderless { border: none; } .is-size-7 { font-size: 0.85rem !important; } .is-7by1 { padding-top: 42.8%; } .is-7by1 img { bottom: 0; left: 0; position: absolute; right: 0; top: 0; } .is-overflow-x-auto { overflow-x: auto !important; } .is-flex-grow { flex-grow: 1 !important; } .is-flex-wrap { flex-wrap: wrap !important; } .is-flex-start { justify-content: start !important; } .is-flex-center { justify-content: center !important; } .is-flex-middle { align-items: center !important; } .has-order-1 { order: 1; } .has-order-2 { order: 2; } .has-order-3 { order: 3; } .has-mr-6 { margin-right: 0.5em !important; } .has-mb-6 { margin-bottom: 0.5em !important; } .has-mr-7 { margin-right: 0.25em !important; } .has-link-grey, .has-link-black-ter { transition: 0.2s ease; } .has-link-grey:hover, .has-link-black-ter:hover { color: #3273dc !important; } .has-link-grey { color: #7a7a7a !important; } .has-link-black-ter { color: #242424 !important; } @media screen and (max-width: 768px) { .has-text-centered-mobile { text-align: center !important; } .is-flex-center-mobile { justify-content: center !important; } .has-mt-5-mobile { margin-top: 1em !important; } } /* --------------------------------- * Font icon fixes * --------------------------------- */ .fa, .fab, .fal, .far, .fas { line-height: inherit; } /* --------------------------------- * Fix content elements * --------------------------------- */ .content h1, .content h2, .content h3, .content h4, .content h5, .content h6 { font-weight: 400; } .content h1 { font-size: 1.75em; } .content h2 { font-size: 1.5em; } .content h3 { font-size: 1.25em; } .content h4 { font-size: 1.125em; } .content h5 { font-size: 1em; } .content code, .content pre { font-size: 0.85em; font-family: \"Source Code Pro\", monospace, \"Microsoft YaHei\"; } .content code { color: #ff3860; background: transparent; padding: 0; } .content blockquote footer strong + cite { margin-left: 0.5em; } /* --------------------------------- * Fix code highlight * --------------------------------- */ figure.highlight { padding: 0; width: 100%; position: relative; margin: 1em 0 1em !important; } figure.highlight pre, figure.highlight table tr:hover { color: inherit; background: transparent; } figure.highlight table { width: auto; } figure.highlight pre { padding: 0; overflow: visible; } figure.highlight pre .line { line-height: 1.5rem; } figure.highlight figcaption, figure.highlight .gutter { background: rgba(200,200,200,0.15); } figure.highlight figcaption { padding: 0.3em 0.75em; text-align: left; font-style: normal; font-size: 0.8em; } figure.highlight figcaption span { font-weight: 500; font-family: \"Source Code Pro\", monospace, \"Microsoft YaHei\"; } figure.highlight figcaption a { float: right; color: #9a9a9a; } figure.highlight .gutter { text-align: right; } figure.highlight .tag, figure.highlight .title, figure.highlight .number, figure.highlight .section { display: inherit; font: inherit; margin: inherit; padding: inherit; background: inherit; height: inherit; text-align: inherit; vertical-align: inherit; min-width: inherit; border-radius: inherit; } figure.highlight .copy { display: none; position: absolute; bottom: 0; right: 0; color: #fff; background: rgba(0,0,0,0.5); } figure.highlight:hover .copy { display: block; } /* --------------------------------- * Fix Video * --------------------------------- */ .video-container { position: relative; padding-bottom: 56.25%; padding-top: 25px; height: 0; } .video-container iframe { position: absolute; top: 0; left: 0; width: 100%; height: 100%; } /* --------------------------------- * Fix Gist Snippet * --------------------------------- */ .gist table tr:hover { background: transparent; } .gist table td { border: none; } .gist .file { all: initial; }"},{"title":"","date":"2019-05-11T11:48:33.093Z","updated":"2019-05-11T11:48:33.093Z","comments":true,"path":"js/back-to-top.js","permalink":"https://jimmywei01.github.io/js/back-to-top.js","excerpt":"","text":"$(document).ready(function () { var $button = $('#back-to-top'); var $footer = $('footer.footer'); var $mainColumn = $('.column-main'); var $leftSidebar = $('.column-left'); var $rightSidebar = $('.column-right'); var lastScrollTop = 0; var rightMargin = 20; var bottomMargin = 20; var lastState = null; var state = { base: { classname: 'card has-text-centered', left: '', width: 64, bottom: bottomMargin, 'border-radius': 4 } }; state['desktop-hidden'] = Object.assign({}, state.base, { classname: state.base.classname + ' rise-up', }); state['desktop-visible'] = Object.assign({}, state['desktop-hidden'], { classname: state['desktop-hidden'].classname + ' fade-in', }); state['desktop-dock'] = Object.assign({}, state['desktop-visible'], { classname: state['desktop-visible'].classname + ' fade-in', width: 40, 'border-radius': '50%' }); state['mobile-hidden'] = Object.assign({}, state.base, { classname: state.base.classname + ' fade-in', right: rightMargin }); state['mobile-visible'] = Object.assign({}, state['mobile-hidden'], { classname: state['mobile-hidden'].classname + ' rise-up', }); function isStateEquals(prev, next) { for (var prop in prev) { if (!next.hasOwnProperty(prop) || next[prop] !== prev[prop]) { return false; } } for (var prop in next) { if (!prev.hasOwnProperty(prop) || prev[prop] !== prev[prop]) { return false; } } return true; } function applyState(state) { if (lastState !== null && isStateEquals(lastState, state)) { return; } $button.attr('class', state.classname); for (let prop in state) { if (prop === 'classname') { continue; } $button.css(prop, state[prop]); } lastState = state; } function isDesktop() { return window.innerWidth >= 1078; } function isTablet() { return window.innerWidth >= 768 && !isDesktop(); } function isScrollUp() { return $(window).scrollTop() < lastScrollTop && $(window).scrollTop() > 0; } function hasLeftSidebar() { return $leftSidebar.length > 0; } function hasRightSidebar() { return $rightSidebar.length > 0; } function getRightSidebarBottom() { if (!hasRightSidebar()) { return 0; } return Math.max.apply(null, $rightSidebar.find('.widget').map(function () { return $(this).offset().top + $(this).outerHeight(true); })); } function getScrollTop() { return $(window).scrollTop(); } function getScrollBottom() { return $(window).scrollTop() + $(window).height(); } function getButtonWidth() { return $button.outerWidth(true); } function getButtonHeight() { return $button.outerHeight(true); } function updateScrollTop() { lastScrollTop = $(window).scrollTop(); } function update() { // desktop mode or tablet mode with only right sidebar enabled if (isDesktop() || (isTablet() && !hasLeftSidebar() && hasRightSidebar())) { var nextState; var padding = ($mainColumn.outerWidth() - $mainColumn.width()) / 2; var maxLeft = $(window).width() - getButtonWidth() - rightMargin; var maxBottom = $footer.offset().top + getButtonHeight() / 2 + bottomMargin; if (getScrollTop() == 0 || getScrollBottom() < getRightSidebarBottom() + padding + getButtonHeight()) { nextState = state['desktop-hidden']; } else if (getScrollBottom() < maxBottom) { nextState = state['desktop-visible']; } else { nextState = Object.assign({}, state['desktop-dock'], { bottom: getScrollBottom() - maxBottom + bottomMargin }); } var left = $mainColumn.offset().left + $mainColumn.outerWidth() + padding; nextState = Object.assign({}, nextState, { left: Math.min(left, maxLeft) }); applyState(nextState); } else { // mobile and tablet mode if (!isScrollUp()) { applyState(state['mobile-hidden']); } else { applyState(state['mobile-visible']); } updateScrollTop(); } } update(); $(window).resize(update); $(window).scroll(update); $('#back-to-top').on('click', function () { $('body, html').animate({ scrollTop: 0 }, 400); }); });"},{"title":"","date":"2019-05-07T09:18:08.763Z","updated":"2019-05-07T09:18:08.762Z","comments":true,"path":"js/clipboard.js","permalink":"https://jimmywei01.github.io/js/clipboard.js","excerpt":"","text":"document.addEventListener('DOMContentLoaded', function () { if (typeof(ClipboardJS) !== 'undefined') { $('figure.highlight').each(function () { var id = 'code-' + Date.now() + (Math.random() * 1000 | 0); $(this).attr('id', id); $(this).prepend($(``)); }); new ClipboardJS('.highlight .copy'); } });"},{"title":"","date":"2019-05-07T09:18:08.772Z","updated":"2019-05-07T09:18:08.771Z","comments":true,"path":"js/gallery.js","permalink":"https://jimmywei01.github.io/js/gallery.js","excerpt":"","text":"document.addEventListener('DOMContentLoaded', function () { if (typeof ($.fn.lightGallery) === 'function') { $('.article').lightGallery({ selector: '.gallery-item' }); } if (typeof ($.fn.justifiedGallery) === 'function') { $('.justified-gallery').justifiedGallery(); } });"},{"title":"","date":"2019-05-07T09:18:08.856Z","updated":"2019-05-07T09:18:08.856Z","comments":true,"path":"js/main.js","permalink":"https://jimmywei01.github.io/js/main.js","excerpt":"","text":"(function($){ $('.article img:not(\".not-gallery-item\")').each(function () { // wrap images with link and add caption if possible if ($(this).parent('a').length === 0) { $(this).wrap(''); if (this.alt) { $(this).after('' + this.alt + ''); } } }); if (typeof(moment) === 'function') { $('.article-meta time').each(function () { $(this).text(moment($(this).attr('datetime')).fromNow()); }); } function adjustNavbar() { const navbarWidth = $('.navbar-main .navbar-start').outerWidth() + $('.navbar-main .navbar-end').outerWidth(); if ($(document).outerWidth() < navbarWidth) { $('.navbar-main .navbar-menu').addClass('is-flex-start'); } else { $('.navbar-main .navbar-menu').removeClass('is-flex-start'); } } adjustNavbar(); $(window).resize(adjustNavbar); var $toc = $('#toc'); if ($toc.length > 0) { var $mask = $(''); $mask.attr('id', 'toc-mask'); $('body').append($mask); function toggleToc() { $toc.toggleClass('is-active'); $mask.toggleClass('is-active'); } $toc.on('click', toggleToc); $mask.on('click', toggleToc); $('.navbar-main .catalogue').on('click', toggleToc); } })(jQuery);"},{"title":"","date":"2019-05-07T09:18:08.818Z","updated":"2019-05-07T09:18:08.773Z","comments":true,"path":"js/insight.js","permalink":"https://jimmywei01.github.io/js/insight.js","excerpt":"","text":"/** * Insight search plugin * @author PPOffice { @link https://github.com/ppoffice } */ (function ($, CONFIG) { var $main = $('.ins-search'); var $input = $main.find('.ins-search-input'); var $wrapper = $main.find('.ins-section-wrapper'); var $container = $main.find('.ins-section-container'); $main.parent().remove('.ins-search'); $('body').append($main); function section (title) { return $('').addClass('ins-section') .append($('').addClass('ins-section-header').text(title)); } function searchItem (icon, title, slug, preview, url) { return $('').addClass('ins-selectable').addClass('ins-search-item') .append($('').append($('').addClass('fa').addClass('fa-' + icon)) .append($('').addClass('ins-title').text(title != null && title !== '' ? title : CONFIG.TRANSLATION['UNTITLED'])) .append(slug ? $('').addClass('ins-slug').text(slug) : null)) .append(preview ? $('').addClass('ins-search-preview').text(preview) : null) .attr('data-url', url); } function sectionFactory (type, array) { var sectionTitle; var $searchItems; if (array.length === 0) return null; sectionTitle = CONFIG.TRANSLATION[type]; switch (type) { case 'POSTS': case 'PAGES': $searchItems = array.map(function (item) { // Use config.root instead of permalink to fix url issue return searchItem('file', item.title, null, item.text.slice(0, 150), item.link); }); break; case 'CATEGORIES': case 'TAGS': $searchItems = array.map(function (item) { return searchItem(type === 'CATEGORIES' ? 'folder' : 'tag', item.name, item.slug, null, item.link); }); break; default: return null; } return section(sectionTitle).append($searchItems); } function parseKeywords (keywords) { return keywords.split(' ').filter(function (keyword) { return !!keyword; }).map(function (keyword) { return keyword.toUpperCase(); }); } /** * Judge if a given post/page/category/tag contains all of the keywords. * @param Object obj Object to be weighted * @param Array fields Object's fields to find matches */ function filter (keywords, obj, fields) { var keywordArray = parseKeywords(keywords); var containKeywords = keywordArray.filter(function (keyword) { var containFields = fields.filter(function (field) { if (!obj.hasOwnProperty(field)) return false; if (obj[field].toUpperCase().indexOf(keyword) > -1) return true; }); if (containFields.length > 0) return true; return false; }); return containKeywords.length === keywordArray.length; } function filterFactory (keywords) { return { POST: function (obj) { return filter(keywords, obj, ['title', 'text']); }, PAGE: function (obj) { return filter(keywords, obj, ['title', 'text']); }, CATEGORY: function (obj) { return filter(keywords, obj, ['name', 'slug']); }, TAG: function (obj) { return filter(keywords, obj, ['name', 'slug']); } }; } /** * Calculate the weight of a matched post/page/category/tag. * @param Object obj Object to be weighted * @param Array fields Object's fields to find matches * @param Array weights Weight of every field */ function weight (keywords, obj, fields, weights) { var value = 0; parseKeywords(keywords).forEach(function (keyword) { var pattern = new RegExp(keyword, 'img'); // Global, Multi-line, Case-insensitive fields.forEach(function (field, index) { if (obj.hasOwnProperty(field)) { var matches = obj[field].match(pattern); value += matches ? matches.length * weights[index] : 0; } }); }); return value; } function weightFactory (keywords) { return { POST: function (obj) { return weight(keywords, obj, ['title', 'text'], [3, 1]); }, PAGE: function (obj) { return weight(keywords, obj, ['title', 'text'], [3, 1]); }, CATEGORY: function (obj) { return weight(keywords, obj, ['name', 'slug'], [1, 1]); }, TAG: function (obj) { return weight(keywords, obj, ['name', 'slug'], [1, 1]); } }; } function search (json, keywords) { var WEIGHTS = weightFactory(keywords); var FILTERS = filterFactory(keywords); var posts = json.posts; var pages = json.pages; var tags = json.tags; var categories = json.categories; return { posts: posts.filter(FILTERS.POST).sort(function (a, b) { return WEIGHTS.POST(b) - WEIGHTS.POST(a); }).slice(0, 5), pages: pages.filter(FILTERS.PAGE).sort(function (a, b) { return WEIGHTS.PAGE(b) - WEIGHTS.PAGE(a); }).slice(0, 5), categories: categories.filter(FILTERS.CATEGORY).sort(function (a, b) { return WEIGHTS.CATEGORY(b) - WEIGHTS.CATEGORY(a); }).slice(0, 5), tags: tags.filter(FILTERS.TAG).sort(function (a, b) { return WEIGHTS.TAG(b) - WEIGHTS.TAG(a); }).slice(0, 5) }; } function searchResultToDOM (searchResult) { $container.empty(); for (var key in searchResult) { $container.append(sectionFactory(key.toUpperCase(), searchResult[key])); } } function scrollTo ($item) { if ($item.length === 0) return; var wrapperHeight = $wrapper[0].clientHeight; var itemTop = $item.position().top - $wrapper.scrollTop(); var itemBottom = $item[0].clientHeight + $item.position().top; if (itemBottom > wrapperHeight + $wrapper.scrollTop()) { $wrapper.scrollTop(itemBottom - $wrapper[0].clientHeight); } if (itemTop < 0) { $wrapper.scrollTop($item.position().top); } } function selectItemByDiff (value) { var $items = $.makeArray($container.find('.ins-selectable')); var prevPosition = -1; $items.forEach(function (item, index) { if ($(item).hasClass('active')) { prevPosition = index; return; } }); var nextPosition = ($items.length + prevPosition + value) % $items.length; $($items[prevPosition]).removeClass('active'); $($items[nextPosition]).addClass('active'); scrollTo($($items[nextPosition])); } function gotoLink ($item) { if ($item && $item.length) { location.href = $item.attr('data-url'); } } $.getJSON(CONFIG.CONTENT_URL, function (json) { if (location.hash.trim() === '#ins-search') { $main.addClass('show'); } $input.on('input', function () { var keywords = $(this).val(); searchResultToDOM(search(json, keywords)); }); $input.trigger('input'); }); var touch = false; $(document).on('click focus', '.navbar-main .search', function () { $main.addClass('show'); $main.find('.ins-search-input').focus(); }).on('click touchend', '.ins-search-item', function (e) { if (e.type !== 'click' && !touch) { return; } gotoLink($(this)); touch = false; }).on('click touchend', '.ins-close', function (e) { if (e.type !== 'click' && !touch) { return; } $('.navbar-main').css('pointer-events', 'none'); setTimeout(function(){ $('.navbar-main').css('pointer-events', 'auto'); }, 400); $main.removeClass('show'); touch = false; }).on('keydown', function (e) { if (!$main.hasClass('show')) return; switch (e.keyCode) { case 27: // ESC $main.removeClass('show'); break; case 38: // UP selectItemByDiff(-1); break; case 40: // DOWN selectItemByDiff(1); break; case 13: //ENTER gotoLink($container.find('.ins-selectable.active').eq(0)); break; } }).on('touchstart', function (e) { touch = true; }).on('touchmove', function (e) { touch = false; }); })(jQuery, window.INSIGHT_CONFIG);"}],"posts":[{"title":"JS 紀錄9 - object","slug":"JS-紀錄9-object","date":"2019-06-11T14:19:44.000Z","updated":"2019-06-13T12:22:46.388Z","comments":true,"path":"2019/06/11/JS-紀錄9-object/","link":"","permalink":"https://jimmywei01.github.io/2019/06/11/JS-紀錄9-object/","excerpt":"JavaScript Object","text":"JavaScript Object 物件導向 把情境(問題)描述為物件 人 &amp; 香蕉 描述物件的屬性 &amp; 方法 人 - 屬性 名子, 年齡, 有的物品 人 - 方法 打招呼, 走路, 接收物品 香蕉 - 屬性 名字, 價格, 味道 香蕉 - 方法 剝⽪, 攻擊人 操作讓物件彼此互動 A 跟 B 是⼈，A 有⼀根香蕉 A.打招呼( ) A.給予( B , 香蕉) B -&gt; 香蕉.剝⽪( ) B.吃( 香蕉 ) 「類別」可想像成是建構某特定物體的藍圖或模具，而「實體」就是按照這藍圖或模具製造出來的成品，並使用「建構子」來建立和初始化實體 「繼承」定義一個類別，其特性繼承於另外一個類別，稱它們為「父類別」與「子類別」，而子類別「繼承」了父類別的特性 「多型」是指子類別除了擁有自己的方法外，這個方法還能覆寫來特化父類別的同名方法，以賦予其更特殊的行為 new 關鍵字發生哪些事？ 建立一個新的物件 將物件的 .__proto__ 指向 prototype，形成原型鏈 將建構子的 this 指向 new 出來的新物件 回傳這個物件 新增 / 修改屬性有什麼特性 get &amp; set 方法 - 模擬 Private 成員 使用物件字面值的方式定義屬性 透過這樣方式產生的物件，所有的屬性都是「公開成員」可隨意變動 get 屬性讀取，不允許修改 12345678910function Person( name, age, gender )&#123; this.getName = function()&#123; return name &#125; this.getAge =function()&#123; return age &#125; this.getGender = function()&#123; return gender &#125; set 修改屬性更新 12345678910111213141516171819202122 this.setName = function(name)&#123; return this.setName = name &#125; this.setGender = function(gender)&#123; return this.setGender = gender &#125; this.greeting = function()&#123; console.log(&apos;Hello! My name is &apos; + this.getName() + &apos;.&apos;); &#125;; this.hello = function(person)&#123; console.log(&apos;Hello&apos; + &apos; &apos;+person.name+&apos; &apos;+&quot;I&apos;m&quot;+&apos; ‘+this.getName()) &#125; this.old = function(person)&#123; console.log(&apos;Hello&apos; + &apos; &apos;+&quot;I&apos;m&quot;+&quot; &quot;+this.getName()+&apos; &apos;+&quot;I&apos;m&quot;+&apos; &apos;+this.getAge()+&apos; &apos;+&apos;old&apos;) &#125;&#125;let person2 = new Person( &apos;John&apos;, 10, &apos;male&apos;);person2.greeting(); // &quot;Hello! My name is John.&quot;console.log(person2.getAge()) // 10 屬性描述器 (Property descriptor)是什麼 自己設定的屬性 稱為 屬性的特徵，而設定這些屬性特徵的函式稱為 屬性描述器 就算沒有屬性描述器，我們依然可以撰寫 JavaScript，但使用 屬性描述器 可以讓程式更為強健 有什麼特性 改善過去 constructor 函式與 ES6 Class 語法仍然是「一對一」關係的語法糖，只能宣告成員方法，無法宣告成員屬性 若要用 class 來模擬 private 透過 Object.defineProperty 加上 get、set 來處理 會直接對一個物件定義屬性或是修改現有的屬性。執行後會回傳定義完的物件 用來檢視屬性的特徵 可否寫入(writable) 可否配置(configurable) 可否列舉(enumerable) Object.defineProperty(obj, prop, descriptor) obj 要定義屬性的物件 prop 要被定義或修改的屬性名字 descriptor 要定義或修改物件敘述內容 Object.getOwnPropertyDescriptor() 檢查物件屬性描述器的狀態 屬性描述器（Property descriptor）要透過 ES5 所提供的 Object.defineProperty() 來使用 value: 屬性的值(唯一要設定的) writable: 定義屬性是否可以改變，如果是 false 那就是唯讀屬性(預設：false) enumerable: 定義物件內的屬性是否可以透過 for-in 語法來迭代(預設：false) configurable: 定義屬性是否可以被刪除、或修改屬性內的 writable、enumerable 及 configurable 設定(預設：false) get: 物件屬性的 getter function 回傳有效值 (預設：undefined) set: 物件屬性的 setter function 決定如何處理數據 (預設：undefined) 定義了 get 與 set 方法，表示要自行控制屬性的存取，那麼就不能再去定義 value 或 writable 的屬性描述 123456789101112131415161718192021222324252627282930313233343536373839var person = &#123;&#125;Object.defineProperty(person,&apos;name&apos;,&#123; value:&apos;jimmy&apos;, writable:false // 不可被寫入(自定義)&#125;)// 檢查物件屬性描述器的狀態console.log(Object.getOwnPropertyDescriptor(person, &apos;name’))// &#123;value: &quot;jimmy&quot;, writable: false, enumerable: false, configurable: false&#125;console.log(person.name) // jimmyperson.name=&apos;jj&apos; // writable:true or falseconsole.log(person.name) // jj or jimmy/*----------------------------------function Archiver() &#123; var temperature = null; var archive = []; Object.defineProperty(this, &apos;temperature&apos;, &#123; get: function() &#123; console.log(&apos;get!&apos;); console.log(this) return temperature; &#125;, set: function(value) &#123; temperature = value; archive.push(&#123; val: temperature &#125;); console.log(archive) &#125; &#125;); this.getArchive = function() &#123; return archive; &#125;;&#125;let arc = new Archiver();arc.temperature; // &apos;get!&apos;arc.temperature = 11;arc.temperature = 13;arc.getArchive(); // [&#123; val: 11 &#125;, &#123; val: 13 &#125;] constructor、prototype、proto和原型鏈Function, 對象(object) 對象由函數創建，函數都是 Function 實例對象 Function 函數是 Person 函數的構造函數 Function 函數同時是自己的構造函數 Function 函數同樣是 Object 對象的構造函數 1234function Person()&#123;&#125; console.log(Person.constructor) // ƒ Function() &#123; [native code] &#125;console.log(Function.constructor) // ƒ Function() &#123; [native code] &#125;console.log(Object.constructor) // ƒ Function() &#123; [native code] &#125; 建構式 (Constructor)有什麼特性 有 function 就有 constructor 只能使用 function，不能使用箭頭函式 流程 產生一個新物件的 constructor 屬性設為 Person ，這個 Function 物件建立了一個 Person 建構式 (constructor) ，透過 new 關鍵字來建立各種實例物件 這個物件繼承 Person.prototype (Function 物件) person1 與 person2 是 Person 的實例對象，他們的 constructor 指指向創建它們的 Person 函數 Person 是函數，同時也是 Function 的實例對象，它的 constructor 指向創建它的 Function 函數 Function 函數，它是 JS 的內建對象，它的構造函數是它自己，所以內部 constructor 指向自己 1234567891011121314151617function Person(name,age)&#123; this.name = name this.age = age this.greeting = function()&#123; console.log(&apos;Hello! My name is &apos; + this.name + &apos;.&apos;); &#125;; this.hello = function(Person)&#123; console.log(&apos;Hello&apos; + &apos; &apos;+Person.name+&apos; &apos;+&quot;I&apos;m&quot;+&apos; &apos;+this.name+&apos; &apos;+this.age) &#125;&#125;let person1 = new Person(&apos;jimmy&apos;,30)person1.greeting() // &quot;Hello! My name is jimmy.&quot;let person2 = new Person( &apos;John&apos;, 10);person2.greeting(); // &quot;Hello! My name is John.&quot;person1.hello(person2) // &quot;Hello John I&apos;m jimmy 30&quot; prototype (原型對象) JS 並沒有對所建立的函式區分建構函式與一般的函式，所以只要是函式，就一定會有 prototype 屬性(除了語言內建的函式不會有這個屬性) prototype 存檔點一樣裡面放著許多屬性＆方法(共用) function 自帶 prototype 存檔點 實例物件沒有 prototype(只會繼承上一個的 prototype 方法)，因為實例物件沒有 function 缺點1 constructor 生成的實例對象，有一個缺點就是無法共享屬性和方法(佔記憶體空間) 因為沒有 class，所以它的繼承方法是透過 「原型」(prototype) 來進行實作 12345678// 設定相同方法 但不等於一樣並且佔據記憶體空間person1.atk = function() &#123; console.log(&apos;攻擊&apos;)&#125;person2.atk = function() &#123; console.log(&apos;攻擊&apos;)&#125;console.log(person1.atk === person2.atk) // false 改善 透過「原型」繼承可以讓本來沒有某個屬性的物件去存取其他物件的屬性(可共享) 所有實例物件需要共享的屬性和方法，都放在 prototype 裡面 那些不需要共享的屬性和方法，就放在 constructor 裡面 1234567// 設定共用方法在 prototype 裡面Person.prototype.atk = function()&#123; return this.name+&apos; &apos;+&apos;攻擊&apos; &#125;console.log(person1.atk()) // &apos;攻擊&apos;console.log(person2.atk()) // &quot;攻擊&quot;console.log(person1.atk === person2.atk) // true 缺點2 new Person( ) 出來的多個實例中如果都有 constructor 屬性，並且都指向創建自己的構造函數，所以它們都各自佔據記憶體空間 改善 constructor 可以被當成一個共享屬性存放在 prototype 中，作用也依然是指向自己的 constructor 也就是默認 constructor 是被當做共享屬性放在它們的原型對像 prototype 中 缺點3 如果是共享屬性 constructor，那將兩個實例其中一個屬性改了，為什麼第二個實例沒同步？ 因為 person1.constructor = Function 改的並不是原型對像上的共享屬性 constructor，而是給實例 person1 加了一個 constructor 屬性 可隨意更改新增實例的 constructor 屬性，但無法通過一個 實例.constructor 找回創建自己的構造函數(之間沒有箭頭鏈接) 1234567891011function Person() &#123;&#125;var person1 = new Person()var person2 = new Person()console.log(person1.constructor) // ƒ Person() &#123;&#125;console.log(person2.constructor) // ƒ Person() &#123;&#125;person1.constructor = Functionconsole.log(person1.constructor) // ƒ Function() &#123; [native code] &#125;console.log(person2.constructor) // ƒ Person() &#123;&#125;console.log(person1) // Person &#123;constructor: ƒ&#125;console.log(person2) // ƒ Person() &#123;&#125; 改善 ＿proto＿ 讓實例物件找到自己的原形對象，每個物件都有一個 ＿proto＿ 內部屬性，幫助物件間指向它繼承而來的原型 prototype 物件 ＿proto＿ 這個內部屬性，它是一個存取器(accessor)屬性，意思是用 getter 和 setter 函式合成出來的屬性 用 new 的話必須要有 constructor ，所以 constructor 內的屬性會共享給實例 123456789101112// 創建自己的構造函數console.log(person1.__proto__.constructor) // ƒ Person() &#123;&#125;console.log(person1.constructor) // ƒ Person() &#123;&#125;console.log(person1.constructor === person1.__proto__.constructor) // true// 創建自己的構造函數內部的 prototype（原型對象）console.log(person1.__proto__) // &#123;atk: ƒ, constructor: ƒ&#125;console.log(person1.__proto__.__proto__) // &#123;constructor: ƒ, __defineGetter__: ƒ, __defineSetter__: ƒ, hasOwnProperty: ƒ, __lookupGetter__: ƒ, …&#125;console.log(person1.__proto__.__proto__.constructor) // ƒ Object()console.log(person1.__proto__.__proto__.__proto__) // null 最後完整圖 實例對象.＿proto＿.constructor = 創建自己的 constructor 實例對象.＿proto＿ = 創建自己的 prototype（原型對象共用的東西都在裡面） 實例對象.prototype.＿proto＿.constructor = 原型對象 Object 不會像 Function 一樣指向自己的 protoype ，如果指向那就會進入死回圈 12345678910111213141516171819202122232425console.log(person1.constructor) // ƒ Person() &#123;&#125;console.log(Person.constructor) // ƒ Function() &#123; [native code] &#125;console.log(Function.constructor) // ƒ Function() &#123; [native code] &#125;console.log(Object.constructor) // ƒ Function() &#123; [native code] &#125;console.log(person1.__proto__.constructor) // ƒ Person() &#123;&#125;console.log(Person.__proto__.constructor) // ƒ Function() &#123; [native code] &#125;console.log(Function.__proto__.constructor) // ƒ Function() &#123; [native code] &#125;console.log(Object.__proto__.constructor) // ƒ Function() &#123; [native code] &#125;console.log(Person.__proto__.constructor === Person.constructor) // trueconsole.log(person1.prototype) // undefinedconsole.log(Person.prototype.__proto__.constructor) // ƒ Object() &#123; [native code] console.log(Function.prototype.__proto__.constructor) // ƒ Object() &#123; [native code] &#125;console.log(Object.prototype.constructor) // ƒ Object() &#123; [native code] &#125;console.log(person1.__proto__.__proto__.constructor) // ƒ Object() &#123; [native code] &#125;console.log(Person.__proto__.__proto__.constructor) // ƒ Object() &#123; [native code] &#125;console.log(Function.__proto__.__proto__.constructor) // ƒ Object() &#123; [native code] &#125;console.log(Object.__proto__.__proto__.constructor) // ƒ Object() &#123; [native code] &#125;console.log(Person.prototype.__proto__.constructor === Person.__proto__.__proto__.constructor) // true 原型鏈 (prototype chain) 由 ＿proto＿ 指向連接起來的結構，稱之為原型鏈(prototype chain)，也就是原型繼承的整個連接結構(紅色箭頭) person -&gt; function -&gt; object -&gt; nul 1234567891011console.log(Person.constructor) // ƒ Function() &#123; [native code] &#125;console.log(Person.__proto__) // ƒ () &#123; [native code] &#125;console.log(Person.__proto__.constructor) // ƒ Function() &#123; [native code] &#125;console.log(Person.__proto__.__proto__) // &#123;constructor: ƒ, __defineGetter__: ƒ, __defineSetter__: ƒ, hasOwnProperty: ƒ, __lookupGetter__: ƒ, …&#125;console.log(Person.__proto__.__proto__.constructor) // ƒ Object() &#123; [native code] &#125;console.log(Person.__proto__.__proto__.__proto__) // null 缺點 prototype 的 constructor 很容易被更改 所有所謂繼承下來的屬性全都是共享屬性 12345678910111213141516function GrandFather() &#123; this.name = &apos;GrandFather&apos;&#125;function Father() &#123; this.age = 40&#125;Father.prototype = new GrandFather() // Father 函數改變自己的 prototype 指向function Son() &#123;&#125;Son.prototype = new Father() // Son 函數改變自己的 prototype 指向console.log(Son.prototype.constructor) // ƒ GrandFather()var son = new Son()console.log(son.name) // GrandFatherconsole.log(son.age) // 40 改善 重新指向回自己的 prototype.constructor 123456Son.prototype.constructor = Sonconsole.log(Son.prototype.constructor) // ƒ Son() &#123;&#125;let son2 = new Son()console.log(son2.name) // GrandFatherconsole.log(son2.age) // 40 名詞整理 含義 作用 constructor 建立實例對象的構造函數 容易被更改、放在 prototype 中當共享屬性 prototype 對象的原型對象 存放共享方法 / 屬性、節省記憶體、只要是 function 都有、實例對象沒有這屬性 ＿proto＿ 指向自己的原型對象、構成原型鍊、每個對象都有一個 ＿proto＿ 原型繼承(Prototype-based inheritance)基礎12345678910111213141516171819202122232425262728293031323334353637383940414243function Energy(name,age)&#123; this.name = name this.age = age&#125;// 設定共同方法Energy.prototype.atk = function()&#123; return this.name+&apos; &apos;+&apos;攻擊&apos;&#125;// 實例 1let Hulk = new Energy(&apos;Hulk&apos;,50) // Hulk 自己的方法Hulk.call = function () &#123; return this.name + &apos; 打電話&apos; &#125;console.log(Hulk.call()) // Hulk 打電話console.log(Hulk.atk()) // Hulk 攻擊console.log(Hulk.constructor) // function Energyconsole.log(Hulk.prototype) // undefinedconsole.log(Hulk.__proto__) // &#123;atk: ƒ, constructor: ƒ&#125;console.log(Hulk.__proto__.constructor) // function Energyconsole.log(Hulk.__proto__.__proto__.constructor) // ƒ Object() &#123; [native code] &#125;console.log(Hulk.__proto__.__proto__.__proto__) // null// 實例 2let Iron = new Energy(&apos;Iron&apos;,53)// Iron 自己的方法Iron.call = function () &#123; return this.name + &apos; 打電話&apos; &#125;console.log(Iron.call()) // Iron 打電話console.log(Iron.atk()) // Iron 攻擊// 判斷 constructor function 內外方法是否共用console.log(Hulk.call === Iron.call) // flaseconsole.log(Hulk.atk === Iron.atk) // true// 判斷某個物件是否存在於另一個物件的原型鏈中console.log(Energy.prototype.isPrototypeOf(Hulk)); // true 繼承123456789101112131415161718function Energy(name,age)&#123; this.name = name this.age = age&#125;function Batman()&#123;&#125;console.log(Batman.prototype) // &#123;constructor: ƒ&#125; Batman 未掛載到 Energy// Batman 函數改變自己的 prototype 指向(繼承)Batman.prototype = new Energy(&apos;Batman&apos;,65)// Batman 自己的 methodBatman.speak = function()&#123; return this.name + &apos; 打電話&apos; &#125;console.log(Batman.speak()) // Batman 打電話console.log(Batman.prototype) // Energy&#123;name: &quot;Batman&quot;, age: 65&#125; 已掛載console.log(Batman.prototype.constructor) // ƒ Energy(name,age) 不指向回自己 在 prototype.constructor 底下建立實例，constructor 會指向繼承的 prototype，而原型鍊就不是在 Batman 下 micky2 -&gt; Energy -&gt; Energy -&gt; Object -&gt; null 12345678910111213let micky2 = new Batman()console.log(micky2.name) // Batmanconsole.log(micky2.atk()) // Batman 攻擊console.log(micky2.constructor) // ƒ Energy(name,age)console.log(micky2.prototype) // undefinedconsole.log(micky2.__proto__) // Energy&#123;name: &quot;Batman&quot;, age: 65&#125;console.log(micky2.__proto__.constructor) // ƒ Energy(name,age)console.log(micky2.__proto__.__proto__.constructor) // ƒ Energy(name,age)console.log(micky2.__proto__.__proto__.__proto__.constructor) // ƒ Object()console.log(micky2.__proto__.__proto__.__proto__.__proto__) // nullconsole.log(Energy.prototype.isPrototypeOf(micky2)); // trueconsole.log(Batman.prototype.isPrototypeOf(micky2)); // true 指向回自己 後在 prototype.constructor 底下建立實例，constructor 一樣指向繼承的 prototype，而原型鍊會在 Batman 下 micky -&gt; Batman -&gt; Energy -&gt; Object -&gt; null 12345678910111213141516171819// 指向回自己Batman.prototype.constructor = Batman console.log(Batman.prototype) // Energy&#123;name: &quot;Batman&quot;, age: 65, constructor: ƒ&#125;console.log(Batman.prototype.constructor) // ƒ Batman()&#123;&#125;let micky = new Batman()console.log(micky.name) // Batmanconsole.log(micky.atk()) // Batman 攻擊console.log(micky.prototype) // undefinedconsole.log(micky.constructor) // ƒ Batman()&#123;&#125;console.log(micky.__proto__) // Energy&#123;name: &quot;Batman&quot;, age: 65, constructor: ƒ&#125;console.log(micky.__proto__.constructor) // ƒ Batman()&#123;&#125;console.log(micky.__proto__.__proto__.constructor) // ƒ Energy(name,age)console.log(micky.__proto__.__proto__.__proto__.constructor) // ƒ Object()console.log(micky.__proto__.__proto__.__proto__.__proto__) // nullconsole.log(Energy.prototype.isPrototypeOf(micky)); // trueconsole.log(Batman.prototype.isPrototypeOf(micky)); // true 類別的繼承(Classical inheritance) - class 語法糖前身有什麼特性 Object.create 沒有 constructor ，需要重新定義 模仿了傳統物件導向語言的類別方法，而達到繼承的功能 判斷 判斷某個物件是否存在於另一個物件 傳入對象將作為新建對象的原型 Object.create(prototype, descriptors) 有什麼特性 定義一個物件當作原型物件 原型物件建立另一個新的物件(過程可以加入其他的屬性) 不會執行建構函式，繼承 prototype 的方法＆屬性 參數 prototype 必需，要用作原型的對象，可以為 null(停止 prototype chain) descriptors 屬性描述器 可選，數據屬性包含 value，writable，enumerable，configurable 特性，未指定最後三個特性，則默認為 false 檢索或設置該值， 訪問器屬性包含 set 和/或 get 指定原型且可選擇性地指定屬性 isPrototypeOf prototype.isPrototypeOf(object) 判斷某個物件是否存在於另一個物件的原型鏈結中 instanceof object instanceof constructor 物件 instanceof 函式，回傳 boloon 檢查物件是否為指定的建構子所建立的實體 instanceof 測試實例和原型鏈中出現過的 constructor function，如果存在就會返回 true Object.keys 回傳一個 array，陣列中的各元素為直屬於 obj ，對應可列舉屬性名的字串 組合繼承流程 建立子類別，增加子類別的屬性/方法 選擇要繼承的父類別 prototype(方法自動繼承) 將子類別建立好在掛載到要的父類別 prototype 上 123456789// 父類別function Energy(name,age)&#123; this.name = name this.age = age&#125;Energy.prototype.atk = function()&#123; return this.name+&apos; &apos;+&apos;攻擊&apos;&#125; 兩種新增屬性的方式 用 call(thisAg,arg1,argN…) 強制指定參數帶入父類別屬性 定義新的建構子(SuperEnergy) 1234function SuperEnergy(type,name,age,status,level)&#123; Energy.call(this,type,name,age,status) // 指向新的物件 this.level = level // 子類別自己可新增屬性&#125; 直接新增子類別自己的屬性 1234567function SuperEnergy(name,type,status,level,age)&#123; this.name = name this.type = type this.status = status this.level = level this.age = age &#125; 使用共同方法 將 SuperEnergy.prototype 建立在 Object.create(Energy) 上無法使用共同方法 所以要建立在 Object.create(Energy.prototype) 上 123456789101112131415161718// 掛載到父類別 prototype 上SuperEnergy.prototype = Object.create(Energy.prototype)// 指向回自己SuperEnergy.prototype.constructor = SuperEnergy// 物件實例步驟 // 可定義物件自己的屬性＆方法從 SuperEnergy 產生實例 hulklet hulk = new SuperEnergy(&apos;hulk&apos;,&apos;sencise&apos;,&apos;pace&apos;,&apos;large&apos;,45)hulk.skill = function(name)&#123; return &apos;GAA&apos;+&apos; &apos;+&quot;I&apos;m&quot;+&apos; &apos;+this.name&#125;console.log(hulk.skill()) // GAA I&apos;m hulk GAA I&apos;m Energyconsole.log(hulk.name) // hulk Energyconsole.log(hulk.atk()) // hulk 攻擊console.log(hulk.age) // 45 原型鍊 hulk -&gt; SuperEnergy -&gt; Energy -&gt; Object -&gt; null 1234567891011121314151617181920212223242526console.log(hulk.constructor) // ƒ SuperEnergy(name,type,status,level)console.log(hulk.prototype) // undefinedconsole.log(hulk.__proto__) // Energy &#123;constructor: ƒ&#125; console.log(hulk.__proto__.constructor) // ƒ SuperEnergy(name,type,status,level)console.log(hulk.__proto__.__proto__) // &#123;atk: ƒ, constructor: ƒ&#125;console.log(hulk.__proto__.__proto__.constructor) // ƒ Energy(name,age)console.log(hulk.__proto__.__proto__.__proto__) // &#123;constructor: ƒ, __defineGetter__: ƒ, __defineSetter__: ƒ, hasOwnProperty: ƒ, __lookupGetter__: ƒ, …&#125;console.log(hulk.__proto__.__proto__.__proto__.constructor) // ƒ Object() console.log(hulk.__proto__.__proto__.__proto__.__proto__) // null// 檢查物件是否為指定的建構子所建立的實體console.log(hulk instanceof SuperEnergy) // true console.log(hulk instanceof Energy) // true console.log(SuperEnergy instanceof Energy) // falseconsole.log(hulk.__proto__ === SuperEnergy.prototype) // trueconsole.log(SuperEnergy.__proto__=== Energy.__proto__) // true// 可用的屬性console.log(Object.keys(hulk)) // [&quot;name&quot;, &quot;type&quot;, &quot;status&quot;, &quot;level&quot;, &quot;skill&quot;]// 更改父類別的方法Energy.prototype.atk = function()&#123; return this.name+&apos; &apos;+&apos;先不攻擊&apos; &#125;console.log(hulk.atk()) // &quot;hulk 先不攻擊&quot; 物件繼承1234567891011121314151617let Alien = &#123; type:&apos;evialEnergy&apos;, name: &apos;bloodSpider&apos;, age:&apos;none&apos;, status:&apos;monster&apos;, speak:function(name)&#123; return &quot;I&apos;m&quot;+&apos; &apos;+this.name &#125;&#125;let bloodSpider = Object.create(Alien)console.log(bloodSpider.status) // &quot;monster&quot;console.log(bloodSpider.speak()) // &quot;I&apos;m bloodSpider”console.log(Alien.constructor) // ƒ Object() &#123; [native code] &#125;console.log(Alien.prototype) // undefinedconsole.log(Alien.__proto__) // function Object()console.log(Alien.__proto__.__proto__) // null 建立物件的語法 物件字面定義，相等於 new Object() const newObject = { } 使用 Object.create 方法 const newObject = Object.create( proto ) const newObject = Object.create( proto.prototype ) ES6 類別定義，或是建構函式 const newObject = new ConstructorFunc ( ) const newObject = new ClassName ( ) 類別宣告(class declaration) class 並非如其他物件導向語言般在宣告時期靜態的複製定義，而只是物件間的連結 執行時期變更父類別的方法或屬性，子類別與其實體都會受到影響 class 語法無法宣告屬性，只能宣告方法，因此若想宣告屬性以追蹤共用狀態，就只能回歸到 prototype 為了優化效能，super 是在宣告時期靜態綁定的，在某些狀況下，綁定會失敗，因此必須手動綁定 class 語法只能指定方法，不能設定屬性，這避免開發者誤將屬性（狀態或資料）放在類別中造成的共用問題 class 相當於建立共享方法，宣告自己的屬性 123456789101112131415161718192021222324class Energy&#123;// 宣告自己的屬性 constructor(name,age)&#123; this.name = name this.age = age &#125;// 共享方法 atk()&#123; return this.name+&apos; &apos;+&apos;攻擊&apos; &#125; speak()&#123; return &apos;I`am &apos; + this.name &#125;&#125;let Iron = new Energy(&apos;Iron&apos;,32)console.log(Iron.name) // Ironconsole.log(Iron.atk()) // Iron 攻擊console.log(Iron.speak()) // I`am Ironconsole.log(Iron.constructor) // class Energyconsole.log(Iron.__proto__.constructor) // class Energyconsole.log(Iron.__proto__.__proto__.constructor) // function Object()console.log(Iron.__proto__.__proto__.__proto__) // null 類別繼承 - extends 把子類別掛載到父類別 相當於設定 prototype(＿proto＿) 原型鍊 Energy -&gt; Function -&gt; Object -&gt; null 呼叫父類別 - super 在子類別中，呼叫父類別的方法或屬性來使用 子類必須在 constructor 方法中調用 super 方法，否則新建實例時會報錯 這是因為子類自己的 this 對象，必須先通過父類的構造函數完成塑造，得到與父類同樣的實例屬性和方法，然後再對其進行加工，加上子類自己的實例屬性和方法，如果不調用 super 方法，子類就得不到 this 對象 靜態綁定 - 也就是父類別的方法或屬性不會隨不同子類別變化 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Energy&#123; constructor(name,age)&#123; this.name = name this.age = age &#125; atk()&#123; return this.name+&apos; &apos;+&apos;攻擊&apos; &#125; speak()&#123; return &apos;I`am &apos; + this.name &#125;&#125;/* 這兩句相當於下面的寫法 * SuperEnergy.prototype = Object.create(Energy.prototype) * SuperEnergy.prototype.constructor = SuperEnergy*/class SuperEnergy extends Energy &#123; // 表示屬性來自父類別共用 constructor(name,age,status)&#123; super(name,age) this.status = status &#125; angry()&#123; return this.name+&apos; &apos;+ this.status &#125; // 更改父類別方法名子並直接把相同方法掛載到 SuperEnergy 下 superGa()&#123; return super.speak() &#125;&#125;console.log(SuperEnergy.prototype) // Energy &#123;constructor: ƒ, speak: ƒ&#125;console.log(SuperEnergy.constructor) // ƒ Function() console.log(SuperEnergy.__proto__) // class Energyconsole.log(SuperEnergy.__proto__.constructor) // ƒ Function() console.log(SuperEnergy.__proto__.__proto__) // ƒ () &#123; [native code] &#125;console.log(SuperEnergy.__proto__.__proto__.constructor) // function Function() &#123; [native code] &#125;console.log(SuperEnergy.__proto__.__proto__.__proto__.constructor) // function Object() &#123; [native code] &#125;console.log(SuperEnergy.__proto__.__proto__.__proto__.__proto__) // null 建立繼承實例 原型鍊 SuperEnergy -&gt; Energy -&gt; Object -&gt; null 123456789101112131415161718192021222324252627282930313233343536let hulk = new SuperEnergy(&apos;hulk&apos;,45,&apos;crazy&apos;)// 實例設定自己的方法hulk.skill = function()&#123; return &apos;GAA&apos;+&apos; &apos;+this.name +&apos; &apos;+ &quot;smash&quot; &#125;console.log(hulk.name) // hulkconsole.log(hulk.status) // crazyconsole.log(hulk.age) // 45console.log(hulk.atk()) // hulk 攻擊console.log(hulk.angry()) // hulk crazyconsole.log(hulk.skill()) // GAA hulk smashconsole.log(hulk.speak()) // I`am hulkconsole.log(hulk.superGa()) // I`am hulkconsole.log(hulk.prototype) // undefinedconsole.log(hulk.constructor) // class SuperEnergy extends Energyconsole.log(hulk.__proto__) // Energy &#123;constructor: ƒ, speak: ƒ&#125;console.log(hulk.__proto__.constructor) // class SuperEnergy extends Energyconsole.log(hulk.__proto__.__proto__) // &#123;constructor: ƒ, atk: ƒ&#125; console.log(hulk.__proto__.__proto__.constructor) // class Energyconsole.log(hulk.__proto__.__proto__.__proto__) // &#123;constructor: ƒ, __defineGetter__: ƒ, __defineSetter__: ƒ, hasOwnProperty: ƒ, __lookupGetter__: ƒ, …&#125;console.log(hulk.__proto__.__proto__.__proto__.constructor) // ƒ Object() console.log(hulk.__proto__.__proto__.__proto__.__proto__) // null// 子更動父的方法SuperEnergy.prototype.atk = function()&#123; return this.name+&apos; &apos;+&apos;不要攻擊&apos;&#125;console.log(hulk.atk()) // hulk 不要攻擊","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jimmywei01.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jimmywei01.github.io/tags/JavaScript/"}]},{"title":"JS 紀錄8 - function 3 (Arror function)","slug":"JS-紀錄8-function-3-Arror-function","date":"2019-06-06T07:21:47.000Z","updated":"2019-06-06T12:33:56.031Z","comments":true,"path":"2019/06/06/JS-紀錄8-function-3-Arror-function/","link":"","permalink":"https://jimmywei01.github.io/2019/06/06/JS-紀錄8-function-3-Arror-function/","excerpt":"JavaScript Arror function","text":"JavaScript Arror function Arrow function有什麼特性 箭頭函式本身沒有 this 意思就是說，箭頭函數不會創造一個新的 this，而是從它的外圍作用域一併抓起 箭頭函式 this 代表的是 function 執行時所屬的物件(function在外，function爸爸) 在箭頭函數中，this 綁定定義時的作用域，而不是指向運行時所在的作用域 只能用在匿名函式 隱式回傳(內建return) 箭頭函數使得 this 從 “動態” 變成 “靜態” 作用域 箭頭函数的 this 綁定定義時所在的作用域（即 Timer 函數） 普通函数的 this 指向運行時所在的作用域（即 window） 12345678910111213function Timer() &#123; this.s1 = 0; this.s2 = 0;// 箭頭函数 setInterval(() =&gt; this.s1++, 1000);// 普通函数 setInterval(function () &#123; this.s2++; &#125;, 1000);&#125;var timer = new Timer();setTimeout(() =&gt; console.log(&apos;s1: &apos;, timer.s1),3100); // 3 this = TimersetTimeout(() =&gt; console.log(&apos;s2: &apos;, timer.s2),3100); // 0 this = window 判斷 ( ) =&gt; 表示該變量存儲一個函數 1function() === ()=&gt; 只有一個參數時，括號才能不加 12(singleParam) =&gt; &#123; statements &#125;singleParam =&gt; &#123; statements &#125; 若無參數，就一定要加括號 1() =&gt; &#123; statements &#125; 簡化 callback function 1[1,2,3].map(x =&gt; x * 2) 沒用 花括號 ({}) 也只能在一行的語句的時候使用，會自動加 return 使用 花括號 ({}) 可以加入多行的語句，return 不會自動加，需要自己加上否則得到 undefined 1234567let funcA = x =&gt; x + 1let funcB = x =&gt; &#123; x + 1 &#125;let funC(a,b) =&gt; &#123;return a+b&#125;funcA(1) // 2funcB(1) // undefinedfunC(1,2) // 3 可使用的情況 用 箭頭函式 取出內層(return) myString 參數 (一般要用 隱式綁定) 12345678910111213141516171819202122232425262728293031323334353637383940var myString = &apos;hello global&apos;,obj = &#123;&#125;;function outer() &#123; this.myString = &apos;hello outer&apos;; return () =&gt; &#123; // closure console.log(this) // &apos;hello outer&apos; 未指定 this.myString = &apos;hello arrow function&apos;; // 指定 在箭頭函數裡 console.log(this) // &apos;hello arrow function&apos; &#125;&#125;var arrowFn = outer.call(obj); // outer 綁定外層 this = obj 才可取出內層 console.log(obj.myString); // &quot;hello outer&quot;arrowFn();console.log(obj.myString); // &quot;hello arrow function&quot; console.log(window.myString); // &quot;hello global&quot;/*----------------------------------// 隱式綁定 取出var myString = &apos;hello global&apos;,obj = &#123;&#125;;function outer() &#123; let self = this self.myString = &apos;hello outer&apos;; return (function()&#123; console.log(self) //&apos;hello outer&apos; self.myString = &apos;hello arrow function&apos;; console.log(self) // &apos;hello arrow function&apos; &#125;)&#125;var arrowFn = outer.call(obj); // outer 綁定外層 self = obj 才可取出內層 console.log(obj.myString); // &quot;hello outer&quot; arrowFn();console.log(obj.myString); // &quot;hello arrow function&quot; console.log(window.myString); // &quot;hello global&quot; 不可使用的情況 函式物件中的call、apply、bind，無法“覆蓋”箭頭函式中的 this 值(本身沒有 this) 123456789101112131415161718(function() &#123; return [ (() =&gt; this.x).bind(&#123; x: &apos;inner&apos; &#125;)() ];&#125;).call(&#123; x: &apos;outer&apos; &#125;); // outer/*----------------------------------let family = &#123; ming: &apos;JJ&apos;&#125;const func = () =&gt; &#123; console.log(this);&#125;const func2 = function () &#123; console.log(this);&#125;func.call(family); // 箭頭函式 this 是 windowfunc2.call(family); // 一般函示 this 是 window 箭頭函式無法用於建構式 constructor，使用 new 會產生錯誤 123456789101112131415function MyCat(name) &#123; this.catName = name console.log(this) // window&#125;MyCat.prototype.sayCatName = () =&gt; &#123; return this.catName&#125;MyCat.prototype.sayCatName2 = function()&#123; return this.catName&#125;const cat = new MyCat(&apos;Mew&apos;)console.log(cat.sayCatName()) // undefinedconsole.log(cat.sayCatName2()) // &quot;Mew&quot; 箭頭函式沒有一般函式有的 arguments，如果要可以用 spread 代替 123456function foo(...a) &#123; setTimeout(() =&gt; &#123; console.log(&apos;args:&apos;, a); &#125;, 100);&#125;foo(2, 4, 6, 8) // args: (4) [2, 4, 6, 8] this 如果是用在監聽 DOM 上一樣會指向 window，所以無法使用在此情境 12345678var elements = document.getElementsByTagName(&apos;div&apos;);var changeDOM = () =&gt; &#123; console.log(this); // 指向 window Object this.style.border = &apos;1px solid red&apos;. // 錯誤&#125;for (var i = 0; i &lt; elements.length; i++) &#123; elements[i].addEventListener(&apos;click&apos;, changeDOM, false);&#125; 在物件的 prototype 屬性中定義的方法 this 會指向 window 123456789101112131415function MyCat(name) &#123; this.catName = name console.log(this) // window&#125;MyCat.prototype.sayCatName = () =&gt; &#123; return this.catName&#125;MyCat.prototype.sayCatName2 = function()&#123; return this.catName&#125;const cat = new MyCat(&apos;Mew&apos;)console.log(cat.sayCatName()) // undefinedconsole.log(cat.sayCatName2()) // &quot;Mew&quot; 箭頭函式不能當作 generators 函數使用，使用 yield 會產生錯誤 箭頭函式用於解決一般的 this 問題是可以，但並不適用於全部的情況","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jimmywei01.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jimmywei01.github.io/tags/JavaScript/"}]},{"title":"JS 紀錄7 - this 指向判斷的方式","slug":"JS-紀錄7-this-指向判斷的方式","date":"2019-06-05T06:22:22.000Z","updated":"2019-06-06T05:41:28.582Z","comments":true,"path":"2019/06/05/JS-紀錄7-this-指向判斷的方式/","link":"","permalink":"https://jimmywei01.github.io/2019/06/05/JS-紀錄7-this-指向判斷的方式/","excerpt":"JavaScript this","text":"JavaScript this this 是什麼？ this 用來 ‘傳遞’ 一個 object 的引用 function 呼叫方法會影響 this 在同個範圍(global,function)裡面傳遞不同的東西(物件,變數) this 判定方式 判斷函數被調用時 this 指向誰，立馬看 ( ) 左邊的部分 如果 ( ) 左邊是一個引用(參照)，那麼函數 this 指向的就是這個引用所屬的對象 否則 this 指向的就是全局對象(global) this 會因執行的環境與上下文 (context) 的不同，而有不同的結果 123456789var foo = &#123; baz: function() &#123; console.log(this); &#125;&#125;foo.baz(); // foo object，() 左邊是 baz，baz 屬於 foo，所以指向 foovar anotherBaz = foo.baz;anotherBaz(); // window ，() 左邊是 anotherBaz，anotherBaz 屬於 window，所以這個指向 window context 是什麼？ 函式在被呼叫執行時，所處的物件環境 ‘use strict’ 在非嚴格模式下，this 的內容就會是global 物件 在嚴格模式下，this 的內容就會是 undefined 有什麼方法 默認綁定 Global Object (Window 物件) 隱式綁定 函數功能(function) 顯式綁定 (call、apply、bind) 建構式綁定(constructor) DOM 方法有什麼效果默認綁定 Global Object (Window 物件) 不加任何的修飾符直接調用函數 瀏覽器的執行環境下，global object 指的就是 Window 物件 NodeJS 的執行環境下，global object 指的就是 Global 物件 1234567891011121314151617181920console.log(this) // Window/*----------------------------------function statement() &#123; console.log(this);&#125;statement(); // Window/*----------------------------------let expression = function() &#123;console.log(this);&#125;expression(); // Window/*----------------------------------function statement() &#123;&apos;use strict&apos;console.log(this);&#125;statement(); // undefined 隱式綁定 函數功能(function) 呼叫的物件不同，所以執行的結果也會不同 1234567891011121314151617181920212223// 回到上一層 this = widows 在指定到 a,blet people = function()&#123; return this.name // this 代表的是 function 執行時所屬的物件&#125;// 回到上一層 this = widows 在指定到 alet people = function()&#123; return a.name &#125;let a =&#123; name:&apos;Jimmy&apos;, people:people&#125;let b = &#123; name:&apos;Amy&apos;, people:people&#125;// 在函數中 this 的指向改變了 ，所以 this 不是靜態的 console.log(a.people()) // “Jimmy” &quot;Jimmy&quot;console.log(b.people()) // “Jimmy” “Amy&quot; 物件在指向的時候是 by reference 的方式 window 錯誤 - 在物件方法內再建立方法(function)時，物件屬性值指向 window 並經由 scop china 找到上一層的物件屬性值 所以 再次設定的物件屬性不會等於正確設定的屬性值 可由 let self = this , let that = this 來設定取代 一般寫法 123456789101112131415161718192021222324252627282930313233343536// f1 function 執行完後離開 execution stack ，所以在執行 f2 function 會指定到 windowlet o = &#123; f1: function () &#123; console.log(this); // object let f2 = function () &#123; console.log(this); // window &#125;(); &#125;&#125;o.f1()/*----------------------------------// 在第二個 function 定義 this 還是 window (function in function)let o = &#123; f1: function() &#123; console.log(this); // object let f2 = function() &#123; let self = this console.log(self); // window 錯誤 &#125;(); &#125;&#125;o.f1()/*----------------------------------// 固定變數的 this 值必須在第一個 function 定義 let o = &#123; f1: function() &#123; let self = this console.log(self); // object let f2 = function() &#123; console.log(self); // object 正確 &#125;(); &#125;&#125;o.f1() 嚴格模式 ‘use strict’ 1234567891011121314151617181920212223242526272829303132333435363738394041// 嚴格模式 不允許使用內層 thislet o = &#123; f1: function () &#123; &apos;use strict&apos; console.log(this); // object let f2 = function () &#123; console.log(this); // undefined &#125;(); &#125;&#125;o.f1()/*----------------------------------// 若在 嚴格模式 使用內層 this 要在第一個 function 定義let o = &#123; f1: function() &#123; &apos;use strict&apos; let self = this console.log(self); // object let f2 = function() &#123; console.log(self); // object &#125;(); &#125;&#125;o.f1()/*----------------------------------// 使用嚴格模式在 forEach 中內層 this 不會指向外部 this，而指向 undefinedlet obj =&#123; name:&apos;jan&apos;, friends:[&apos;Tarzan&apos;,&apos;Cheeta&apos;], loop:function()&#123; &apos;use strict&apos; console.log(this) //object this.friends.forEach(function(friends)&#123; console.log(this) // undefined console.log(this.name+&apos; knows &apos;+friends) // error &#125;) &#125;&#125;obj.loop() 解法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// 解法1.指定變數給 thislet obj =&#123; name:&apos;jan&apos;, friends:[&apos;Tarzan&apos;,&apos;Cheeta&apos;], loop:function()&#123; &apos;use strict&apos; let self = this console.log(self) // object self.friends.forEach(function(friends)&#123; console.log(self) // object console.log(self.name+&apos; knows &apos;+friends) //jan knows Tarzan //jan knows Cheeta &#125;) &#125;&#125;obj.loop()/*----------------------------------// 解法2.用 callback function 的特性 [, thisArg] 來指定 this 值let obj =&#123; name:&apos;jan&apos;, friends:[&apos;Tarzan&apos;,&apos;Cheeta&apos;], loop:function()&#123; &apos;use strict&apos; console.log(this) // object this.friends.forEach(function(friends)&#123; console.log(this) // object console.log(this.name+&apos; knows &apos;+friends) //jan knows Tarzan //jan knows Cheeta &#125;,this) &#125;&#125;obj.loop()/*----------------------------------// 解法3.用 bind 強制內層 this 指定為外層 object var obj =&#123; name:&apos;jan&apos;, friends:[&apos;Tarzan&apos;,&apos;Cheeta&apos;], loop:function()&#123; &apos;use strict&apos; console.log(this) //object this.friends.forEach(function(friends)&#123; console.log(this) //object console.log(this.name+&apos; knows &apos;+friends) //jan knows Tarzan //jan knows Cheeta &#125;.bind(this)) &#125;&#125;obj.loop() 顯式綁定 (call、apply、bind) 為什麼要用 顯示綁定？ callback function 中的 this 往往會改變指向，造成不是我們要的結果 明確(強制)指定要執行 function 中的 this 是什麼，就不用透過另一個變數來暫存 this 的方式來獲取 function method call function.call (thisArg, arg1, arg2, ...) 提供的 this 值與傳入參數值(arguments)傳進目標函式 apply function.apply (thisArg, [argsArray]) this 值傳入外，另一個傳入參數值使用 array call apply 兩者共通 重新定義函數的執行環境(this) 使用在 context 較常變動的場景，依照呼叫時的需要帶入不同物件作為該 function 的 this thisArg 可以指定為 null，this 指向為 window 呼叫的當下就立即執行 call apply 差異 傳入參數的形式不同 1234567貓吃魚，狗吃肉，有一天貓不僅想吃肉，還想吃豬肉牛肉羊肉// function.call(thisArg, arg1, arg2, ...)狗.吃肉.call(貓，豬肉，牛肉，羊肉)// function.apply(thisArg, [argsArray])狗.吃肉.apply(貓, [豬肉, 牛肉, 羊肉]) 以 DOM 來看 call 和 apply 可以用來重新定義函數的執行環境(this的指向) 123456789101112function changeStyle(attr, value)&#123;// 自定義屬性 this.style[attr] = value;&#125;console.log(this) // windowlet box = document.getElementById(&apos;box’);window.changeStyle.call(box, &quot;height&quot;, &quot;200px&quot;);console.log(box) // [object HTMLDivElement]window.changeStyle.apply(box, [&apos;height&apos;, &apos;200px&apos;]);console.log(box) // [object HTMLDivElement] thisArg 可以指定為 null，this 指向為 window 1234567function add(a,b)&#123; console.log(a+b) console.log(this)&#125;add(5,3) // 8 windowadd.call(null,5,3) // 8 windowadd.apply(null,[5,3]) // 8 window Math 中用 apply 把 array 當參數傳入直接求 array 中最大值，不用自己去遍歷求值 1234let arr = (6,3,2,8,9)console.log(this) // windowlet max = Math.max.call(null, arr);console.log(max) // 9 bind function.bind (thisArg[, arg1[, arg2[, ...]]]) 前者為套用 this 的物件，後者以後都是 function 的參數 使用 bind 寫死要綁定的物件，可避免函式呼叫時退回到預設綁定 執行 function 前，綁定指定的物件這樣 this 就會是這個物件 新函式在呼叫時，建立一個新函式提供的 this 值與一連串的傳入參數值來進行呼叫，不需要參數則不要傳入即可 常用在像是 callback function 這種類型，可以先綁定好 this，然後讓 function 在需要時才被呼叫 不會立即執行 1234567891011121314151617181920212223var obj = &#123; msg:&apos;Hi!&apos;&#125;// 綁定指定的物件 thissetTimeout(function() &#123; console.log(this.msg); // &quot;Hi!&quot;&#125;.bind(obj), 2000);//-------------------------let cat = &#123; name: &apos;Hello Kitty&apos;&#125;;let dog = &#123; name: &apos;Snoopy&apos;&#125;;// 新函式提供的 this 值function sayHi() &#123; console.log(&apos;Hello, I am &apos; + this.name);&#125;sayHi.bind(cat)(); // &quot;Hello, I am Hello Kitty&quot;sayHi.bind(dog)(); // &quot;Hello, I am Snoopy&quot; 硬綁定(hard binding)是指使用 bind 寫死要綁定的物件，可避免函式呼叫時退回到預設綁定 1234567891011121314151617181920212223242526/*在 bind(foo, obj) 中，將 foo 的 this 強制指定為 obj，並將結果指定給 bar，因此當執行 bar(3) 時，this.a 對 obj 查找屬性 a（找到為 2，並非退回到全域範疇）且加上傳入的數字 3，而得到結果 b 為 5*/function foo(something) &#123; console.log(this.a, something); return this.a + something;&#125;// 簡易的綁定 this 的 helperfunction bind(fn, obj) &#123; return function() &#123; return fn.apply(obj, arguments); &#125;;&#125;var obj = &#123; a: 2&#125;;// 寫死要綁定的物件var bar = bind(foo, obj);var b = bar(3); // 2 3console.log(b); // 5 function currying 類似預設參數 將接受 n 個參數的 function，轉變成 n 個到只接受一個參數的 function 過程 簡化參數的處理，基本上是一次處理一個參數，藉以提高程式的彈性和可讀性 12345678910111213141516171819202122// setTimeout function 的 this 指向為 windowsetTimeout(function()&#123; console.log(this) // window&#125;, 1000);/*----------------------------------// 在 myobj 裡面不是指向 obj 而是 window 造成呼叫時 undefined 找不到結果var myObj = &#123; id: &quot;rettamkrad&quot;, printId: function() &#123; console.log(&apos;The id is &apos;+ this.id + &apos; &apos;+ this.toString()); console.log(this) // window object object &#125;&#125;;setTimeout(myObj.printId, 100); // &quot;The id is undefined [object Window]”setTimeout(myObj.printId.bind(myObj), 100); // bind 寫法// &quot;The id is rettamkrad [object Object]”setTimeout(function()&#123;myObj.printId()&#125;, 100); // closure (IIFE)寫法// &quot;The id is rettamkrad [object Object]” 實例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// function currying function add(a, b) &#123; return a + b;&#125;let add1 = add.bind(null, 1);console.log(add1(2)); // 3console.log(add1(4)); // 5/*----------------------------------// function borrowing// bind,call,apply 借用 person 物件裡面 fullname 這個 methodvar person = &#123; firstname:&apos;Jimmy&apos;, lastname:&apos;Wei&apos;, fullname: function(firstname,lastname)&#123; console.log(this) var name = this.firstname+&quot; &quot;+this.lastname return name; &#125;&#125;// person2 屬性值傳入 person 的 fullname methodvar person2 = &#123; firstname: &apos;Chien-Ming&apos;, lastname: &apos;Wang&apos;&#125;// holiday 取用 person 的 fullname methodvar holiday = function(location1,location2)&#123; console.log(&apos;log: &apos;+this.fullname()) // 取用 person method console.log(&apos;assion: &apos;+location1+&quot; &quot;+location2)&#125;// this = object person// &quot;log: Jimmy Wei&quot;// &quot;assion: taiwan japan&quot;// &quot;assion: londan taiwan&quot;// &quot;assion: usa taiwan&quot;holiday.call(person,&apos;taiwan&apos;,&apos;japan&apos;)holiday.apply(person,[&apos;londan&apos;,&apos;taiwan&apos;])holiday.bind(person,&apos;usa&apos;,&apos;taiwan&apos;)()// person2 跟 person 調用 method// this = object person2// &quot;Chien-Ming Wang”console.log(person.fullname.call(person2))console.log(person.fullname.apply(person2))console.log(person.fullname.bind(person2)()) 建構式綁定(constructor 物件產生時會被呼叫的方法) new constructor[([arguments])] 這個新建構的物件 this 會指向新建構的物件 1234567891011let x = 2;function test(x) &#123; this.x = x || 1 // 預設參數 1 console.log(this) // object&#125;var obj = new test();var obj2 = new test(3);console.log(x) // 2console.log(obj.x) // 1 objectconsole.log(obj2.x) // 3 object DOM 元素觸發事件，this 就指向那個元素 DOM 調用 function 就如同物件調用 function，所以此 this 所指向的則是該 DOM 12345678910function doAlert() &#123; console.log(this) // window console.log(this.innerHTML) // undefined &#125; doAlert(); let myElem = document.querySelector(&apos;#test&apos;); myElem.onclick = doAlert;console.log(myElem.onclick === doAlert); // true myElem.onclick(); // I am an element object 比較優先順序 顯式綁定和建構式綁定無法直接比較(會報錯) 匹配的優先順序由 高至低排列 建構式綁定：this 會指向 new 出來的物件 顯示綁定：使用 call、apply、bind，明確指出要綁定給 this 的物件 隱式綁定：當函式為物件的方法（method）時，在執行階段 this 就會被綁定至該物件 預設綁定：當其他規則都不適用時，沒有使用 bind、call、apply 或不屬於任何物件的 method，就套用預設綁定，在非嚴格下，瀏覽器環境 this 的值就是預設值全域物件 window，而在嚴格模式下，this 的值就是 undefined 結論 this 代表的是 function 執行時所屬的物件 判斷函數被調用時 this 指向誰，立馬看 ( )左邊的部分 function 內用嚴格模式下，默認的 this 就是 undefined 可由 let self = this , let that = this 來設定變數取代 this call、apply、bind 明確(強制)指定要執行 function 中的 this 是什麼，不用設定變數 new 綁定這個新建構的物件 this 會指向新建構的物件 DOM 元素觸發事件，this 就指向那個元素 執行方式 範例語法 this等於 Global this Global object (eg. window) Global Function foo() Global object Object Function myObject.foo() myObject Function using call foo.call(myCall,myArg) myCall Function using apply foo.apply(myCall,[myArgs]) myApply Constructor Function var newObj = new foo() newObj Evaluation eval(thing_to_eval) 等同eval層級 顯式綁定 bind call apply 適用狀況 在執行前先綁定物件做為該 function 的 this，需要時才被呼叫不會立即執行 依照呼叫時的需要帶入不同的物件作為該 function 的 this，在呼叫的當下就立即執行 與 call 相同 傳參數的方式 代入指定的物件 func.bind (thisArg[, arg1[, arg2[, ...]]]) 參數需要一個一個指定 function.call (thisArg, arg1, arg2, ...) 參數使用陣列傳入 function.apply (thisArg, [argsArray]) element.addEventListener 中使用 this ＆ e.target ＆ e.currentTarget 差異 this 總是會拿到被監聽的對象本身，也就是 element.addEventListener() 的 element e.currentTarget === this e.target 則是指事件被觸發時的對象，有可能不是 element 本身 12345678910111213141516171819&lt;div class=&quot;hero&quot;&gt;&lt;h1 contenteditable&gt;🔥WOAH!&lt;/h1&gt;&lt;/div&gt;const hero = document.querySelector(&apos;.hero&apos;)hero.addEventListener(&apos;mousemove&apos;, moveShadow)function moveShadow (e) &#123; console.log(&apos;this&apos;, this) // 回傳的一定是 &quot;.hero” console.log(&apos;currentTarge&apos;, e.currentTarget) // 等同於this// &lt;div class=&quot;hero&quot;&gt;// &lt;h1 contenteditable&gt;🔥WOAH!&lt;/h1&gt;// &lt;/div&gt; console.log(’target&apos;, e.target) // 回傳的可能是 &quot;.hero&quot; 也可能是 “h1” // &lt;h1 contenteditable&gt;🔥WOAH!&lt;/h1&gt; 回傳元素裡面的內容&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jimmywei01.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jimmywei01.github.io/tags/JavaScript/"}]},{"title":"JS 紀錄6 - function 2","slug":"JS-紀錄6-function-2","date":"2019-06-04T01:19:06.000Z","updated":"2019-06-04T13:05:34.817Z","comments":true,"path":"2019/06/04/JS-紀錄6-function-2/","link":"","permalink":"https://jimmywei01.github.io/2019/06/04/JS-紀錄6-function-2/","excerpt":"JavaScript function 紀錄2","text":"JavaScript function 紀錄2 IIFE(Immediately Invoked Functions Expressions) - 立即執行函式有什麼特性 IIFE 在執行環境一讀取到就會立即執行，而不像一般的函式需要呼叫才會執行 限制變數存在的作用域，讓變數不輕易成為「全域變數」的方法 closure 的應用封裝物件的公用與私有成員 希望不同 execution context 的變數之間不要互相影響 判斷 (function () { … })(要執行的) (function () { … }(要執行的)) 寫法 函式表達式 + 匿名函式 1234(function (a, b)&#123; var c = 10; return a + b + c;&#125;)(10,20); // 40 迴圈遇到 function var i 為 global 每次 for 迴圈都用同個記憶體位置紀錄，所以跑完後的值為 5 非同步執行 不會等待 window.setTimeout 結束後才繼續，而是在執行階段就一口氣跑完 12345for(var i = 0; i&lt;5; i++)&#123; window.setTimeout(function() &#123; console.log(i); // 5 5 5 5 5 &#125;,1000)&#125; IIFE window.setTimeout 透過「立即函式」來包裝 為了保留每一次執行迴圈時那個「當下的」i 將它包覆起來然後 i 作為參數傳入 x 12345678for( var i = 0; i &lt; 5; i++ ) &#123;// closure 參數 x 會被內部 function keep 住 (function(x)&#123; window.setTimeout(function() &#123; console.log(x); // 0 1 2 3 4 &#125;, 1000); &#125;)(i);&#125; let 宣告 用 let 的 scope 在 for 迴圈鎖住讓每次跑的迴圈都建立到一個新的記憶體位置 12345for(let i =0;i&lt;5;i++)&#123; window.setTimeout(function()&#123; console.log(i) // 0 1 2 3 4 &#125;,1000)&#125; callback function( heigh order function)有什麼特性 callback function 跟一般的函式沒什麼不同，差別在於被呼叫執行的時機 函式之間的相依過深，ES5 callback 多層之後產生的「波動拳」維護就要用 ES6 Promise, ES7 Async/Await 判斷 把函式當作引數(參數)，透過另一個函式來呼叫它(回傳函式) function A 將 function B 當成參數傳入使用，當這個 function A 執行後會觸發 function B 的執行 寫法 將函式當成參數傳遞給其他函式 12345function get(url,handler)&#123; $.get(url,function(data)&#123; handler(data); &#125;);&#125; 以具名函式方式傳入 (也可以透過匿名函式傳入) 1234567891011121314function callback(data)&#123; $(&apos;.result&apos;).html(data);&#125;get(&apos;ajax/test.html’, callback);/*----------------------------------name(function()&#123; console.log(&apos;My name is jimmy&apos;);&#125;);function name(callback)&#123; var Greeting = &apos;Here is some work...&apos;; callback(); // My name is jimmy&#125; 事件動作(ex.點擊事件)後，呼叫點擊事件內要執行的 function 12// function 可獨立出來box.addEventListener(&apos;click&apos;,function()&#123;&apos;box向左移動&apos;&#125;,false) 多個動作要進行那就必須控制多個 function 間執行的順序(執行順序的排程) 123456789101112function logWord(word)&#123; setTimeout(function()&#123; console.log(word) // b,c,a or c,a,b 沒有固定順序 &#125;,Math.floor(Math.random()*100)+1)&#125;function wordAll()&#123; logWord(&apos;a&apos;) logWord(&apos;b&apos;) logWord(&apos;c&apos;)&#125;wordAll() callback 方式執行順序 12345678910111213141516171819function logWord(word,funCallback)&#123; setTimeout(function()&#123; console.log(word) // &apos;a&apos;,&apos;b&apos;,&apos;c&apos; 固定順序// 傳入型態判定是否為 function if(typeof funCallback === &apos;function&apos;)&#123; funCallback() &#125; &#125;)&#125;function wordAll()&#123;// 決定執行順序 logWord(&apos;a&apos;,function()&#123; logWord(&apos;b&apos;,function()&#123; logWord(&apos;c&apos;,function()&#123;&#125;) &#125;) &#125;)&#125;wordAll() callback 帶入參數(引數) 123456789function showMessage(greeting, name, callback) &#123; console.log(&apos;you call showMessage&apos;) // you call showMessage if(typeof callback === &apos;function&apos;)&#123; callback(greeting, name) &#125; &#125;showMessage(&apos;Hello!&apos;, &apos;Eddy&apos;, function(param1, param2) &#123; console.log(param1 + &apos; &apos; + param2) // Hello! Eddy&#125;) function 傳入參數預設值( || ) ES5 (=)ES6有什麼特性 進行預設值的設定 沒有傳入任何參數，回傳 undefined 這個參數 判斷 用 typeof 的回傳值來判斷是否為undefined，或是用 (=) 或 (||)運算符 的預設值設定方式 123456789101112131415161718// ES5function myfavorite(phone,name,job)&#123; job = job || &apos;bnanan&apos; console.log(phone) console.log(name) console.log(job)&#125;myfavorite() // undefined undefined banana/*----------------------------------// ES6function myfavorite(phone,name=&apos;jimmy&apos;,job)&#123; job = job || &apos;bnanan&apos; console.log(phone) console.log(name) console.log(job)&#125;myfavorite() // undefined jimmy banana function 無名的傳入參數(arguments)有什麼特性 JS 有預設的參數 arguments 可直接帶入，這種參數不須預先設定，所有函式都內建此參數 arguments 雖是一個物件資料類型，但它有”陣列”的一些基本特性，不過缺少大部份陣列中的方法，所以被稱作”pseudo-array”(偽陣列) 判斷 不管有沒有參數的 function 都有 arguments 12345678910111213141516171819202122232425262728293031323334353637// 無參數function sum()&#123; let b = 0 for(i in arguments)&#123; b += arguments[i] &#125; return b&#125;console.log(sum(1,2,3,5)) // 12/*----------------------------------// 有參數function myfavorite(phone,name,job)&#123; job = job || &apos;bnanan&apos; if(arguments.length === 0)&#123; console.log(&apos;呵呵呵’) // &apos;呵呵呵&apos; return &#125; console.log(arguments)&#125;myfavorite()/*----------------------------------// 儲值系統// 先預設裡面沒錢 myMoney// 每儲一次 相加var myMoney = 0function cashMoney()&#123; var machsion = 0 for(var i = 0; i &lt; arguments.length; i++)&#123; machsion +=arguments[i]; console.log(machsion) // 10 110 310 &#125; var machsionMoney = machsion + myMoney console.log(&quot;現在總共儲值”+machsionMoney+”元&quot;)&#125;cashMoney(10,100,200,500) // &quot;現在總共儲值810元” function 不固定傳入參數(Variadic)與其餘參數(spread) ES6有什麼特性 在 function 中定義有三個傳入參數，在呼叫函式時傳入的參數值(arguments)沒有預設的情況下會視為 undefined or NaN，或是多出來的情況是會被直接略過 123456function sum(x, y, z) &#123; return x+y+z&#125;console.log(sum(1, 2, 3)) //6console.log(sum(1, 2)) //NaNconsole.log(sum(1, 2, 3, 4)) //6 改善1 […arguments] 透過變數宣告 12345678910function updateSum()&#123; let num = [...arguments] let sum = num.reduce(function(item,currItem)&#123; return item + currItem &#125;,0) console.log(sum)&#125;updateSum(1,2,3) // 6updateSum(1,2) // 3updateSum(1,2,3,4) // 10 改善 2 (…arg) 透過參數 12345678910function sum2(...arg)&#123; let total = 0 for(let i = 0; i &lt; arg.length; i++)&#123; total+= arg[i] &#125; return total&#125;console.log(sum2(1,2,3)) // 6console.log(sum2(1,2)) // 3console.log(sum2(1,2,3,4)) // 10 判斷 其餘參數 spread (…) (…參數名稱) spread 只是扮演好參數的角色，代表不確定的其他參數名稱 如果一個函式中的參數值有其他的確定傳入參數名稱，其餘參數名稱應該要寫在最後一個位子，而且一個函式只能有一個其餘參數名稱 將類陣列轉為陣列的方式 […spread] Array.from() 範例 其餘參數 1234function moreMoney(...money) &#123; console.log(money); // 100, 200, 300,400&#125;moreMoney(100, 200, 300,400) 使用展開語法，合併陣列 123456let groupA = [&apos;薯條&apos;, &apos;可樂&apos;, &apos;漢堡&apos;];let groupB = [&apos;雞排&apos;, &apos;炸雞&apos;];let groupAll = groupA.concat(groupB)let groupAll2 = [...groupA,...groupB]console.log(groupAll) // [&quot;薯條&quot;, &quot;可樂&quot;, &quot;漢堡&quot;, &quot;雞排&quot;, &quot;炸雞&quot;]console.log(groupAll2) // [&quot;薯條&quot;, &quot;可樂&quot;, &quot;漢堡&quot;, &quot;雞排&quot;, &quot;炸雞&quot;] 淺複製 (shallow copy) 123456let groupA = [&apos;薯條&apos;, &apos;杰倫&apos;, &apos;漢堡&apos;];let groupB = groupA;let groupB = [...groupA] // 將值一個一個取出來在 return 回陣列groupB.push(&apos;阿明&apos;);console.log(groupA); // [&quot;薯條&quot;, &quot;可樂&quot;, &quot;漢堡&quot;, &quot;阿明&quot;]console.log(groupB) // [&quot;薯條&quot;, &quot;可樂&quot;, &quot;漢堡&quot;, &quot;阿明&quot;] 類陣列 Array.from 123456let doms = document.querySelectorAll(&apos;li&apos;);let doms2 = [...doms]let doms3 = Array.from(document.querySelectorAll(&apos;li&apos;)) // 轉為陣列console.log(doms); // NodeList (缺少 array 的方法)console.log(doms2) // arrayconsole.log(doms3) // array 類陣列 […arguments] 1234567891011var originCash = 1000;function updateEasyCard() &#123;let arg = arguments // arg.reduce is not a function (類陣列沒有 array 的方法)let arg = [...arguments] // 轉為陣列let sum = arg.reduce(function (accumulator, currentValue) &#123; return accumulator + currentValue; &#125;, 0); console.log(&apos;我有 &apos; + sum + &apos; 元&apos;);&#125;updateEasyCard(0); // 我有 1000 元updateEasyCard(10, 50, 100, 50, 5, 1, 1, 1, 500); // 我有 718 元 spread 與 arguments 物件的幾個簡單比較 spread 只是代表其餘的傳入參數值，而 arguments 物件是代表所有傳入的參數值 其餘參數傳入值是一個標準陣列，可以使用所有的陣列方法 arguments 是”偽”陣列的物件類型，不能使用陣列的大部份內建方法 spread 需要定義才能使用，arguments 物件不需要定義即可使用，它是隱藏機制 function 遞迴 函式呼叫函式自己的行為 通過呼叫函數本身來重複將問題分解為同類的子問題而解決問題的方法 遞回函式一定記得設定終止條件，否則很容易跳不出來，導致無窮迴圈的情況產生 遞迴函式會收到兩個輸入：結束遞迴的基本情況（base case）或是延續遞迴的遞迴情況（recursive case) 123456789function foo(x) &#123;// 基本情況 if ( x &lt; 5 ) return x// 遞迴情況 return foo(x / 2)&#125;foo(6)foo(10)foo(12) Step1 Step2 Step3 foo(6) (6 / 2) return 3 (3 &lt; 5) return 3 foo(10) (10 / 2) return 5 (5 / 2) return 2.5 (2.5 &lt; 5) return 2.5 foo(12) (12 / 2) return 6 (6 / 2) return 3 (3 &lt; 5) return 3","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jimmywei01.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jimmywei01.github.io/tags/JavaScript/"}]},{"title":"JS 紀錄5 - function","slug":"JS-紀錄5-function","date":"2019-06-03T01:28:43.000Z","updated":"2019-06-03T07:54:37.423Z","comments":true,"path":"2019/06/03/JS-紀錄5-function/","link":"","permalink":"https://jimmywei01.github.io/2019/06/03/JS-紀錄5-function/","excerpt":"JavaScript function 紀錄1","text":"JavaScript function 紀錄1 function 背後運算的邏輯 只要使用 function Global Execution Context（執行全域上下文）就會被建立，這時候會一併建立 this，global object (window) 函式物件(function) 就是一般物件外加可以被呼叫的能力 將 function 儲存成變數 function 當成參數代入另一個 function 中 在 function 中回傳另一個 function 分割片段功能 &amp; 多層級組合 1234var a = function () &#123; &#125; console.log(typeof (a)) // functiona.x = 1;console.log(a.x) // 1 特色 一級物件 (First-class object) 可以被動態建立、可以指定給變數、可以複製給其他變數 可以擁有自己的屬性或方法 (一般物件特性) 提供了變數的作用域 (Scope) 語法 name 函式名稱 param 要被傳入函式的引數名稱，一個函式最多可以擁有 255 個引數 statements statements 構成了函式內容的陳述式 123function name([param[, param[, ... param]]]) &#123; statements&#125; function expressions 和 function declaration - 函數表達式＆函數語句 有什麼特性 建立函式的方式 判斷 expressions 存成一個變數 hoisting 會產生錯誤 無法立即知道該匿名函式的功能，可讀性較差 declaration 匿名函式不會直接回傳任何的值 最開始該函式就會透過 hoisting 先被儲存在記憶體中 函式表達式(function expression) 函式宣告式(function declaration) 具名函式 var add = function add(a, b) { return a + b}; add.name // add function add(a, b) { return a + b }; add.name // add 匿名函式 var add = function (a, b) { return a + b }; add.name // add function (a, b) { return a + b } // Uncaught SyntaxError hoisting 有什麼特性 變數和 function 的宣告在編譯階段中先被放入記憶體，實際在程式碼中位置還是一樣 當 function 與變數/常數同時提升時，function 的優先程度高於變數/常數 如果 hosting 時有兩個 function，最後的 function 會被 hosting 判斷 function 會被完全提升 所以能呼叫 變數宣告 只有所進行的指定(assignments)動作不會提升 所以產生錯誤 123456789101112131415161718// 全域變數var num =5;// 區域變數function test()&#123; var a = 3&#125;console.log(a) // 區域 is not defined 取不到 function 變數 console.log(num) // 全域 5/*----------------------------------var a = 1fnc() // hosting 呼叫 functionfunction fnc()&#123; console.log(a) // hosting undefined var a = 2 console.log(a) // 2&#125;console.log(a) // 1 Scope - lexical scoping(語彙範疇) 「鴨子轉圈圈」就是把大家都匡在這裡，好好待不要亂跑，想出去可是有條件的 有什麼特性 「切分變數有效範圍的最小單位是 “function” 」＝ scope 避免相同變數所造成的衝突，這當中包含了避免污染全域命名空間和模組的管理 判斷 能夠被存取的位置 global function 找尋一個變數的 lexical scoping rule 會從此變數所存在的 function 開始找，如果找到了就返回該變量，如果找不到就往上一層繼續找以此類推直到 global 的環境 scope chain 範圍鏈是在函式被定義的當下 決定的，不是看呼叫(return)的時候決定 可以找到上一層變數＆function function 的 execution context 已經離開 execution stack 了，但這個 execution context 在記憶體中所建立的位置並沒有消失，因此 JS 仍然可以透過 scope chain 找到變數(scope chain 跟變數 close 在一起)而這樣的現象就稱為 closure 123456789101112131415161718192021222324252627282930313233let a = 6function foo(x)&#123; let b = x * 3 function bar(y)&#123; let c = y * b return c &#125; return bar(b)&#125;console.log(foo(a))gobale scope: a,foo()foo scope: x,b,bar()bar scope: y,c以 bar( ) 來說在這 scope 裡面找變數 b，找不到往 foo( ) 找，找到回傳 b = x * 3 往上找的過程叫 scope chain 範圍鏈是在函式被定義的當下決定的，不是在被呼叫(return)的時候決定/*----------------------------------function foo() &#123; var secretData = &apos;HelloWorld&apos;; function bar() &#123; return secretData.split(&apos;&apos;).join(&apos;-&apos;); &#125; return &#123; bar &#125;&#125;var baz = foo();var publicData = baz.bar();console.log(publicData); // H-e-l-l-o-W-o-r-l-dconsole.log(secretData); // Uncaught ReferenceError closure 有什麼特性 不想讓變數直接被操作或修改 避免變數汙染全域的問題 - IIFE 的應用 透過 closure 讓 function 能夠有 private 變數，讓變數保留在該 function 中避免暴露在 global 導致運算出錯 closure 會 keep 住變數佔用記憶體空間，如果這變數沒有在使用 JS 會自己回收 判斷 運用在巢狀函式的定義中 function 內 return 另一個 function，通常就是有用到 closure 的概念 每執行一次 function，就會產生一個新的 execution context，而且即使有多個參數值被儲存在記憶體中，JS 會自己找到屬於該 execution context 的變數 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879// 基本 clouser 範例function add(a)&#123; return function (b)&#123; return function (c)&#123; return a+b+c &#125; &#125;&#125;add(1)(2)(3) // 6/*----------------------------------// 基本 closure 共用 private function// 運用的是同一個 bar() 時，變數間也都是獨立的執行環境不會汙染全域function foo(name) &#123; var x = &quot;hi”;// 真正執行的 function function bar() &#123; console.log( x +&quot; &quot;+name) ; &#125; return bar; // 取不到變成 private === closure&#125;let a = foo(&apos;a&apos;);let b = foo(&apos;b&apos;);a() // hi ab() // hi b/*----------------------------------// 寫法簡化// 不必為裡面的函式命名，可用 return 匿名函式的方式直接把它回傳出來function foo(name) &#123; var x = &apos;hi&apos;;// 真正執行的 function return function() &#123; console.log( x +&apos; &apos;+name) ; &#125;&#125;let a = foo(&apos;a&apos;);let b = foo(&apos;b&apos;);a() // hi ab() // hi b/*----------------------------------// 共用一個環境 在 closure 中使用迴圈// 用 IIFE (closure方式)可解// 用 bind 指定 this 可解for(var i =0;i&lt;5;i++)&#123; setTimeout(function()&#123; console.log(i) &#125;,1000) // 5 5 5 5 5 &#125;/*----------------------------------// 改成 IIFE(closure的應用)for(var i =0;i&lt;5;i++)&#123;// 外部函數被呼叫，並把 i 作為它第一個參數，此時函數內 e 變數就擁有了一個 i 的拷貝 (function(e)&#123; setTimeout(function()&#123; console.log(e) &#125;,1000) &#125;)(i) // 0 1 2 3 4&#125;/*----------------------------------// 為了瀏覽器兼容性用 bind 指定for(var i =0;i&lt;5;i++)&#123; setTimeout(function(e)&#123; console.log(e) &#125;.bind(this,i),1000) // 0 1 2 3 4&#125;/*----------------------------------// 用 let 的特性鎖住區塊for(let i=0;i&lt;5;i++)&#123; setTimeout(()=&gt;console.log(i),1000) // 0 1 2 3 4&#125; 範例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 點擊按鈕取出對應的文字&lt;button id=&quot;first&quot;&gt;First&lt;/button&gt;&lt;button id=&quot;second&quot;&gt;Second&lt;/button&gt;&lt;button id=&quot;third&quot;&gt;Third&lt;/button&gt;// 一般寫法var buttons = document.querySelectorAll(&apos;button&apos;)for (var i = 0; i &lt; buttons.length; i ++) &#123; // buttonName 暴露於 global var buttonName = buttons[i].innerHTML buttons[i].addEventListener(&apos;click&apos;, function()&#123; console.log(buttonName) // Third Third Third &#125;)&#125;/*----------------------------------// es5 建立一個 closure 把資料存在這個 function 當中var buttons = document.querySelectorAll(&apos;button&apos;)for (var i = 0; i &lt; buttons.length; i ++) &#123; // 要執行的 var buttonName = buttons[i].innerHTML buttons[i].addEventListener(&apos;click&apos;, saveButtonName(buttonName),false)&#125;// 建立 closure 簡化寫法// buttonName 被儲存在 closure 當中// buttonName 參數傳入要監聽的 saveButtonName functionfunction saveButtonName(e)&#123; return function()&#123; console.log(e) // First Second Third &#125;&#125; /*----------------------------------// IIFE(closure) var buttons = document.querySelectorAll(&apos;button&apos;)for (var i = 0; i &lt; buttons.length; i ++) &#123; (function(e)&#123; buttons[i].addEventListener(&apos;click&apos;, function()&#123; console.log(e) // First Second Third &#125;) &#125;)(buttons[i].innerHTML) &#125;/*----------------------------------// es6 用 let 建立到一個新的記憶體位置，因此最後指稱到的地方會是不一樣的 var buttons = document.querySelectorAll(&apos;button&apos;)for (let i = 0; i &lt; buttons.length; i ++) &#123;// 每次記錄到不同記憶體位置 let buttonName = buttons[i].innerHTML buttons[i].addEventListener(&apos;click&apos;, function () &#123; console.log(buttonName) // First Second Third &#125;)&#125; return 終止函式執行 ＆ 指定函式返回的值 沒有 return 陳述式（或者光是 return，沒有值），JavaScript 便會傳回 undefined 呼叫 return 的地方後，函式會立即停止 return [[expression]] 1234567891011121314151617181920212223// return 沒有值為 undefinedfunction getRectArea(width, height) &#123; if (width &gt; 0 &amp;&amp; height &gt; 0) &#123; return width * height; &#125; return ;&#125;console.log(getRectArea(3, 4)); // 12console.log(getRectArea(-3, 4)); // undefined/*----------------------------------// 呼叫 return 停止動作function counter() &#123; for (var count = 1; count++) &#123; // 無限迴圈 console.log(count + &apos;A&apos;); // 直到 5 if (count === 5) &#123; return; // 終止迴圈 &#125; console.log(count + &apos;B&apos;); // 直到 4 &#125; console.log(count + &apos;C&apos;); // 永不顯示&#125;counter(); // “1A” “2A” “2B” “3A” “3B” “4A” “4B” “5A&quot;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jimmywei01.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jimmywei01.github.io/tags/JavaScript/"}]},{"title":"JS 紀錄4 - Array","slug":"JS-紀錄4-Array","date":"2019-06-01T07:32:53.000Z","updated":"2019-06-02T02:57:06.121Z","comments":true,"path":"2019/06/01/JS-紀錄4-Array/","link":"","permalink":"https://jimmywei01.github.io/2019/06/01/JS-紀錄4-Array/","excerpt":"JavaScript Array 紀錄","text":"JavaScript Array 紀錄 Array 的方法判別是否為陣列 isArray( ) - 內建 typeof 去檢查陣列得到 “object” 的結果 回傳 true toString.call - 所有情況都可以正確判斷。判斷陣列以外的其他特別物件，缺點是效率最差 Properties (屬性) length - 回傳 Array 元素長度(成員個數) Search(搜尋) includes( ) - 判斷元素有沒有在 Array 裡面 回傳 true | false indexof( ) - 回傳第一個被找到的元素 index；若不存在則回傳 -1 lastIndexof( ) - 回傳最後一個被找到的元素 index；若不存在則回傳 -1 Operation(操作) pop( ) - 移除陣列最後面的值，回傳 被移除掉的值 push( ) - 增加一個 或 多個元素至陣列尾端 ，回傳 陣列的新 length shift( ) - 移除陣列最前面的值，回傳 被移除掉的值 unshift( ) - 增加陣列最前面的值，回傳 陣列的新 length slice( ) - 用淺拷貝(shallow copy)的方式分割元素出子陣列，回傳一個新 Array (舊 Array 不變動) splice( ) - 藉由刪除並／或增加新元素來改變陣列內容，回傳一個改變後的 Array concat( ) - 合併兩個或多個陣列。回傳一個新 Array (舊 Array 不變動) join( ) - 把所有陣列裡的值加上 separator(符號)，回傳一個字串 Iteration (迭代 callback) forEatch( ) - 不會return任何東西 &amp; 中斷，單純執行 function 改變原本陣列裡的事 find( ) - 回傳一個值，且是 第一個 抓到條件為 true 的值，否則回傳 undefined 搜尋陣列中符合條件的物件 findIndex( ) - 尋找符合的元素回傳其 index，若沒有符合的對象則回傳 -1 filter( ) - 回傳一個 Array，只要條件為 true 的所有值 or Array，適合拿來搜尋 map( ) - return 後方為 true 運算後的值 or 新 Array，用在判斷回傳 true | false some( ) - 回傳一個值 false | true，只要部分符合就回傳 true，只要一找到相符的值就跳出 every( ) - 回傳一個值 false | true，需要全部符合才回傳 true Iteration (迭代 callback) - Special reduce( ) - 由 callback function 前後值兩相運算，然後縮減陣列中的元素，最終回傳一個值 收到前一個回傳的值供下一個物件使用，很適合用在累加與比對上 rightReduce( ) - 陣列中每一個值（由右至左）傳入 callback function，最終回傳一個值 Order(排序) sort( ) - 將 Array 排序，排序順序是根據字串的 Unicode 編碼位置（code points）而定 排序過的陣列，不是原陣列的 copy，而是直接更改原陣列 localeCompare - 判斷在目前地區設定中兩個字串是否相等 reverse( ) - 反轉後的 Array Array 方法的效果判別是否為陣列 初始值 1const ary = [&apos;red&apos;,&apos;green&apos;,&apos;blue&apos;] Array.isArray(obj) Obj - 要檢查的物件 1234Array.isArray(ary) // trueArray.isArray(&apos;foobar&apos;) // falseArray.isArray(undefined) // falseObject.prototype.toString.call(variable) === &apos;[object Array]&apos; Properties (屬性) Array.isArray 回傳 Array 元素長度 1ary.length // 6 Method (方法)Search(搜尋) 初始值 1const ary = [9,2,5,3,7,6,1] Array.prototype.includes()(searchElement[, fromIndex]) -&gt; (搜索元素,[元素的索引]) 判斷陣列是否包含特定的元素 回傳 true | false 12345let a = ary.includes(9)let b = ary.includes(0)console.log(a) // trueconsole.log(b) // false Array.prototype.indexOf()(searchElement[, fromIndex]) -&gt; (搜索元素,[元素的索引]) 回傳第一個被找到的元素 index；若不存在則回傳 -1 123456const indexArray = ary.indexOf(3)const notArray = ary.indexOf(8)console.log(indexArray) // 3console.log(notArray) // -1console.log(ary) // [9,2,5,3,7,6,1] Array.prototype.lastIndexOf()(searchElement[, fromIndex]) -&gt; (搜索元素,[元素的索引]) 回傳最後一個被找到的元素 index；若不存在則回傳 -1 123456const indexArray = ary.lastIndexOf(7)const notArray = ary.lastIndexOf(8)console.log(indexArray) // 4console.log(notArray) // -1console.log(ary) // [9,2,5,3,7,6,1] Operation(操作) 初始值 1const color = [&apos;red&apos;,&apos;blue&apos;,&apos;yellow&apos;,&apos;green&apos;] Array.prototype.pop() 移除陣列最後一個元素 123const newColor = color.pop()console.log(newColor) // &quot;green&quot;console.log(color) // [&quot;red&quot;, &quot;blue&quot;, &quot;yellow&quot;] Array.prototype.push() 增加一個 或 多個元素至陣列尾端 123const newColor = color.push(&apos;black’)console.log(newColor) // 5console.log(color) // [&quot;red&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;green&quot;, &quot;black&quot;] Array.prototype.shift( ) 移除陣列最前面的值 123const newColor = color.shift()console.log(newColor) // &quot;red&quot;console.log(color) // [&quot;blue&quot;, &quot;yellow&quot;, &quot;green&quot;] Array.prototype.unshift(element1[, …[, elementN]]) -&gt; (元素1,[元素N]) 增加陣列最前面的值 123const newColor = color.unshift(&apos;black&apos;,&apos;white’)console.log(newColor) // 6console.log(color) // [&quot;black&quot;, &quot;white&quot;, &quot;red&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;green&quot;] Array.prototype.slice([begin[, end]]) -&gt; (元素開始位置,[元素結束位置]) 用淺拷貝(shallow copy)的方式分割出元素值陣列，回傳一個新 array (舊 array 不變動) 12345const newColor = color.slice(-1)const newColor2 = color.slice(1,3)console.log(newColor) // [&quot;green&quot;]console.log(newColor2) // [&quot;blue&quot;, &quot;yellow”]console.log(color) // [&quot;red&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;green&quot;] Array.prototype.splice(start[, deleteCount[, item1[, item2[, …]]]]) -&gt; (元素開始位置,[刪除元素數量],[增加的元素]) 藉由刪除並｜增加新元素來改變陣列內容，回傳一個改變後的 array return 分割出元素值陣列 123456789const newColor = color.splice(-1)const newColor2 = color.splice(0,2)const newColor3 = color.splice(0,3,&apos;c’) // 刪除後增加元素console.log(newColor) // [&quot;green”]console.log(color) // [&quot;red&quot;, &quot;blue&quot;, &quot;yellow&quot;]console.log(newColor2) // [&quot;red&quot;, &quot;blue&quot;]console.log(color) // [&quot;yellow&quot;, &quot;green&quot;]console.log(newColor3) // [&quot;red&quot;, &quot;blue&quot;, &quot;yellow&quot;]console.log(color) // [&quot;c&quot;, &quot;green&quot;] Array.prototype.concat(value1[, value2[, …[, valueN]]]) -&gt; (元素1[, 元素2[, …[, 元素N]]]) 合併兩個或多個陣列，回傳一個新 array (舊 array 不變動) 123const newArray = color.concat([&apos;1&apos;,&apos;4&apos;,&apos;5&apos;,&apos;3&apos;])console.log(newArray) // [&quot;red&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;green&quot;, &quot;1&quot;, &quot;4&quot;, &quot;5&quot;, &quot;3&quot;]console.log(color) // [&quot;red&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;green&quot;] Array.prototype.join([separator]) -&gt; (符號) 把所有陣列裡的值加上 separator(符號)，回傳一個字串 123const newArray = color.join(&quot;-&quot;)console.log(newArray) // &quot;red-blue-yellow-green&quot;console.log(color) // [&quot;red&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;green&quot;] Iteration (迭代 callback) (function callback(currentValue[, index[, array]]) { // your iterator }[, thisAge]) 項目屬姓名可不同 順序要相同 callback 函式將會把 Array 中的每個元素作為參數，帶進 callback 函式裡，每個元素各執行一次，接收三個參數: currentValue(必須) - 原陣列目前所迭代的元素(當前變數) - 元素屬性值 index(選用) - 原陣列目前所迭代的元素 index(當前變數的index) - 元素index array(選用) - 呼叫 forEach() 方法的陣列，也就是上面語法中的 array - 元素array thisAge(選用) - 執行 callback function 時被當作 this 的物件 初始值 123456789const airport = [ &#123;go:&apos;japan&apos;,back:&apos;taiwan&apos;,goTime:&apos;1200&apos;,backTime:&apos;1429&apos;&#125;, &#123;go:&apos;Italy&apos;,back:&apos;New Zealand&apos;,goTime:&apos;1260&apos;,backTime:&apos;2349&apos;&#125;, &#123;go:&apos;Rome&apos;,back:&apos;Austria&apos;,goTime:&apos;0534&apos;,backTime:&apos;1229&apos;&#125;, &#123;go:&apos;Germany&apos;,back:&apos;taiwan&apos;,goTime:&apos;1670&apos;,backTime:&apos;1529&apos;&#125;, &#123;go:&apos;Singapore&apos;,back:&apos;Singapore&apos;,goTime:&apos;1980&apos;,backTime:&apos;2429&apos;&#125;, &#123;go:&apos;Canada&apos;,back:&apos;japan&apos;,goTime:&apos;1230&apos;,backTime:&apos;2349&apos;&#125;, &#123;go:&apos;United States&apos;,back:&apos;Rome&apos;,goTime:&apos;1748&apos;,backTime:&apos;2158&apos;&#125;] Array.prototype.forEach(currentValue, currentIndex, array[, thisArg]) 不會return任何東西，單純執行 function 改變原本陣列裡的事 forEach( ) 不會為沒有值的數組元素執行函數 forEach 這類型的方法無法中斷，如果想要中斷迴圈的執行會建議使用傳統的 for…loop 1234567891011121314151617181920212223let air = airport.forEach(function(i)&#123; return i.go&#125;)console.log(air) // undefined, 不會 return 東西/*----------------------------------airport.forEach(function(i)&#123; i.goTime = 100&#125;)console.log(airport) // goTime 都變為 100/*----------------------------------function logArrayElements(element, index, array) &#123; console.log(&apos;a[&apos; + index + &apos;] = &apos; + element);&#125;// 空值沒用到會跳過[2, 5, , 9].forEach(logArrayElements);/* &quot;a[0] = 2&quot;&quot;a[1] = 5&quot;&quot;a[3] = 9&quot;*/ Array.prototype.find(currentValue, currentIndex, array[, thisArg]) 回傳一個值，且是 第一個 抓到條件為 true 的值，否則回傳 undefined 123456789101112131415const go = airport.find(function(item)&#123; return item.backTime &gt; 1400&#125;)console.log(go)//[object Object] &#123; back: &quot;taiwan&quot;, backTime: &quot;1429&quot;, go: &quot;japan&quot;, goTime: &quot;1200&quot;&#125;/*----------------------------------const j = airport.find(function(item)&#123;&#125;)console.log(j) // undefined Array.prototype.findIndex(currentValue, currentIndex, array[, thisArg]) 尋找符合的元素回傳第一個其 index，若沒有符合的對象則回傳 -1 123456789const go = airport.findIndex(function(item)&#123; return item.backTime &gt; 2400&#125;)console.log(go) // 4/*----------------------------------const j = airport.findIndex(function(item)&#123;&#125;)console.log(j) // -1 Array.prototype.filter(currentValue, currentIndex, array[, thisArg]) 回傳一個 array，只要條件為 true 的就會包含在此陣列，適合拿來搜尋符合條件的參數 是否滿足特定條件並返回一個新 array 123456789101112131415const go = airport.filter(function(item)&#123; return item.backTime &gt; 1800&#125;)console.log(go)/*[&#123;back: &quot;New Zealand&quot;,backTime: &quot;2349&quot;,go: &quot;Italy&quot;,goTime: &quot;1260&quot;&#125;, &#123;back: &quot;Singapore&quot;,backTime: &quot;2429&quot;,go: &quot;Singapore&quot;,goTime: &quot;1980&quot;&#125;, &#123;back: &quot;japan&quot;,backTime: &quot;2349&quot;,go: &quot;Canada&quot;,goTime: &quot;1230&quot;&#125;, &#123;back: &quot;Rome&quot;,backTime: &quot;2158&quot;,go: &quot;United States&quot;,goTime: &quot;1748&quot;&#125;]*//*----------------------------------const j = airport.filter(function(item)&#123;&#125;)console.log(j) // [] Array.prototype.map(currentValue, currentIndex, array[, thisArg]) 將原陣列的每一個元素經由 callback function 運算後所回傳的新 array 用 ES6 ‘=&gt;’ 不用加 return 1234567891011121314151617const go = airport.map(function(item)&#123; return item.backTime * 3&#125;)console.log(go) // [4287, 7047, 3687, 4587, 7287, 7047, 6474]/*----------------------------------const j = airport.filter(function(item)&#123;&#125;)console.log(j) // []/*----------------------------------const mapTime = airport.map(a =&gt; a.goTime)console.log(mapTime) // [&quot;1200&quot;, &quot;1260&quot;, &quot;0534&quot;, &quot;1670&quot;, &quot;1980&quot;, &quot;1230&quot;, &quot;1748”]/*----------------------------------const air = airport.map(num =&gt; num.goTime*2).filter(num =&gt; num &gt; 2100)console.log(air) // [4287, 7047, 3687, 4587, 7287, 7047, 6474] Array.prototype.some(currentValue, currentIndex, array[, thisArg]) 回傳一個值 false | true，只要一找到相符的值就跳出 1234const back = airport.some(function(i)&#123; return i.back = &apos;taiwan&apos;&#125;)console.log(back) // true Array.prototype.every(currentValue, currentIndex, array[, thisArg]) 回傳一個值 false | true，需要全部符合才回傳 true 1234const back = airport.every(function(i)&#123; return i.goTime &gt; 1304&#125;)console.log(back) // fales Iteration (迭代 callback) - Special reduce( ) - (function callback([accumlator, currentValue, index, array]),[initialValue]) rightReduce( ) - (function callback([previousValue, currentValue, index, array]),[initialValue]) callback 函式將會把 Array 中的每個元素作為參數，帶進 callback 函式裡，每個元素各執行一次，接收四個參數: accumlator 前一個參數，如果是第一個陣列的話，值是以另外傳入或初始化的值 暫時存放回呼函式回傳值的累加器(累加器是上一次呼叫後，所回傳的累加數值) 第一個元素從 initialValue 開始，沒有提供 initialValue，則 accumulator 會等於陣列的第一個元素值，且 currentValue 將會等於陣列的第二個元素值 currentValue - 原陣列目前所迭代的元素(當前變數) - 項目屬性值 index(選用) - 原陣列目前所迭代的元素 index(當前變數的 index) - 項目 index 若有傳入 initialValue，則由索引 0 之元素開始，若無則自索引 1 之元素開始 array(選用) - 呼叫 reduce() 方法的陣列 - 項目 array initialValue - 初始值 previousValue - 最後一個元素從 initialValue 開始．若沒有提供 initialValue，則 previousValue 會等於陣列的最後一個元素值，且 currentValue 將會等於陣列的倒數第二個元素值 123456789101112131415161718192021222324252627282930313233343536let people = [ &#123; name: &apos;上校薯條&apos;, money: 500 &#125;, &#123; name: &apos;巨無霸漢堡&apos;, money: 3000 &#125;, &#123; name: &apos;完美薯條&apos;, money: 60000 &#125;];/*----------------------------------var reducePlus = people.reduce(function(accumulator, currentValue, currentIndex, array)&#123;// 分別為前一個回傳值, 目前值, 當前索引值 console.log(accumulator, currentValue, currentIndex); return accumulator + currentValue.money; // 與前一個值相加&#125;, 0); // 傳入初始化值為 0console.log(reducePlus); // 總和為 63500// 比較最大值let max = people.reduce(function(prev,item)&#123; console.log(prev,item.money)/*0 500500 30003000 60000*/ return Math.max(prev,item.money) // 與前一個值比較&#125;,0)console.log(&apos;large&apos;,max) // large 60000 初始值 1let num = [4,2,65] Array.prototype.reduce(accumulator, currentValue, currentIndex, array [, initialValue]) 由 callback function 前後值兩相運算，然後縮減陣列中的元素，最終回傳一個值 1234let a = num.reduce(function(accumulator, currentValue, currentIndex)&#123; return accumulator+currentValue&#125;,0)console.log(a) // 71 callback accumulator currentValue currentIndex array return value First call 0 4 0 [4,2,65] 4 Second call 4 2 1 [4,2,65] 6 Third call 6 65 2 [4,2,65] 71 initialValue - 初始值變更 1234let a = num.initialValue(function(accumulator, currentValue, currentIndex)&#123; return accumulator+currentValue&#125;,100)console.log(a) // 171 callback accumulator currentValue currentIndex array return value First call 100 4 0 [4,2,65] 104 Second call 104 2 1 [4,2,65] 106 Third call 106 65 2 [4,2,65] 171 Array.prototype.reduceRight(accumulator, currentValue, currentIndex, array [, initialValue]) 陣列中每一個值（由右至左）傳入callback function，最終回傳一個值 1234let a = num.reduceRight(function(accumulator, currentValue, currentIndex)&#123; return accumulator+currentValue&#125;,0)console.log(a) // 71 callback accumulator currentValue currentIndex array return value First call 0 65 0 [4,2,65] 65 Second call 65 2 1 [4,2,65] 67 Third call 67 4 2 [4,2,65] 71 initialValue - 初始值 1234let a = num.initialValue(function(accumulator, currentValue, currentIndex)&#123; return accumulator+currentValue&#125;,100)console.log(a) // 171 callback accumulator currentValue currentIndex array return value First call 100 65 0 [4,2,65] 165 Second call 165 2 1 [4,2,65] 167 Third call 167 4 2 [4,2,65] 171 map filter reduce 差異 (這張好懂) map - 就像每一個基本食物素材加工後輸出我想要的樣子 filter - 選我想要吃的 reduce - 把這些食物吃完做後的結果 引用 François-Guillaume Ribreau Order(排序) 初始值 1const num = [40, 1, 5, 200] Array.prototype.sort(compareFunction) 將 array 排序，排序順序是根據字串的 Unicode 編碼位置（code points）而定 123456789101112131415161718const item = num.sort(function(i)&#123; return i&#125;)console.log(item) // [200, 5, 1, 40]// 照數字大小排列let b = num.sort(CompareForSort);console.log(b); // [1, 5, 40, 200]function CompareForSort(first, second)&#123; if (first == second) // 回傳 0，則 a 與 b 不會改變彼此的順序 return 0; if (first &lt; second) // 回傳 -1，則 b 在 a 前面 return -1; else return 1; // 回傳 1，則 a 在 b 前面&#125; Sort 中文字排序 - 用 string的方法 得到中文排序 String.prototype.localeCompare(compareString[, locales[, options]]) string(必要) - 要比較的第一個字串 gtggtggggtgffddfdlocaleCompare - 判斷在目前地區設定中兩個字串是否相等 compareString(必要) - 要比較的第二個字串 locales(選用) - 語言環境 1234567891011// 初始值const fruitArray = [&apos;蘋果&apos;, &apos;芒果&apos;, &apos;櫻桃&apos;, &apos;香蕉&apos;, &apos;大香蕉&apos;, &apos;小香蕉’ ]let s = fruitArray.sort()console.log(s) // [&quot;大香蕉&quot;, &quot;小香蕉&quot;, &quot;櫻桃&quot;, &quot;芒果&quot;, &quot;蘋果&quot;, &quot;香蕉&quot;]//按筆劃從小到大排序fruitArray.sort(function(a,b)&#123; return a.localeCompare(b,&apos;zh-Hans-TW-u-co-stroke&apos;)&#125;)console.log(fruitArray) // [&quot;大香蕉&quot;, &quot;小香蕉&quot;, &quot;芒果&quot;, &quot;香蕉&quot;, &quot;蘋果&quot;, &quot;櫻桃&quot;] Array.prototype.reverse() 反轉後的陣列 1234var a = [&apos;one&apos;, &apos;two&apos;, &apos;three&apos;];var reversed = a.reverse(); console.log(a); // [&apos;three&apos;, &apos;two&apos;, &apos;one&apos;]console.log(reversed); // [&apos;three&apos;, &apos;two&apos;, &apos;one&apos;] 統整 Method Array data return 作用 Search(搜尋) — — — includes( ) 不變 true ｜ false 搜尋陣列中有沒有要找的元素值(boolean) indexof( ) 不變 第一個元素 index / 不存在則回傳 -1 回傳第一個被找到的元素 index lastIndexof( ) 不變 最後一個元素 index / 不存在則回傳 -1 回傳最後一個被找到的元素 index Operation(操作) — — — pop( ) 改變 一個值 移除 Array 尾端的值 push( ) 改變 新 length 增加一個 或 多個元素到 Array 尾端 shift( ) 改變 一個值 移除 Array 最前端的值 unshift( ) 改變 新 length 增加值到 Array 最前端 splice( ) 改變 新 Array 在一定範圍分割出要的 Array 值 or 增加 Array 值 slice() 不變 新 Array 在一定範圍分割出要的 Array 值 concat( ) 不變 新 Array 合併兩個 or 多個 Array join( ) 不變 string 合併符號產生 String Iteration (迭代 callback) — — — forEatch( ) 改變 不會 return 任何東西 無法 break 或者 return false 中斷，會跳過空元素 find( ) 不變 一個值 找到一個符合條件的元素值 findIndex( ) 不變 index 找到一個符合條件的元素值 index filter( ) 不變 值 or Array return 後方為 true 符合條件的所有值 or Array map( ) 不變 值 or Array return 後方為 true 運算後的值 or 新 Array，用在判斷回傳 true｜false some( ) 不變 false｜true 條件部分符合 every( ) 不變 false｜true 條件全部符合 Iteration (迭代 callback) - Special — — — reduce( ) 不變 一個值 接續上一個 or 尾端初始值與元素值進行計算 rightReduce( ) 不變 一個值 接續上一個 or 尾端初始值與元素值從右邊開始進行計算 Order(排序) — — — sort( ) 改變 新 Array 將 Array 排序(依照 Unicode 編碼位置) reverse( ) 改變 新 Array 反轉元素","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jimmywei01.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jimmywei01.github.io/tags/JavaScript/"}]},{"title":"JS 紀錄3 - event、iterator","slug":"JS-紀錄3-event、iterator","date":"2019-05-29T14:56:50.000Z","updated":"2019-05-30T08:45:52.574Z","comments":true,"path":"2019/05/29/JS-紀錄3-event、iterator/","link":"","permalink":"https://jimmywei01.github.io/2019/05/29/JS-紀錄3-event、iterator/","excerpt":"JavaScript event、iterator 紀錄","text":"JavaScript event、iterator 紀錄 事件 eventDOM 語句1document.querySelector(‘input’).textContent=‘hello’ document 取的html文件 querySelector 找到我要的元素 (‘input’) 找到 input 元素 textContent 取得這個元素的文字內容 =‘hello’ 把內容設成 ’hello’ = morningAlarm; 把內容設成變數 oText.innerHTML=index // 標籤中的內容：元素.innerHTML。(網頁tag) oTeat.value=index // 屬性的寫入操作 (網頁表單類) on-event 對應的 function 指的是「事件的處理器」 btn.onclick = function(){} 只能綁定一個事件 addEventListener() 這個「事件的監聽器」基本上有三個參數， 「事件名稱」 「事件的處理器」(事件觸發時執行的 function) 「Boolean」值，由這個 Boolean 決定事件是以「捕獲 true」或「冒泡 false」機制執行，若不指定則預設為「冒泡 false」 可綁定多個事件 事件流程可以分成兩種機制 事件冒泡 (Event Bubbling) 事件捕獲 (Event Capture) Capture 或 Bubbling 誰先誰後呢？ 要看程式碼的順序而定 情境 點擊 &lt;td&gt; 圖片來源: W3C, DOM event flow 12345678910111213141516171819202122232425262728293031323334353637383940414243HTML&lt;div&gt; &lt;div id=&quot;parent&quot;&gt; 父元素 &lt;div id=&quot;child&quot;&gt;子元素&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;JS// 父元素var parent = document.querySelector(&apos;#parent&apos;);// 子元素var child = document.querySelector(&apos;#child&apos;);// 第三個參數 true / false 分別代表 捕獲/ 冒泡 機制parent.addEventListener(&apos;click&apos;, function () &#123; console.log(&apos;Parent Capturing&apos;);&#125;, true); // &quot;Parent Capturing” 捕獲 上～下parent.addEventListener(&apos;click&apos;, function () &#123; console.log(&apos;Parent Bubbling&apos;);&#125;, false);// &quot;Parent Bubbling” 冒泡 下～上child.addEventListener(&apos;click&apos;, function () &#123; console.log(&apos;Child Capturing&apos;);&#125;, true);// &quot;Parent Capturing” 捕獲 上～下// &quot;Child Capturing&quot;// &quot;Parent Bubbling&quot;child.addEventListener(&apos;click&apos;, function () &#123; console.log(&apos;Child Bubbling&apos;);&#125;, false);// &quot;Parent Capturing” 冒泡 下～上// &quot;Child Capturing&quot;// &quot;Child Bubbling&quot;// &quot;Parent Bubbling&quot; 阻擋事件冒泡傳遞 event.stopPropagation() 阻擋事件向上冒泡傳遞 要在元素與元素重疊的情況下使用其中一個元素事件 在 jQuery 的 event handler 最後加上 return false 來得到 preventDefault() 與 stopPropagation() 的效果 但在 JavaScript 的 addEventListener() 裡，最後面加上 return false 只會有 preventDefault() 的效果，不會有 stopPropagation() 的作用 IE 兼容性寫法 1e.stopPropagation ? e.stopPropagation() : e.cancelBubble = true; 123456789// 阻止冒泡 不會在回到父元素child.addEventListener(&apos;click&apos;, function () &#123; e.stopPropagation() console.log(&apos;Child Capturing&apos;);&#125;, false);// &quot;Parent Capturing” 冒泡 下～上// &quot;Child Capturing&quot;// &quot;Child Bubbling&quot; 事件指派 (Event Delegation) 用父元素偵測子元素的作法，這樣才不會綁那麼多監聽導致效能低落 判斷 e.target 是不是我們要的目標節點 e 是紀錄當執行該事件的資訊 target 永遠指向觸發事件的 DOM 物件 處理多個事件目標 12345678910HTML&lt;ul class = &quot;parent&quot;&gt;父 &lt;li class=&quot;child&quot;&gt;子&lt;/li&gt;&lt;/ul&gt;JSparent.addEventListener(&apos;click&apos;,function(e)&#123; if(e.target.nodeName!==&quot;LI&quot;)&#123;return&#125; // 不是 LI 就回傳空白 console.log(e.target.textContent)&#125;) // 點擊 parent 不會有反應 點擊 child 顯示 ‘子&apos; 阻擋預設行為 event.preventDefault() HTML 部分元素會有預設行為，像是 &lt;a&gt; 的連結，或是表單的 submit 等等… 如果要在這些元素上綁定事件，那麼適當地取消它們的預設行為就是很重要的一件事 123456789HTML&lt;a id=&quot;link&quot; href=&quot;https://www.google.com&quot;&gt;Google&lt;/a&gt;JSlet a = document.querySelector(&apos;#link&apos;)a.addEventListener(&apos;click&apos;,function(e)&#123; e.preventDefault() // 執行的是 console 而不是直接帶去 google 的網站 console.log(&apos;Google!&apos;);&#125;) 事件迴圈 even.loop 通過決定何時調用函數以及如何處理異步事件來使用事件循環來創建更流暢的瀏覽體驗 執行方式 簡單 也就是當同步與異步一起執行的時候，同步不用理會異步，異步等同步執行完之後才會執行 詳細 運行程序時，會進行函數調用並將其添加到堆疊(Stack)中 需要等待服務器響應請求的函數回傳它的值與狀態回來然後被發送到單獨的佇列(Queue)，堆疊(Stack)清除後，將執行佇列(Queue)中請求的函數功能拉到堆疊(stack)中去執行 原則 當只有在堆疊(Stack)空空如也時，才會把佇列(Queue)中任務移回堆疊(Stack) 同步(Synchronous, sync)與異步(Asynchronous, async) 同步(Synchronous, sync) 指程式碼的執行順序，都是由上往下依順序執行，一個執行程序完成後才會再接著下一個 但對於 JavaScript 只有單執行緒的程式語言，容易造成阻塞(blocking) 也就是說當這個資料庫查詢的執行程序，需要很長的一段時間才能結束時，在這期間其他的操作都會停擺，像是滑鼠要點按按鈕之類的功能，就完全沒有作用 異步(Asynchronous, async) 先往佇列(task queue)丟，在之後的某個時間再回傳它的值與狀態回來 不是所有的 callback(回調)函式都是會丟到任務佇列(task queue)之中執行，只有經過特殊設計過的異步callback(回調)才會這樣作 含有 callback(回調) function 由上到下執行 會先將 setTimeout 中的 callback function（簡稱 cb）放到 WebAPIs 的計時器中，當時間到時，把該 cb 放到佇列(task queue)內，在「等到」所有堆疊(stack)的內容都被清空(堆疊當中沒有執行項目的時候，event loop 便把佇列(task queue)中的內容拉到堆疊(stack)中去執行)，在「立即」執行這個 cb event loop 的作用是去監控堆疊(stack) 和佇列(task queue)，當堆疊當中沒有執行項目的時候，便把佇列中的內容拉到堆疊中去執行 1234567891011121314// 1 同步執行項目輸出 hi,結束console.log(&apos;hi’) /* 異步cb -&gt; callback function1 setTimeout(cb,5000) -&gt; 2 cb 在 WebAPIs 等待 5000ms-&gt; 3 cb加入到 task queue -&gt; 1 stack 無執行項目 cb 輸出 there,結束 */setTimeout(function () &#123; console.log(&apos;there’) &#125;, 5000) // 1 同步執行項目輸出 JSConfEU,結束console.log(&apos;JSConfEU’) 事件 可能會有一個以上的任務佇列(task queue) 以下是幾種會包含的任務: Events(事件): EventTarget 物件異步分派到對應的 Events 物件 Parsing(解析): HTML parser Callbacks(回調): 呼叫異步回調函式 使用外部資源: 資料庫、檔案、Web I/O DOM處理的反應: 回應DOM處理時的元素對應事件 少數幾個內建的 API 與相關物件有類似的異步機制: setTimeout setInterval XMLHttpRequest requestAnimationFrame WebSocket Worker 某些 HTML5 API，例如 File API、Web Database API 有使用 onload 的 API 異步的程式流程的組織方式，現在也有好幾種作法: Promise 語法結構(ES6) Generators (ES6) Async 函式(ES7) 遍歷器 iterator 可參考 https://medium.com/dubizzletechblog/introduction-to-javascript-iterables-iterators-and-generators-a26be413dfd9 iterator 是一種接口，為不同的數據結構提供統一的訪問機制 iterator 主要供 for…of 使用 ES6 中提供了一些具備原生 iterator 的數據結構( 包括 Array、Map、Set、String、TypedArray、函數的 arguments 、NodeList，不包括 Object)，部署在數據結構的 Symbol.iterator 屬性中 所以也可以說，一種數據結構只要有 Symbol.iterator 屬性，就稱之為可遍歷 iterator 的遍歷過程 創建一個對象，指向當前數據結構的起始位置 第一次調用對象的 next()，可以指向數據結構的第一個成員 第二次調用對象的 next()，就指向數據結構的第二個成員 不斷調用對象的 next()，直到它指向數據結構的結束位置 next() next() 必須總是回傳一個包含符合 done 及 value 屬性的物件 假如回傳了一個非物件值（如 false 或 undefined），則將會拋出一個 TypeError 錯誤 done（布林值） 若迭代完整個序列，則值為 true。在這個情況下 value 可以是代表迭代器的回傳值 若迭代器能夠產出序列中的下一個值，則值為 false。相當於完全不指定 done 屬性 value - 任何由迭代器所回傳的 JavaScript 值 可於 done 為 true 時省略 123456789101112131415161718192021const arr = [1,4,2];const iter = arr[Symbol.iterator]();console.log(iter.next()); // &#123;value: 1, done: false&#125;console.log(iter.next()); // &#123;value: 4, done: false&#125;console.log(iter.next()); // &#123;value: 2, done: false&#125;console.log(iter.next()); // &#123;value: undefined, done: true&#125;var it = makeIterator([&apos;a&apos;, &apos;b&apos;]);function makeIterator(array) &#123; var nextIndex = 0; return &#123; next: function() &#123; return nextIndex &lt; array.length ? &#123;value: array[nextIndex++], done: false&#125; : &#123;value: undefined, done: true&#125;; &#125; &#125;;&#125;console.log(it.next()) // &#123; value: &quot;a&quot;, done: false &#125;console.log(it.next()) // &#123; value: &quot;b&quot;, done: false &#125;console.log(it.next()) // &#123; value: undefined, done: true &#125; for1234let iterable = &quot;boo&quot;;for (let i=0;i&lt;iterable.length;i++)&#123; console.log(i+iterable[i]) // &apos;0b&apos;,&apos;1o&apos;,&apos;2o&apos;&#125; for..in 使用範圍 把該物件中的所有屬性名稱和屬性值都呼叫出 透過建構函式（constructor function ）來建立物件時，這個物件可能會繼承該函式建構式的一些屬性或方法，這時候直接使用 for…in 時，這些繼承而來的屬性和方法也會被一併輸出 object 12345678var obj = &#123; a: 1, b: [], c: function () &#123;&#125;&#125;;for (var key in obj) &#123; console.log(key); // &apos;a&apos; &apos;b&apos; &apos;c&apos;&#125; array 得到 index 得到 value 得到 index , value 得到 index , object prototype 無法取值 12345678910111213141516171819202122var arr = [3, 5, 7];for (var i in arr) &#123; console.log(i); // 0 1 2&#125;var arr = [3, 5, 7];for (var i in arr) &#123; console.log(arr[i]); // 3 5 7&#125;var arr = [3, 5, 7];for (var i in arr) &#123; console.log(i, arr[i]); // &apos;0&apos; 3 , &apos;1&apos; 5 , &apos;2&apos; 7&#125;Object.prototype.objCustom = function()&#123;&#125;; Array.prototype.arrCustom = function()&#123;&#125;;var arr = [3, 5, 7];arr.foo = &apos;hello&apos;;for (var i in arr) &#123; console.log(i); // “0&quot; “1&quot; “2&quot; “foo&quot; “arrCustom&quot; &quot;objCustom&quot;&#125; hasOwnProperty 不會往上檢查物件的原型鏈 (prototype chain)，只會檢查物件本身是否存在這個屬性 Array index 依然存在無法取值 123456789Object.prototype.objCustom = function()&#123;&#125;; Array.prototype.arrCustom = function()&#123;&#125;;var arr = [3, 5, 7];arr.foo = &apos;hello&apos;;for (var i in arr) &#123; if (arr. hasOwnProperty (i)) &#123; console.log(i); // 0 1 2 foo &#125;&#125; forEach forEach(function(item(參數項目), index(參數索引),array(陣列本身)){}) forEach 的時候是無法 break 或者 return false 中斷 1234567var arr = [3, 5, 7];arr.forEach(function (value) &#123; console.log(value); // 3 5 7 if (value == 5) &#123; return false; &#125;&#125;); for…of 目的通常是為了逼近所需目標或結果(魔術方塊的概念) 每一次對過程的重複稱為一次“迭代”，而每一次迭代得到的結果會作為下一次迭代的初始值。重複執行一系列運算步驟 使用範圍 Array、Set 和 Map 結構、類Array（比如 arguments、NodeList）、Generator 對象，以及 String 中斷 for…of，可以使用 break、continue、throw 或 return Array 得到 value 123456789101112let obj = [10,20,30]for (var value of obj) &#123; console.log(value); // 10 20 30&#125;var arr = [3, 5, 7];for (let value of arr) &#123; console.log(value); // 3 5 if (value == 5) &#123; break; &#125;&#125; String 1234let iterable = &quot;boo&quot;;for (let value of iterable) &#123; console.log(value); // &apos;b&apos; &apos;o&apos; &apos;o&apos;&#125; Map 會 return 回處理好的值，為新的 array people.map(function( item, index, array ){}) 12345678let iterable = new Map([[&quot;a&quot;, 1], [&quot;b&quot;, 2], [&quot;c&quot;, 3]]);for (let [key, value] of iterable) &#123; console.log(value); // 1 2 3&#125;for (let entry of iterable) &#123; console.log(entry); // [&quot;a&quot;, 1] [&quot;b&quot;, 2] [&quot;c&quot;, 3]&#125; Set new Set([iterable]) 類陣列，但是成員的值都是唯一的，沒有重複的值 如果要轉為陣列，用 Array.form 1234let iterable = new Set([1, 1, 2, 2, 3, 3]);for (let value of iterable) &#123; console.log(value); // 1 2 3&#125; arguments 12345(function() &#123; for (let argument of arguments) &#123; console.log(argument); // 1 2 3 &#125;&#125;)(1, 2, 3); NodeList 原先用 Array.from(querySelectorAll) 轉成 array 在用 forEach 取出值 1234let elements = document.querySelectorAll(&apos;body&apos;);for (let element of elements) &#123; console.log(element.tagName); // body&#125; enumerable 屬性 for–of 並不能直接使用在普通的對像上，但如果我們按對象所擁有的屬性進行循環，可使用內置的 Object.keys() ，取得物件的 key 123for (var key of Object.keys(someObject)) &#123; console.log(key + &quot;: &quot; + someObject[key]);&#125; TypedArray 12345let typeArr = new Uint8Array([0x00, 0xff]);for (let value of typeArr) &#123; console.log(value); // 0 255&#125; 循環一個生成器(generators) 1234567891011121314function* fibonacci() &#123; // a generator function let [prev, curr] = [0, 1]; // 解構 while (true) &#123; [prev, curr] = [curr, prev + curr]; yield curr; &#125;&#125;for (let n of fibonacci()) &#123; console.log(n); // truncate the sequence at 1000 if (n &gt;= 1000) &#123; break; &#125;&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jimmywei01.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jimmywei01.github.io/tags/JavaScript/"}]},{"title":"JS 紀錄2 - 包裹物件、自動轉型","slug":"JS-紀錄2-包裹物件、自動轉型","date":"2019-05-28T14:06:30.000Z","updated":"2019-05-29T14:59:22.083Z","comments":true,"path":"2019/05/28/JS-紀錄2-包裹物件、自動轉型/","link":"","permalink":"https://jimmywei01.github.io/2019/05/28/JS-紀錄2-包裹物件、自動轉型/","excerpt":"JavaScript 轉型觀念紀錄","text":"JavaScript 轉型觀念紀錄 原始型別(Primitive Type) - 不允許自由擴增屬性 但卻有屬性 &amp; 方法可以使用，因為有原始型別包裹物件 (primititve type wrapper type) ＆ 父元素的關係 null, undefined 沒有原始型別包裹物件 string, number, boolean 物件型別(Object Type) - 可以自由擴增屬性 原始型別包裹物件 (primititve type wrapper type) 主要用途 透過包裹物件的 toPrimitive 中的 valueOf() ＆ toString() 將原始型別產生物件型別的特性，自由擴增屬性與方法 toPrimitive toPrimitive(input [, PreferredType]) input 代入的值 PreferredType 會依照設定的首選的類型，決定要先後呼叫 valueOf 與 toString 的順序 valueOf() 取得物件內部的原始型別的值 (Primitive Value) toString() 取得物件內部的原始型別的值 (Primitive Value) 並轉換成字串型別 沒有提供這個值也就是預設情況，則會設定轉換的 hint 值為 “default” 轉換方式 如果 input 是原始資料類型，則直接回傳 input PreferredType 為 Number 首選類型時，優先使用 valueOf，然後再呼叫 toString PreferredType 為 String 首選類型時，優先使用 toString，然後再呼叫 valueOf 預設呼叫方式則是先呼叫 valueOf 再呼叫 toString，否則，拋出TypeError錯誤 兩個例外，一個是 Date 物件預設首選類型是字串(String)，另一是 Symbol物件，它們覆蓋了原來的 PreferredType 行為 簡略規則 undefined -&gt; undefined（基本型別值，不轉換） null -&gt; null（基本型別值，不轉換） boolean -&gt; boolean（基本型別值，不轉換） number -&gt; number（基本型別值，不轉換） string -&gt; string（基本型別值，不轉換） object：使用 [[DefaultValue]] 內部方法，依照傳入的參數決定要使用 toString 或 valueOf 取得原始型別值 Date 首選類型為 String，它優先使用 toString 來進行轉換，最後字串連接運算 11 + (new Date()) // &quot;1Sun Nov 27 2016 01:09:03 GMT+0800 (CST)&quot; Date 物件中的 valueOf 回傳值，需要使用一元加號(+)，來強制轉換它為數字類 1+new Date() // 1480180751492 Object valueOf() 回傳值: 物件本身 toString() 回傳值: “[object Object]” 字串值，不同的內建物件的回傳值是 “[object type]”字串，”type” 指的是物件本身的類型識別 123var a = &#123;age:20&#125;a.valueOf() // &#123;age: 20&#125;a.toString() // &quot;[object Object]&quot; Array valueOf() 回傳值: 物件本身 toString() 回傳值: 相當於用陣列值呼叫 join(‘,’) 所回傳的字串,也就是 [1,2,3].toString() 會是 “1,2,3”，這點要特別注意 123var b = [&apos;hot&apos;,&apos;cold’]b.valueOf() // [&quot;hot&quot;, &quot;cold”]b.toString() // &quot;hot,cold&quot; Function valueOf() 回傳值: 物件本身 toString () 回傳值: 函式中包含的程式碼轉為字串值 1234567891011121314function Person (name,age)&#123; this.name = name this.age = age &#125;var p1 = new Person1(&apos;Jim&apos;,20)Person.prototype.valueOf = function () &#123; return this.age;&#125;;Person.prototype.toString = function () &#123; return this.name;&#125;;p1.valueOf() // 20p1.toString() // &quot;Jim&quot; 轉型過程的抽象值運算 toPrimitive 賦予 String, Number, Boolean 有 valueOf() ＆ toString() 方法 JSON.stringify JSON 的字串化 無法轉為 JSON 字串的非法值有 undefined、function、symbol、具有循環參考（circular reference）的物件 1234JSON.stringify(42) // &quot;42&quot;JSON.stringify(true) // &quot;true&quot;JSON.stringify(null) // &quot;null&quot;JSON.stringify(&apos;Hello World&apos;) // &quot;&quot;Hello World&quot;&quot;，字串會在外面再包一層引號 String 任何非字串的值被強制轉型為字串 1234String([1,2,3]) // “1,2,3&quot;String([&#123;&#125;]) // &quot;[object Object]”String(false) // “false&quot;String(0) // &quot;0&quot; Number 將非數字值當成數字來操作 1234567Number(undefined) // NaNNumber(null) // 0Number(true) // 1Number(false) // 0Number(&apos;12345&apos;) // 12345Number(&apos;Hello World&apos;) // NaNNumber(&#123; name: &apos;Jack&apos; &#125;&#125;) // NaN Boolean Truthy 與 Falsy 的概念 1234Boolean(false) // falseBoolean(&apos;1’) // trueBoolean([]) // trueBoolean(&#123;&#125;) // true 自動轉型 物件型別來比較原始型別，所有的物件型別物件，一定會透過 toPrimitive 裡面的 valueOf() 或 toString() 先轉成原始型別物件，然後才進行比較，這就是「自動型別轉換」 強制轉型（coercion）分為兩種「明確的」強制轉型 (explicit coercion) 程式碼中刻意寫出來的型別轉換的動作123456789String(123) // &quot;123&quot;(123).toString() // &quot;123&quot;Number(&apos;123&apos;) // 123+(&apos;123’) // 123-(&apos;-123&apos;) // 123String(123) // “123&quot;Math.floor(-29.8) // -30~~-29.8 // -29-29.8 | 0 // -29 「隱含的」強制轉型 (implicit coercion) 程式碼中沒有明確指出要轉換型別卻轉型的123456&quot;0&quot; == false; // true，字串轉數字、布林再轉數字false == 0; // true，布林轉數字false == “”; // true，字串轉數字、布林再轉數字false == []; // true，布林轉數字、陣列取 toString 得到空字串再轉數字false == &#123;&#125;; // false，布林轉數字、物件取 valueOf 得到空物件&quot;&quot; == 0; // true，字串轉數字 + 運算子是數字的相加，還是字串的串接？ 兩運算元的型別不同，當其中一方是字串時，+ 所代表的就是字串運算子，而會將另外一個運算元強制轉型為字串，並連接兩個字串 [] + {} 中，[] 會轉為空字串，而 {} 會轉為字串 “[object Object]” {} + [] 中，{} 被當成空區塊而無作用， +[] 被當成強制轉型為數字 Number([]) （由於陣列是物件，中間會先使用 toString 轉成字空串，導致變成 Number(‘’)）而得到 0 12345678910111213const a = &apos;1&apos;;const b = 1;const c = [1, 2];const d = [3, 4];a + 1 // &quot;11&quot;b + 1 // 2b + &apos;&apos; // &quot;1&quot;c + d // “1,23,4&quot;[] + &#123;&#125; // &quot;[object Object]&quot;&#123;&#125; + [] // 0-&gt; [].toString() // “” 在什麼狀況下會隱含地將值強制轉為布林呢？ if 述句中的條件判斷 for 述句中的條件判斷，意即測試運算式的第二個子句 while 與 do…while 中檢測條件是否成立的測試運算式 三元運算式 條件 ? 值1 : 值2 中的條件運算，意即測試運算式的第一個子句 邏輯運算子的 ||（or) 和 &amp;&amp;（and）左手邊的運算元會被當成測試運算式 12345678910111213141516171819var a = 12345;var b = &apos;Hello World&apos;;var c; // undefinedvar d = null;if (a) &#123; // true console.log(&apos;a 是真的&apos;); // a 是真的&#125;while (c) &#123; // false console.log(&apos;從來沒跑過&apos;);&#125;c = d ? a : b;console.log(c) // &quot;Hello World&quot;if ((a &amp;&amp; d) || c) &#123; // true console.log(&apos;結果是真的&apos;); // 結果是真的&#125; 比較運算 大家都知道 兩個等號 ( == ) 比對兩邊物件時，JavaScript 會自動轉型，然後才進行比對 怎麼自動轉型？ 它是透過 toPrimitive 的 valueOf() 或 toString() 轉換 除此之外，可以自訂 valueOf() 或 toString() 所以結果 當 JavaScript 任意物件在進行 比較運算 時，都會先執行 valueOf() 或 toString() ，取回該物件相對應原始型別的值，看當下兩邊比較的是甚麼原始型別，然後再進行比較 若有任一值轉型後的結果不是字串，就使用 Number 的規則轉為數字，來做數字上的比較 種類相等比較 可分為 ==（寬鬆相等）、===（嚴格相等）、!=（寬鬆不相等）、!==（嚴格不相等），主要差異是在做值的比較時是否會做強制轉型 == 和 === 其實都會做型別的檢查，只是當面對型別不同時的反應是不一樣 12345const a = &apos;100&apos;;const b = 100;a == b // true，強制轉型，將字串 &apos;100&apos; 轉為數字 100a === b // false 簡略規則 型別相同，就會以同一型做比較，但要注意 NaN 不等於自己（其實，NaN 不大於、不小於也不等於任何數字，所以當然也不等於它自己） +0、-0 彼此相等 物件（含 function 和 array）的相等是比較參考（reference），若參考相等才是相等 型別不同，將其中一個或兩個值先做強制轉型，再用型別相同的做比較 字串轉為數字 布林轉為數字 null 與 undefined 在寬鬆相等下會強制轉型為彼此，因此是相等的但不等於其他值， 若比較的對象是物件，使用 valueOf()（優先）或 toString() 將物件取得基本型別的值，再做比較 而 != 和 !== 就是先分別做 == 和 === 再取否定（!） 123456789101112131415161718192021222324252627282930null === undefined // falsenull == undefined // true// 在 a == b 當中，字串 a 優先轉為數字後，此時就可比較 123 == 123，因此是相等的（true）const a = &apos;123&apos;;const b = 123;a === b // falsea == b // true// 在 a == b 當中，布林 a 優先轉為數字（Numer(true) 得到 1）後，此時就可比較 1 == 123，因此是不相等的（false）const a = true;const b = 123;a === b // falsea == b // false// 在 a == b 當中其實比較的是 null == 123，因此是不相等的（false）const a = null;const b = 123;a === b // falsea == b // false//在 a == b 當中，陣列 a 由於沒有 valueOf()，只好使用 toString() 取得其基型值而得到字串 &apos;1,2,3&apos;，此時就可比較 &apos;1,2,3&apos; == &apos;1,2,3&apos;，因此是相等的（true）const a = [1,2,3];const b = &apos;1,2,3&apos;;a === b // falsea == b // true 大小比較 &lt;（小於）、 &gt;（大於）、&lt;=（小於等於）、&gt;=（大於等於） 例如：a &gt; b 表示比較 a 是否大於 b 簡略規則 若兩個運算元皆為字串時，就直接依照字典字母順序做比較 注意 由於規格只定義了 a &lt; b 的演算法，因此 a &gt; b 會以 b &lt; a 的方式做比較 由於沒有「嚴格關係比較」(===)，所以一定會遇到強制轉型的狀況 123456789101112131415161718// 由於 a 和 b 都不是字串且陣列沒有 valueOf，因此先用 toString 取得基型值，得到 a 為 &apos;12&apos;、b 為 &apos;13&apos;，型別都是字串，接著做字母順序的比較const a = [12];const b = [&apos;13&apos;];a &lt; b // true，&apos;12&apos; &lt; &apos;13&apos;a &gt; b // false，其實是比較 b &lt; a，即 &apos;13&apos; &lt; ’12&apos;// 先用 valueOf 取得基型值（只取到原來的物件），再用 toString 而得到兩個字串 [object Object]，因此比較 [object Object] 與 [object Object]// a == b 比較的是兩物件存值的所在的記憶體位置，也就是參考（reference）const a = &#123; b: 12 &#125;;const b = &#123; b: 13 &#125;;a &lt; b // false，&apos;[object Object]&apos; &lt; &apos;[object Object]&apos;a &gt; b // false，其實是比較 b &lt; a，即 &apos;[object Object]&apos; &lt; &apos;[object Object]&apos;a == b // false，其實是比較兩物件的 referencea &gt;= b // truea &lt;= b // true 例外 null 與 undefined 沒有其物件包裹形式，因此 Object(null) 與 Object(undefiend) 等同於 Object()，也就是空物件 {} Number(NaN) 得到 NaN，且 NaN 不等於自己 1234567891011var a = null;var b = Object(a); // 等同於 Object()a == b; // falsevar c = undefined;var d = Object(c); // 等同於 Object()c == d; // falsevar e = NaN;var f = Object(e); // 等同於 new Number(e)e == f; object 在 JavaScript 裡，所有的物件都是不相等的，每一個都是獨立的物件實體，即便實作了 valueOf 或 toString 方法，還是無法對使用者定義物件進行任何相等比較運算 任何兩個物件相比都是 false 12345&#123;&#125; = &#123;&#125; // &#123;&#125;&#123;&#125; == &#123;&#125; // false&#123;&#125; === &#123;&#125; // false 兩個相同物件比較都是 true 12345678let a = &#123;&#125;a.name = &#123;&#125;let b = &#123;&#125;b.name = &#123;&#125;a == b // falsea === b // true 運算子 || (or) 與 &amp;&amp; (and) 在兩個運算元當中「選擇」其中一個運算元的值作為結果 簡略規則 ||（or） 和 &amp;&amp;（and）會將第一個運算元做布林測試或強制轉型為布林以便測試 對 ||（or）來說，若結果為 true，則取第一個運算元為結果；若結果為 false，則取第二個運算元為結果 對 &amp;&amp;（and）來說，若結果為 true，則取第二個運算元為結果；若結果為 false，則取第一個運算元為結果 可應用於 ||（or） 可用來設定變數的初始值 &amp;&amp;（and）可用來執行「若特定條件成立，才做某件事情」，功能近似 if 述句 12345678910111213141516const a = &apos;Hello World!&apos;const b = 777;const c = null;a &amp;&amp; c // 測試 a 為 true，選 c，結果是 nulla &amp;&amp; b // 測試 a 為 true，選 b，結果是 777undefined &amp;&amp; b // 測試 undefined 為 false，選 undefined，結果是 undefineda || b // 測試 a 為 true，選 a，結果是 &quot;Hello World!&quot;c || &apos;foo&apos; // 測試 c 為 false，選 &apos;foo&apos;，結果是 &quot;foo&quot;const flag = true;function foo() &#123; console.log(&apos;try me&apos;);&#125;flag &amp;&amp; foo(); // try me Symbol 強制轉型 屬性名現在可以有兩種類型，一種是原來就有的字串，另一種就是新增的 Symbol 類型 凡是屬性名屬於 Symbol 類型，可以保證不會與其他屬性名產生衝突 123let a = 33let a2 = Symbol(33)console.log(a===a2) // false 簡略規則 在轉為 string 方面，將 Symbol 明確的強制轉型是允許的，但隱含的強制轉型是被禁止的，並且會丟出錯誤訊息 12345var s1 = Symbol(&apos;Hello World&apos;);console.log(String(s1)); // &quot;Symbol(Hello World)&quot;var s2 = Symbol(&apos; World Hello&apos;);console.log(s2 + &apos;&apos;); // TypeError: Cannot convert a Symbol value to a string 在轉為 number 方面，無論是明確或隱含都是禁止的，並且會丟出錯誤訊息 12345const n1 = Symbol(777);console.log(Number(s1)); // TypeError: Cannot convert a Symbol value to a numberconst n2 = Symbol(999);console.log(+n2); // TypeError: Cannot convert a Symbol value to a number 在轉為 boolean 方面，無論是明確或隱含都是可以的，並且結果都是 true 123456789101112131415const b1 = Symbol(true);const b2 = Symbol(false);Boolean(b1); // trueBoolean(b2); // trueconst b3 = Symbol(true);const b4 = Symbol(false);if (b3) &#123; console.log(&apos;b3 是真的&apos;); // b3 是真的&#125;if (b4) &#123; console.log(&apos;b4 是真的&apos;); // b4 是真的&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jimmywei01.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jimmywei01.github.io/tags/JavaScript/"}]},{"title":"JS 紀錄1 - 物件、變數、型別","slug":"JS-紀錄1-物件、變數、型別","date":"2019-05-27T05:57:39.000Z","updated":"2019-06-02T09:19:29.758Z","comments":true,"path":"2019/05/27/JS-紀錄1-物件、變數、型別/","link":"","permalink":"https://jimmywei01.github.io/2019/05/27/JS-紀錄1-物件、變數、型別/","excerpt":"JavaScript 基本觀念紀錄","text":"JavaScript 基本觀念紀錄 執行時期 - 在準備資料開發時期 - 開始實作 JavaScript 物件 可以指派給一個 變數 並會在執行時期擁有 型別 物件(Object) 這裡的物件代表存在於記憶體中的資料 僅存於執行時期 變數(Variable) 記憶體指標特性（可以指向任何資料) 只能在開發時期宣告 var , let , const 在執行時期只會用來儲存物件的記憶體位置 型別(Type) 僅存於執行時期，並用來標示物件的種類(類型) 不同型別之間可能會有不同的屬性與方法 12345678var a a = 1a = ‘a’a = ‘a’+ a // 1個變數 var a// 3個型別 undefind,number,string// 5個記憶體物件 JavaScript 都是物件 number string boolean null - (此變數可能曾經有值，可能沒有值) 現在沒有值 undefind - 此變數還沒有給值，所以不知道是什麼 symbol array object regexp 變數建立方式先建立物件 在建立型別，型別 用來標示物件的種類 1var a = “5” a = 變數 , 5 = 物件 , “” = (字串)型別 1a.name = “jimmy&quot; a = 變數物件 , name = 屬性 , jimmy = 物件 , “” = (字串)型別 屬性1a.name = &#123;&#125; 可以被刪除 內含記憶體指標特性（可以指向任何資料） 任何一個 JavaScript 只有屬性 變數(也可能是屬性)1let a = &#123;&#125; 絕對無法刪除（除非去 prototye 刪除父連結） 內含記憶體指標特性（可以指向任何資料） 沒有型別 在記憶體裡指向別人 var , let , const 進行宣告 宣告變數 var let const 作用域 Function scope Block scope Block scope 注意事項 盡量不用 var，會汙染 window(全域變數) 造成一堆變數在 window var 宣告過的變數，不能再使用 let 宣告一次 宣告一個唯讀的變數 (變數無法再指向其他物件) hosting undefined is not defined is not defined 作用域 var ( funcotion socpe ) 123456789function myFunction () &#123; var myVar = &quot; Nick &quot; ; if ( true ) &#123; var myVar = &quot; John &quot; ; console.log (myVar); // &quot;John&quot; &#125; console.log (myVar); // &quot;John&quot; &#125;console.log (myVar); // undefined, myVar在函數範圍外部無法被使用 let ( block scope ) 123456789function myFunction () &#123; let myVar = &quot; Nick &quot; ; if ( true ) &#123; let myVar = &quot; John &quot; ; console.log (myVar); // &quot;John&quot; &#125; console.log (myVar); // &quot;Nick&quot;&#125;console.log (myVar); // undefined, myVar在函數範圍外部無法被使用 注意事項 var 污染全域(window) 12345678910111213141516var a = 1window[‘a’] = 2delete window.a // false 是變數也是屬性console.log(a) // 2// var 宣告更改屬性值(index)var a = ‘well’ // ‘well&apos;a[0] // ‘w&apos;a[0] = ‘j’ // ‘j&apos;a[0] // ‘w’a // ‘well’delete a // falsewindow.a // ‘well’ 污染全域(window)window.a = &apos;jj&apos; // ‘jj’ window 可重新賦值a[0] // ‘j&apos;delete window.a // false 是變數也是屬性 let 不會污染全域(window) 12345678910111213141516var a = 1window[‘a’] = 2delete window.a // false 是變數也是屬性console.log(a) // 2// 改用 let 宣告不會污染全域(window)let a = ‘jimmy’ // ‘jimmy’a[0] // ‘j’a[0] = ‘m’ // ‘m’a[0] // ‘j&apos;a // ‘jimmy’delete a // falsewindow.a // undefined 不會污染全域(window)window.a= ‘mm’ // ‘mm’ window.a[0] // ‘m’delete window.a // false hosting 當 function 與變數/常數同名稱而提升時，function 的優先程度高於變數/常數 12345678a()function a()&#123; console.log(&apos;hello&apos;);&#125;// 優先 hostingfunction a()&#123; console.log(&apos;he’); // he&#125; var undefind 12console.log (myVar) // undefined var myVar = 2 let TDZ 程式碼中某個部份變數的參考動作還不能執行，這是因為該變數尚未被初始化 12console.log (myVar) // ReferenceError: myVar is not definedlet myVar = 2 ; const TDZ 12console.log (myVar) // ReferenceError: myVar is not definedconst myVar = 2 ; 變數指派差異 var 一般變數下 可以重新修改變數值 可以重新宣告變數 在 object 和 array 下 可以重新修改 object 和 array 的變數值 可以重新宣告 object 和 array 變數 12345678910111213141516171819202122var myVar = 2 ;myVar = 6console.log(myVar) // 6var myVar = 3console.log(myVar) // 3// arrayvar son = [&apos;John&apos;]son.push(&apos;jimmy’)console.log(son) // [&quot;john&quot;, &quot;jimmy”]son =‘marry&apos;console.log(son) // marry// objectlet q = &#123;r:0&#125;q.r = 3console.log(q) // 3let q = &#123;f:0&#125;console.log(q.f) // 0 let 一般變數下 可以重新修改變數值 不能重新宣告變數 在 object 和 array 下 可以重新修改 object 和 array 的變數值 不能重新宣告 object 和 array 變數 12345678910111213141516171819202122let myVar = 2 ;myVar = 6console.log(myVar) // 6let myVar = 3 ; console.log(myVar) // SyntaxError: Identifier &apos;myVar&apos; has already been declared// arraylet q = &#123;r:0&#125;q.r = 3console.log(q.r) // 3let q = &#123;f:0&#125; console.log(q.f) // SyntaxError: Identifier &apos;q&apos; has already been declared//objectlet person = [‘John’]person.push(‘Jimmy’)console.log(person) // [‘John’,’Jimmy’]let person = [‘Peater’] console.log(person) // SyntaxError: Identifier &apos;person&apos; has already been declared const 一般變數下 不能重新修改變數值 不能重新宣告變數 在 object 和 array 下 可以重新修改 object 和 array 的變數值 不能重新宣告 object 和 array 變數 12345678910111213141516171819202122const myVar = 2 ;myVar = 6 // SyntaxError: Identifier &apos;myVar&apos; has already been declaredconst myVar = 3 ; // SyntaxError: Identifier &apos;myVar&apos; has already been declared//arrayconst person = &#123; name : &apos; Nick &apos;&#125;;person.name = &apos; John &apos; console.log ( person.name ) // &quot;John&quot; person = &quot;Sandra”//跳出錯誤，因為重新指派時是不允許使用const宣告出來的變數的console.log(person) // TypeError: Assignment to constant variable//objectconst person = [];person.push ( &apos; John &apos; ); console.log (person[ 0 ]) // &quot;John&quot; person = [ &quot; Nick &quot; ] console.log(person) // TypeError: Assignment to constant variable 型別型別分類 原始型別(Primitive Type) - 不允許自由擴增屬性 但卻有屬性 &amp; 方法可以使用，因為有原始型別包裹物件 (primititve type wrapper type) ＆ 父元素的關係 1&apos;abc&apos;.charAt === String.prototype.charAt // true 運算元 型別 Number (數值) number String (字串) string Boolean (布林) boolean Null (空值) object Undefind (未定義) undefind Symbol (符號) function 物件型別(Object Type) - 可以自由擴增屬性 運算元 型別 Array (陣列) object Object (物件) object 型別判斷typeof null 是基本型別之一，得到 object，而非 null function 是物件的子型別，但 typeof function() {} 是得到 function ，而非 object NaN 表示是無效的數字，但依舊還是數字，因此結果就是 number，而非「不是數字」(not a number) NaN 與任何數字運算都會得到 NaN，並且 NaN 不大於、不小於也不等於任何數字，包含 NaN 它自己 12345678910typeof &apos;Hello World!&apos; // &apos;string&apos;typeof true // &apos;boolean&apos;typeof 1234567 // &apos;number&apos;typeof null // &apos;object&apos;typeof undefined // &apos;undefined&apos;typeof &#123; name: &apos;Jack&apos; &#125; // &apos;object&apos;typeof Symbol() // &apos;symbol&apos;typeof function() &#123;&#125; // &apos;function&apos;typeof [1, 2, 3] // &apos;object&apos;typeof NaN // &apos;number&apos; instanceof 檢查物件是否為指定的建構子所建立的實體 用來測試一個 object 在原型鏈中是否存在一個構造函數的 prototype 屬性 涉及的構造函數 基礎類型：string、number、boolean、undefined、null、symbol 複雜類型：array，object 其他類型：function、regExp、date 語法 [對象] instanceof [構造函數]， 回傳 boloon 值 注意左側必須是對象（object），如果不是，直接返回 false 12let obj = new Object()obj instanceof Object // true 基礎類型 檢測的一定要是對象（object） 12345678910111213141516171819// 第一個不是 object，是基本類型，返回 falselet num = 1num instanceof Number // false// 第二個是封裝成 object，所以 truenum = new Number(1)num instanceof Number // true// 檢測目標的 __proto__ 與構造函數的 prototype 相同即返回 true，這是不嚴謹的let num = 1num.__proto__ === Number.prototype // truenum instanceof Number // false// 一定要封裝成 objectnum = new Number(1)num.__proto__ === Number.prototype // truenum instanceof Number // truenum.__proto__ === (new Number(1)).__proto__ // true 複雜類型 直接生成構造函數，所以不會像基本類型一樣兩種情況 1234let arr = [ ]arr instanceof Array // truearr instanceof Object // trueArray.isArray(arr) // true 其他類型 除了 function，都一樣是 object 123456789// 這裡要注意，function A() &#123;&#125;相當於 let A; A = function()&#123;&#125;// a 是 new 出來的，所以是經過構造，因此已經是對象，不再是函數，所以 falsefunction A() &#123;&#125;let a = new A()a instanceof Function // falsea instanceof Object // trueA instanceof Function // trueA instanceof Object // true 型別參數傳遞 參數傳遞 Call by reference Call by value Object String Array Number Function Boolean RegExp Null Date Undefined Math Symbol Call by value 佔用不同記憶體位置 123456let age = 100;let age2 = age;console.log(age, age2); // 100,100age = 200;console.log(age, age2); // 200,100 Call by reference 使用相同記憶體位置 記憶體「路徑位置」會被複製 1234567891011121314let superTeam = [&apos;Otree&apos;, &apos;Penguin&apos;, &apos;Frog&apos;, &apos;Jim&apos;];let fakeTeam = superTeam;console.log(fakeTeam, superTeam)// 兩個變數值相同// [&apos;Otree&apos;, &apos;Penguin&apos;, &apos;Frog&apos;, &apos;Jim’];// [&apos;Otree&apos;, &apos;Penguin&apos;, &apos;Frog&apos;, &apos;Jim&apos;];fakeTeam[3] = &apos;Chris’;console.log( fakeTeam, superTeam);// 值也跟著變了// [&apos;Otree&apos;, &apos;Penguin&apos;, &apos;Frog&apos;, ‘Chris’];// [&apos;Otree&apos;, &apos;Penguin&apos;, &apos;Frog&apos;, ‘Chris&apos;]; Call by Sharing （共享參考） 變數值被呼叫時，會直接把該變數所在的記憶體位置做為參考，傳遞給呼叫它的對象 但當對象被賦予新值時，對象會被指定一個新的記憶體位置，值也跟著變了 12345678910111213let superTeam = [&apos;Otree&apos;, &apos;Penguin&apos;, &apos;Frog&apos;, &apos;Jim&apos;];let fakeTeam = superTeam;console.log(fakeTeam, superTeam)// 兩個變數值相同// [&apos;Otree&apos;, &apos;Penguin&apos;, &apos;Frog&apos;, &apos;Jim’];// [&apos;Otree&apos;, &apos;Penguin&apos;, &apos;Frog&apos;, &apos;Jim&apos;];fakeTeam = [&apos;Otree&apos;, &apos;Penguin&apos;, &apos;Frog&apos;, &apos;Chris’];console.log( fakeTeam, superTeam);// 值也跟著變了// [&apos;Otree&apos;, &apos;Penguin&apos;, &apos;Frog&apos;, ‘Chris’];// [&apos;Otree&apos;, &apos;Penguin&apos;, &apos;Frog&apos;, &apos;Jim&apos;]; 為何會產生不同傳遞方式的錯覺？ 在 JavaScript 中所有的 Call by value 型別皆為不可變動的(Immutable) 永遠只能藉由賦予新值的方式將值傳遞給新的變數 物件物件取屬性值 “ . “ […] 可取出 number 屬性的屬性值 12345678910111213141516// 建立物件var car = &#123;// 擴增屬性 name:&apos;Tesla&apos;, star:function()&#123; return &apos;ok&apos; &#125;, &apos;001&apos;:&apos;log&apos;&#125;car.name // “Tesla&quot;car[&apos;name’] // “Tesla&quot;car.star // f()&#123;return ok&#125;car[&apos;star’] // f()&#123;return ok&#125;car.001 // Uncaught SyntaxError: Unexpected numbercar[&apos;001’] // &quot;log&quot; 物件複製 物件複製的內容，儲存在不同的記憶區塊，讓彼此不會影響 ? Object.assign(target, …sources) Shallow Copy 只能處理深度只有一層的物件，沒辦法做到真正的 Deep Copy target - 目標物件 sources - 來源目標 123456789101112131415161718192021222324252627const person = &#123; name:&#123; firstname:&apos;wei&apos;, lastname:&apos;ck&apos; &#125;, age:80&#125;// 物件裡面還有一個子物件的話,這個子物件是無法被複製const person2 = Object.assign(&#123;&#125;,person)person2.name.firstname=&apos;chi&apos;console.log(person,person2)// [object Object] &#123; age: 80, name: [object Object] &#123; firstname: “chi&quot;, lastname: &quot;ck&quot; &#125;&#125;// [object Object] &#123; age: 80, name: [object Object] &#123; firstname: &quot;chi&quot;, lastname: &quot;ck&quot; &#125;&#125; JSON.parse(JSON.stringify(obj)) Deep Copy JSON.stringify 序列化(轉成字串) JSON.parse 物件化(轉成物件) function、regExp、undefind 過不去 123456789101112131415161718192021222324252627const person = &#123; name:&#123; firstname:&apos;wei&apos;, lastname:&apos;ck&apos; &#125;, age:80&#125;// 透過 JSON 將物件序列化(轉成字串)、再物件化(轉成物件)const person3 = JSON.parse(JSON.stringify(person))person3.name.firstname = &apos;chi&apos;console.log(person,person3)// [object Object] &#123; age: 80, name: [object Object] &#123; firstname: &quot;wei&quot;, lastname: &quot;ck&quot; &#125;&#125;// [object Object] &#123; age: 80, name: [object Object] &#123; firstname: &quot;chi&quot;, lastname: &quot;ck&quot; &#125;&#125; jQuery - Deep Copy &amp; Shallow Copy extend 可以複製物件，可以將加入參數使用深度複製 (deep copy) merge object 順序會影響到結果 shallow copy jQuery.extend( target [, object1 ] [, objectN ] ) deep copy jQuery.extend( [(deep)true or false], target, object1 [, objectN ] ) 123456789101112131415161718192021222324252627282930313233var object1 = &#123; apple: 0, banana: &#123; weight: 52, price: 100 &#125;, cherry: 97&#125;;var object2 = &#123;&#125;jQuery.extend(object2, object1);console.log(object2)//[object Object] &#123; apple: 0, banana: [object Object] &#123; price: 100, weight: 52 &#125;, cherry: 97&#125;console.log(object2.banana === object1.banana) // truevar object3 = &#123;&#125;jQuery.extend(true,object3, object1);console.log(object3)// [object Object] &#123; apple: 0, banana: [object Object] &#123; price: 100, weight: 52 &#125;, cherry: 97&#125;console.log(object3.banana === object1.banana) // false 函式庫 lodash - Deep Copy &amp; Shallow Copy shallow copy _.clone() deep copy _.cloneDeep() 1234567var objects = [&#123; &apos;a&apos;: 1 &#125;, &#123; &apos;b&apos;: 2 &#125;]; var shallow = _.clone(objects);console.log(shallow[0] === objects[0]); // truevar deep = _.cloneDeep(objects);console.log(deep[0] === objects[0]); // false","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jimmywei01.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jimmywei01.github.io/tags/JavaScript/"}]},{"title":"瀏覽器兼容性紀錄 (單位、font、CSS 設定、RWD media)","slug":"瀏覽器兼容性紀錄-單位、font、CSS-設定、RWD-media","date":"2019-05-23T15:10:48.000Z","updated":"2019-05-27T05:50:35.475Z","comments":true,"path":"2019/05/23/瀏覽器兼容性紀錄-單位、font、CSS-設定、RWD-media/","link":"","permalink":"https://jimmywei01.github.io/2019/05/23/瀏覽器兼容性紀錄-單位、font、CSS-設定、RWD-media/","excerpt":"紀錄一些不同瀏覽器的做法","text":"紀錄一些不同瀏覽器的做法 目的：解決不同瀏覽器的樣式衝突 CSS Hack 就是指利用不同瀏覽器的一些特殊屬性(非W3C標準)，來對不同瀏覽器進行設定，以達到前台視覺上統一的一種小技巧 無法通過 W3C驗證， 若要使用 CSS Hack 來統一各瀏覽器之間的差異，把他當成是網頁設計時最後的手段 主要分成兩種類型 樣式屬性的密技 ( Attribute Hacks ) 選取器的密技 ( Selector Hacks ) 樣式屬性的密技 ( Attribute Hacks ) 順序性非常重要，比較晚定義的樣式會取代較早定義的樣式，必須把最多瀏覽器版本看的懂的樣式寫在比較上面，這樣才能達到 CSS Hack 的效果 123456.page &#123; color: black; /* 所有瀏覽器 */ color /**/: yellow; /* IE7, IE8, IE9 */ *color: blue; /* IE6, IE7 */ _color: red; /* IE6 */ &#125; 樣式屬性的密技 符號 example IE6 底線 ( _ ) #style { _color: red } IE6, IE7 星號 ( * ) ｜井號 ( # ) #style { *color: red } ｜#style { #color: red } IE7, IE8, IE9 空白與一個註解 ( /**/ ) #style { color /**/: red } IE6, IE7, IE8, IE9 \\9 字串 #style { color: red\\9 } IE8, IE9 \\0/ 字串 #style {color: red\\0/} 選取器的密技 ( Selector Hacks ) autoprefixer - 加入各家瀏覽器的前綴詞（prefix） -webkit- Chrome 與 Safari 正是用核心 -moz- 則是 Mozilla 公司的縮寫(Gecko核心)，代表瀏覽器為Firefox -o- 是 Opera 瀏覽器的縮寫(Presto核心) -ms- 微軟的縮寫代表瀏覽器是 IE 1234567.class&#123; -webkit-border-radius: 5px; -moz-border-radius: 5px; -ms-border-radius: 5px; -o-border-radius: 5px; border-radius: 5px;&#125; IE 條件式註解 該功能只能用於 IE9 以下的瀏覽器裡 讓 IE 根據判斷的語法，來決定要不要執行註解中的內容，而其他的瀏覽器例如(Firefox,Google Chome,Safari…)都還是一樣視為註解，來達到區分 IE 瀏覽器版本及不同瀏覽器的效果 利用 html 的註解形式，在註解中加入一些判斷的語法 1234567&lt;!doctype html&gt;&lt;!--[if lt IE 7 ]&gt; &lt;html lang=&quot;en&quot; class=“no ie6&quot;&gt; &lt;![endif]--&gt;&lt;!--[if IE 7 ]&gt; &lt;html lang=&quot;en&quot; class=&quot;no ie7&quot;&gt; &lt;![endif]--&gt;&lt;!--[if IE 8 ]&gt; &lt;html lang=&quot;en&quot; class=&quot;no ie8&quot;&gt; &lt;![endif]--&gt;&lt;!--[if IE 9 ]&gt; &lt;html lang=&quot;en&quot; class=&quot;no ie9&quot;&gt; &lt;![endif]--&gt;&lt;!--[if (gt IE 9)|!(IE)]&gt;&lt;!--&gt; &lt;html lang=&quot;en&quot; class=&quot;no&quot;&gt; &lt;!--&lt;![endif]--&gt;&lt;head&gt; 可以用來載入不同的 CSS 檔 1234&lt;!--[if lte IE 9]&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;lte-ie-9.css&quot;&gt;&lt;![endif]--&gt;&lt;!--[if lte IE 8]&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;lte-ie-8.css&quot;&gt;&lt;![endif]--&gt;&lt;!--[if lte IE 7]&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;lte-ie-7.css&quot;&gt;&lt;![endif]--&gt;&lt;!--[if lte IE 6]&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;lte-ie-6.css&quot;&gt;&lt;![endif]—&gt; 透過條件式類別名稱的技巧，CSS 內容可以寫成這樣，也可以有效避免使用 CSS Hacks 1234.style &#123; color: black; &#125; /* 所有瀏覽器 */.ie8 .style &#123; color: yellow; &#125; /* IE8 */.ie7 .style &#123; color: blue; &#125; /* IE7 */.ie6 .style &#123; color: red; &#125; /* IE6 */ 參數 說明 if 是或不是 lt less-than，版本小於，例如 [if lt IE 7] 表示版本小於 IE7，不包含 IE7 lte than or equal，版本小於或等於，例如 [if lte IE 7] 表示版本小於IE7，包含 IE7 gt greater-than，版本大於，例如 [if gt IE 7] 表示版本大於 IE7，不包含 IE7 gte greater-than or equal，版本大於或等於，例如 [if gte IE 7] 表示版本大於 IE7，包含 IE7 ! NOT，否定的意思，例如 [if !IE7] 表示不是 IE7 &amp; AND，且的意思，例如 [if (gt IE 7)&amp;(lt IE 9)]，表示要大於 IE7 且小於 IE9 ｜ OR，或的意思，例如 [if (IE 6)｜(IE 7)]，表示 IE6 或 IE7 都會符合條件 不同單位可參考 -&gt; https://codepen.io/Jimmywei01/pen/wbpeqd?editors=1100 px：絕對單位，代表螢幕中每個「點」( pixel ) 縮放螢幕的時候，不會隨著變動 多大 px 字體就會多大 123456789&lt;div class=&quot;a&quot; style=&quot;font-size:16px;&quot;&gt;16px &lt;div style=&quot;font-size:20px;&quot;&gt;20px &lt;div style=&quot;font-size:24px;&quot;&gt;24px &lt;div style=&quot;font-size:16px;&quot;&gt;16px &lt;div style=&quot;font-size:32px;&quot;&gt;32px&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; em：相對單位，每個子元素透過「倍數」乘以父元素的 px 值 每一個 div 都從它上一級父元素繼承了字體大小，並且逐漸增加 最內層是 16px x 1.2 x 1.2 x 1.2 x 1.2 x 1.2 = 39.8px 123456789&lt;div style=&quot;font-size:1.2em;&quot;&gt;1.2em &lt;div style=&quot;font-size:1.2em;&quot;&gt;1.2em &lt;div style=&quot;font-size:1.2em;&quot;&gt;1.2em &lt;div style=&quot;font-size:1.2em;&quot;&gt;1.2em &lt;div style=&quot;font-size:1.2em;&quot;&gt;1.2em&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; rem：相對單位，每個元素透過「倍數」乘以根元素的 px 值 1rem 等於根元素的字體大小 最內層是 16px x 1.2 = 19.2px rem 單位在不同螢幕比例都適用 設定在 html 元素下 font-size 的根元素 px 值當預設值 如何確認 1rem 等於多少 px？ 因為 css 是不會幫忙計算 1rem 是多少 px 的，只能通過自己來計算 計算方式： 假設情境 有一個設計稿 A（ 640*1136 px )，預設的 rem 和 px 的比例 B（ font-size 為10px 即 1rem=10px )，假設切 480px 的圖要放入 320px 總共需要多少 rem ？ 公式 clientWidth 1rem = 預設 font-size * (clientWidth / 設計稿 width) + ‘px’; clientWidth 內設計圖要切的內容尺寸 rem = 設計圖要切的內容尺寸 px / clientWidth 1rem 解 320px 1rem = 10 * ( 320 / 640 ) +’px’ = 5px 320px 內 480px 圖要切的內容尺寸 rem = 480 / 5 = 96 rem 123456789&lt;div style=&quot;font-size:1.2rem;&quot;&gt;1.2rem &lt;div style=&quot;font-size:1.2rem;&quot;&gt;1.2rem &lt;div style=&quot;font-size:1.2rem;&quot;&gt;1.2rem &lt;div style=&quot;font-size:1.2rem;&quot;&gt;1.2rem &lt;div style=&quot;font-size:1.2rem;&quot;&gt;1.2rem&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; %：相對單位，每個子元素透過「百分比」乘以父元素的 px 值 和 em 大同小異 最內層是 16px x 1.2 x 1.2 x 1.2 x 1.2 x 1.2 = 39.8px 123456789&lt;div style=&quot;font-size:120%;&quot;&gt;120% &lt;div style=&quot;font-size:120%;&quot;&gt;120% &lt;div style=&quot;font-size:120%;&quot;&gt;120% &lt;div style=&quot;font-size:120%;&quot;&gt;120% &lt;div style=&quot;font-size:120%;&quot;&gt;120%&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; vh/vm 設計自適應性網頁（RWD）時會希望圖片隨著螢幕的大小而改變，這時候我們就可以利用到這兩個新的單位 vh 代表的是 view height，也就是螢幕可視範圍高度的百分比，1vw = 視窗寬度的 1% vw 表示的是 view width，也就是螢幕可是範圍寬度的百分比，1vh = 視窗高度的 1% 1vw ＝ 1/100th viewport width 如果填的是 30vh 和 30vw，表示這個 div 要占我的可視範圍 30%，因為它會隨著網頁縮放而改變 這個方形的長度會隨著你的視窗而改變，是因為輸入的是 30% vmin | vmax vmin 意思是抓取「長或寬較小的那個的百分比」 vmax 意思是抓取「長或寬較大的那個的百分比」 font-family 先找第一種字體，若不支援或沒有該字體，則採用第二種字體，依此類推，最後使用通用字 1body&#123; font-family:第一種字體, 第二種字體, &quot;第三種字體&quot;, &quot;通用字&quot;; &#125; 引用外部字體方式 CSS link 1&lt;link href=&quot;外部字體超連結&quot; rel=&quot;stylesheet&quot;&gt; @import 1&lt;style&gt; @import url(&apos;外部字體超連結&apos;); &lt;/style&gt; @font-face 1&lt;style&gt; @font-face &#123; font-family: 自定義名稱; src: url(字體檔超連結); &#125; &lt;/style&gt; @font-face 使用方式 local 代表直接抓取使用者電腦中的字型檔 format 標記 同一種字體但分為四種不同格式，format 標記用意在輔助瀏覽器識別，如果瀏覽器不支援該格式，將會直接跳過這個字體，省去下載字體檔案的時間 SVG 的字體，如果有標記 id 在其中，可在字體名稱後方加上 # 來指定特定 id 字體 可以使用 font-weight、font-style 定義字體特性，讓瀏覽器在解析字體時，只下載有在網頁上被使用的字體檔 12345678910111213@font-face &#123; font-family: ’自定義名稱&apos;; src: local(“Helvetica&quot;) ， url(&apos;../fonts/xxx.woff&apos;) format(&quot;woff&quot;), url(&apos;../fonts/xxx.otf&apos;) format(&quot;opentype&quot;), url(&apos;../fonts/xxx.eot&apos;) format(&quot;embedded-opentype”), url(&apos;../fonts/xxx.ttf&apos;) format(&apos;truetype&apos;), url(&apos;../fonts/xxx.svg#hi&apos;) format(&apos;svg’); font-weight: normal; font-style: normal;&#125;h1&#123; font-family:自定義名稱, serif; &#125; 字型格式 副檔名 format( ) 瀏覽器支援 TrueType .ttf “truetype” 舊版 Android (4.4 版以下) 瀏覽器 WOFF .woff “woff” 大多數瀏覽器(包含chrome)在許多較舊的瀏覽器中無法使用 Embed OpenType .eot “embedded-opentype” 舊版 IE (IE9 之下) 瀏覽器 @font-face - unicode-range 讓某些文字顯示不同字體 unicode-range 說明 U+316 單一字元 U+316-3FF 某個字元區間 U+3?? 某個 U+3 開頭的字元 ( U+300~3FF ) U+216-266, U+3?? 用逗號聯集不同區間 1234567891011121314151617@font-face &#123; font-family: font1; src: url(KouzanBrushFont.ttf); unicode-range: U+611B; &#125; @font-face &#123; font-family: font2; src: url(&quot;setofont.ttf&quot;); unicode-range: U+0057,U+0077; &#125; h1 &#123; font-family: font1, font2, sans-serif; font-size: 50px; font-weight: normal;&#125; RWD 使用者體驗 響應式無法讓所有螢幕解析度都最佳化 遵循 80/20 法則，先兼容熱門瀏覽器 動線設計：並非所有內容都要全部塞到網頁內容 斷點時機：設計多欄式佈局的必要觀念 點擊範圍：設計讓人好點選的元素 少即是多：避免資訊量爆炸( 非全部塞滿 ) 載具特性：使用者行為 touch( 手機 click )、hover(手機體驗不好) 不要習慣寫死高度 mobile first 與 desktop first 優先 mobile 寫法 @media (min-width: 768px) desktop 寫法 @media (max-width: 768px) 先做哪個版本，該版本就比較靈活，而被覆蓋後才產生出來的樣式就會因此而受限 mobil first 要建構良好的行動裝置操作體驗，有以下幾點要注意 : 設計網站的時候要考量行動裝置但不是要從手機網站開始設計起，而是過程中要以手機為主要考量 要符合使用者使用行動裝置的方式與動機 (行動中手機查資料、躺在床上滑平板) 明確的內容比設計齊全的導覽功能更重要 (因為行動版的簡化導致更重要內容被刪除) 提供設計良好的導覽選單，方便使用者閒逛或深入閱讀內容 (不要進網站找不到) RWD 圖片設計 不使用 width 圖片堅持呈現原本寬度 ( 所以超出瀏覽器會出現 x 軸 ) 使用 max-width: 100% 圖片保有自己的最大寬度，並自適應父容器 width 縮小 圖片 size 規劃，刻意設計較大張一點的技巧 banner 設計 - 縮放圖片原理 使用兩張圖 mobile 小張 desktop 大張 banner 或網頁中的圖片，呈現方式 : 將圖片在 css 中用背景圖片的方式來呈現 將圖片在 html 中用 img 放入圖片 這兩種方法有什麼不同的適用時機或使用考量？ banner 如果裡面又有放字的話，要考量在手機上會不會過小，是否要把文字拆出來放，那這樣圖片用背景就比較適合，當然純 img 也可以，那就是用絕對定位來設計 如果電子商務上面的產品列表，通常都是直接插入 img，畢竟你不可能在 css 放各種產品背景圖案，但也是有跟後端配合時 在 HTML 標籤上寫 style background ，最後在圖片上面插入文字 怎麼做會比較適合，會依照 文字是否要放在圖內 大小是否要改變 圖片有無要設計兩種 size 以上(PC、Mobile) 思考要怎麼跟後端配合，他要依照什麼規則在後台上圖，前台也會跟著正常 最後再依照設計師提供給的設計稿來決定要怎麼開發 web layout RWD 開發介紹HTML - viewport CSS 還是 CSS framework 開發，都要先加這一行 加這一行的目的是要強迫網頁的內容，以裝置目前的寬度來做呈現，並禁止縮放( 手機與平板的解析度 不會等於載具寬度 ) 1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width; initial-scale=1.0; maximum-scale=1.0; user-scalable=no;&quot;&gt; viewport - 用戶網頁的顯示區域 content - 操作 viewport 123456789&lt;meta name=&quot;viewport&quot;content=&quot;height = [pixel_value | device-height] ,width = [pixel_value | device-width ] ,initial-scale = float_value ,minimum-scale = float_value ,maximum-scale = float_value ,user-scalable = [yes | no] ,target-densitydpi = [dpi_value | device-dpi | high-dpi | medium-dpi | low-dpi]&quot;/&gt; viewport 的參數: width：控制 viewport 的大小，可以指定的一個值或者特殊的值，如 device-width 為設備的寬度（單位為縮放為100% 時的 CSS 的像素） height：和 width 相對應，指定高度 initial-scale：初始縮放 一個浮點值，是頁面大小的一個乘數 例如，如果設置初始縮放為 “1.0”，那麼，web 頁面在展現的時候就會以 target density 分辨率的 1:1 來展現 如果設置為 “2.0”，那麼這個頁面就會放大為 2 倍。 (最小0.25，最大5) minimum-scale：最小縮放 (最小0.25，最大5) maximum-scale：最大縮放 一個浮點值，用指出頁面大小與屏幕大小相比的最大乘數 例如，如果將這個值設置為“2.0”，那麼這個頁面與 target size 相比，最多能放大2倍 (最小0.25，最大5) user-scalable：用戶是否能改變頁面縮放程度 如果設置為 yes 則是允許用戶對其進行改變，反之為 no, 默認值是 yes 如果設置為no，那麼 minimum-scale 和 maximum-scale 都將被忽略，因為根本不可能縮放( 1 或 0 (yes 或 no) ) target-densitydpi：一個屏幕像素密度是由屏幕分辨率決定的，通常定義為每英寸點的數量（dpi） Android 支持三種屏幕像素密度：低像素密度，中像素密度，高像素密度 一個低像素密度的屏幕每英寸上的像素點更少，而一個高像素密度的屏幕每英寸上的像素點更多 Android Browser 和 WebView 默認屏幕為中像素密度(160dpi) target-densitydpi 的取值範圍: device-dpi：使用設備原本的 dpi 作為目標 dpi，不會發生默認縮放 high-dpi：使用 hdpi 作為目標 dpi，中等像素密度和低像素密度設備相應縮小 medium-dpi：使用 mdpi 作為目標 dpi，高像素密度設備相應放大，像素密度設備相應縮小。這是默認的 target density low-dpi：使用 mdp i作為目標 dpi，中等像素密度和高像素密度設備相應放大 value：指定一個具體的 dpi 值作為 target dpi，這個值的範圍必須在 70–400 之間 設置螢幕密度為高頻，中頻，低頻自動縮放，禁止用戶手動調整縮放：123456&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, target-densitydpi=high-dpi, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no&quot;/&gt; CSS - Media Queries123456789@media and|or|not|only and (media feature) &#123; CSS Code;&#125;@media 媒體類型 and (條件) &#123;.css &#123; CSS Code; &#125;&#125; Media Types可參考 W3C -&gt; http://www.w3.org/TR/CSS21/media.html#media-types Value Description all 全部 print 印表機 braille 點字機 screen 視窗螢幕大小 speech 語音合成器 Media Features Value Description width 視窗寬度 height 視窗高度 max-device-height 最大裝置高度 max-device-width 最大裝置寬度 max-height 最大高度 max-width 最大寬度 min-device-width 最小裝置寬度 min-device-height 最小裝置高度 min-height 最小高度 min-width 最小寬度 and 使用者視窗寬度 &lt;= 768px，將字體大小變為 20px 使用者視窗寬度介於 768px ~ 992px，將字體大小變為 30px 使用者視窗寬度 &gt;= 1200px，將字體大小變為 40px 1234567891011121314151617@media screen and (max-width: 768px) &#123;.div1 &#123; font-size: 20px; &#125;&#125;@media screen and (min-width: 768px) and (max-width: 992px) &#123;.div1 &#123; font-size: 30px; &#125; &#125;@media screen and (min-width: 1200px) &#123;.div1 &#123; font-size: 40px; &#125;&#125; or 如果使用者視窗寬度在 XXXpx(含)以下，或 XXXpx(含)以上 將背景變為紅色 123@media screen and (max-width: 600px), screen and (min-width: 800px) &#123; div &#123; background: red; &#125;&#125; not 用來排除符合表達式的設備尺寸 123@media not screen and (max-width: 600px) &#123; div &#123; background: red; &#125;&#125; only 用來針對那些不支援 media queries 卻需要讀取 media type 的設備隱藏樣式用 123456@media only screen and (min-width:480px) &#123; div &#123; background: red; &#125;&#125;media queries 是 CSS3 對於 media type 的一個擴展所以不支援 media queries 的瀏覽器還是要能識別 media type 推薦撰寫方式 使用 CSS media type 區分不同解析度，分別讀入不同 CSS 語法 123&lt;link href=&quot;/css/phone.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;/&gt;&lt;link href=&quot;/css/tablet.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt;&lt;link href=&quot;/css/desktop.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;/&gt; CSS - Fluid Grids 網頁元素以方格式設計 (Grid Design) + 依照視窗大小縮放的流動佈局 (Liquid Layout) Grid Design - 一般網頁 div 排版超過容器最大寬度, div 自動擠到下一行 float (clearfix 來消除 float 的效果) inline-block flex Liquid Layout 把原本用 px 單位製作的版面改成用 %, em, rem PT CSS pt 不等於 iOS pt ，其運作方式也不相同，所以不要放在一起 pt 這個單位詞，其實最早源自於傳統的鉛字印刷，是用來表示鉛字塊的尺寸 1 pt = 1/72 英吋 而 CSS 之所以有 pt 這個單位，其實是要把網頁印刷/列印出來的時候用到的 Retina 螢幕的 iOS 單位 - pt (ppi) 效果：設計稿尺寸 / 2，元素寬度使用百分比實現 ( 比如設計稿上的高度是 200px，則 CSS 中就是 height:100px) 設計稿圖要兩倍大做使用 PPI = Pixels Per Inch 紅點為了維持一樣的大小，他的長/寬就會各涵蓋到 2px，所以原本銀色機上 1pt 等於 1px ，但到了螢幕密度兩倍的地方， 1pt 的大小就會代表 2px CSS - Fluid Image 把原本的 px 單位換成 % ，然後達到依畫面尺寸縮放的功能 要考慮圖片放大後失真 or 可能會有想要針對螢幕大小指定合適圖片的需求 (在設計圖片時把圖解析度設高) RWD 顯示圖片的方式有兩種，一種是傳統 img 標籤，另一種是 CSS 的背景圖 一般圖片 img 標籤，將 width 或 height 設 % 就可以了，另一個設為 auto max-width : 100% 方式防止圖片大到糊掉 1234#banner &#123; width: 100%; | max-width : 100%; height: auto;&#125; 第二種是針對容器(如 div)使用背景圖片 背景圖的方式可彌補 img 但無法針對螢幕大小指定合適圖片 1234567#banner &#123; width: 100%; height: 100px; background-repeat: no-repeat; background-size: 100% auto; background-image: url(&apos;banner.jpg&apos;);&#125; Bootstrap - Fluid Grids 12 欄 Grid System ，以 960px 為基準，因為早期電腦螢幕通常為 1024px，960px 的設計是最為剛好 使用一組 .col-md- *網格類，可以創建一個基本的網格系統，將網格列放置在 .row 中 123456789101112131415161718// 通過製作一個全寬和另一個半寬&lt;div class=&quot;row&quot;&gt;&lt;div class=&quot;col-xs-12 col-md-8&quot;&gt;.col-xs-12 .col-md-8&lt;/div&gt;&lt;div class=&quot;col-xs-6 col-md-4&quot;&gt;.col-xs-6 .col-md-4&lt;/div&gt;&lt;/div&gt;// 移動設備上的列開始為50％，桌面上的列開始為33.3％&lt;div class=&quot;row&quot;&gt;&lt;div class=&quot;col-xs-6 col-md-4&quot;&gt;.col-xs-6 .col-md-4&lt;/div&gt;&lt;div class=&quot;col-xs-6 col-md-4&quot;&gt;.col-xs-6 .col-md-4&lt;/div&gt;&lt;div class=&quot;col-xs-6 col-md-4&quot;&gt;.col-xs-6 .col-md-4&lt;/div&gt;&lt;/div&gt;// 移動和桌面上的列寬50％&lt;div class=&quot;row&quot;&gt;&lt;div class=&quot;col-xs-6&quot;&gt;.col-xs-6&lt;/div&gt;&lt;div class=&quot;col-xs-6&quot;&gt;.col-xs-6&lt;/div&gt;&lt;/div&gt; Bootstrap - Media Queries 當寬度超過該數值以上時會套⽤樣式 1234567891011// Small devices (landscape phones, 576px and up)@media (min-width: 576px) &#123; ... &#125;// Medium devices (tablets, 768px and up)@media (min-width: 768px) &#123; ... &#125;// Large devices (desktops, 992px and up)@media (min-width: 992px) &#123; ... &#125;// Extra large devices (large desktops, 1200px and up)@media (min-width: 1200px) &#123; ... &#125; Bootstrap - Fluid Image bootstrap 要做到 fluid images 只要加上 class=”img-responsive” img-responsive 這個 class 就是下面這幾個 CSS 組成 max-width: 100%; height: auto; display: block; 如果要讓 class=”img-responsive” 的圖片置中可以使用 .center-block","categories":[{"name":"CSS","slug":"CSS","permalink":"https://jimmywei01.github.io/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://jimmywei01.github.io/tags/CSS/"},{"name":"RWD","slug":"RWD","permalink":"https://jimmywei01.github.io/tags/RWD/"},{"name":"瀏覽器","slug":"瀏覽器","permalink":"https://jimmywei01.github.io/tags/瀏覽器/"}]},{"title":"CSS-grid","slug":"CSS-grid","date":"2019-05-21T08:59:10.000Z","updated":"2019-05-27T05:50:35.473Z","comments":true,"path":"2019/05/21/CSS-grid/","link":"","permalink":"https://jimmywei01.github.io/2019/05/21/CSS-grid/","excerpt":"CSS grid 排版透過 grid template 來定義版型的結構，分別由 column 及 row 定義出直排與橫列的格線，內容再依隔線作安排可跨行跨列排版","text":"CSS grid 排版透過 grid template 來定義版型的結構，分別由 column 及 row 定義出直排與橫列的格線，內容再依隔線作安排可跨行跨列排版 可參考 https://css-tricks.com/snippets/css/complete-guide-grid/ https://codepen.io/Jimmywei01/pen/yWodJZ?editors=1100 CSS Grid Terminology grid Line : 分隔元素的線，可以是垂直與水平，如下圖的紅色線 grid Track : 兩條分隔線中間的區域，簡單想就是 Grid 中的 Columns 或 Rows，如下圖的綠色區塊 grid Cell : Grid 中的基本單位，四條線組成的區域，如下圖的藍色區塊。 grid Area : 由數個 Cell 組成的區域，如下圖的紅色區塊。 track-size : fr 單位，通常用於分配 row 或 column 的非彈性尺寸設定完後之剩餘空間。以下圖的 column為例，意思即：將去掉 100px 與 10px 後的剩餘空間，分配為 30% 與 70% line-name: 可自行命名的名稱 grid 外容器屬性 display 網格行列設定 grid-auto-flow : row | column | row dense | column dense grid-template-areas : grid-template-columns | grid-template-rows grid-template : none | subgrid | grid-template-rows / grid-template-columns grid-gap = grid-column-gap + grid-row-gap 網格對齊位址 justify-items align-items justify-content align-content grid 內容器屬性 grid-column-start grid-column-end grid-row-start grid-row-end grid-column grid-row grid-area justify-self align-self 外容器display grid inline-grid 網格行列設定 grid-auto-flow 設定 格線 的長寬度 沒有明確放置在網格上的網格項（grid items），自動放置算法會自動放置這些網格項 row：自動佈局 每行 column：自動佈局 每列 row dense | column dense：自動佈局算法在稍後出現較小的網格項時，嘗試填充網格中較早的空缺，可能導致網格項出現亂序 12345678910111213141516.flow, .flow2&#123; display: grid; grid-template-columns: 60px 60px 60px 60px ; grid-template-rows: 30px 30px; grid-auto-flow: row; height: 100px; width: 450px; margin: 0 10px; border: 2px solid #f76707;&#125;.flow2&#123; grid-auto-flow: column;&#125; grid-template-areas 透過 area 定義區塊在 template 上的位置，概念就是在畫面上登記屬於該元素的空間，此部分要內外元素一起看 外元素 grid-template-areas：定義空間的位置，是透過幾組字串的組合 (名稱會通過區域在排列位置） 內元素 grid-area：定義空間的名稱 .（點號）：代表一個空的網格單元 none：不定義網格區域 1234567891011121314.warp4&#123; display:grid; grid-template-columns: 100px 50px auto 50px 100px; grid-template-rows: 25% auto 100px; grid-template-areas: &quot;head head head head head&quot; &quot;side main main main main&quot; &quot;side foot foot foot foot&quot;; height: 250px; width: 400px; margin: 10px;&#125; grid-template none：將所有三個屬性設置為其初始值 subgrid：將 grid-template-rows，grid-template-columns 的值設為 subgrid，grid-template-areas 設為初始值 grid-template-rows / grid-template-columns： 將 grid-template-columns 和 grid-template-rows 設置為相應地特定的值，並且設置 grid-template-areas 為 none 1234567891011121314.warp5&#123; display:grid; grid-template: 1fr 50px 2fr / 20% 50px 1fr; height: 250px; width: 400px; margin: 10px; border: 2px solid #f76707; grid-template-areas: &quot;header header header&quot; &quot;main main main&quot; &quot;footer footer footer&quot;;&#125; grid-template-columns | grid-template-rows 定義的行列所組成 &lt;line-name&gt; 指定網格線(Grid Line)名稱 123456789101112// &lt;line-name&gt; -&gt; [first],[line2],[line3],[col4-start],[five],[end].warp&#123; display: grid; grid-template-columns: [first] 100px [line2] 50px [line3] auto [col4-start] 50px [five] 100px [end]; grid-template-rows: 25% auto 100px; height: 250px; width: 400px; margin: 10px; border: 2px solid #f76707;&#125; grid-gap = grid-column-gap + grid-row-gap 定義行與列間距 grid-column-gap 左右間距 grid-row-gap 上下間距 1234567891011121314.warp2&#123; display: grid; grid-template-columns: 100px 50px auto 50px 100px; grid-template-rows: 25% auto 100px; grid-column-gap: 10px; grid-row-gap: 20px; grid-gap: 10px 20px; height: 250px; width: 400px; margin: 10px; border: 2px solid #f76707;&#125; fr 是因應 CSS grid 而產生的新單位，全名是 fraction (分數)，是數學分子 + 分母的那個分數 在剩餘空間中所占的比例 可以用 fr 去設定 CSS grid 的相對寬度，以達到 RWD 的縮放效果 如果是跟前面範例一樣使用 px，縮放的時候是不會有 RWD 的 可以混搭單位 repeat(重覆幾次, 重覆的寬度) 重複 grid 的設定 最左邊跟最右邊的 grid 如果不會重覆，可以接在 repeat 的前後 12345678910.warp3&#123; display:grid; grid-template-columns: repeat(2,1fr 2fr 1fr) 50px; height: 250px; width: 400px; margin: 10px; border: 2px solid #f76707;&#125; 網格對齊位址 justify-items - 主軸 「水平對齊」每個網格區域的位置 網格對齊位置 沿著內聯（行）軸對齊網格項（與沿著塊（列）軸對齊的項對齊） start：將內容對齊到網格區域（grid area）的左側 end：將內容對齊到網格區域的右側 center：將內容對齊到網格區域的中間（水平居中） stretch：填滿網格區域寬度（默認值） 1234567891011121314151617.warp6, .warp7, .warp8, .warp9 &#123; display:grid; grid-template-columns: auto 50px auto; grid-template-areas: &quot;head head head&quot; &quot;foot &quot;; justify-items: start; justify-items: end; justify-items: center; justify-items: stretch; height: 50px; width: 200px; margin: 0 5px; border: 2px solid #f76707;&#125; align-items - 主軸 「垂直對齊」每個網格區域的位置 沿著列軸線（列軸）對齊網格項（grid items）內的內容 1234567891011121314151617.warp10, .warp11, .warp12, .warp13 &#123; display:grid; grid-template-columns: auto 50px auto; grid-template-areas: &quot;head head head&quot; &quot;foot &quot;; align-items:start; align-items:end; align-items:center; align-items:stretch; height: 50px; width: 200px; margin: 0 5px; border: 2px solid #f76707;&#125; justify-content - 網格區域 在 網格容器內 的「水平對齊」位置 start：將網格對齊到網格容器（grid container）的左邊 end：將網格對齊到網格容器的右邊 center：將網格對齊到網格容器的中間（水平居中） stretch：調整網格項（grid items）的寬度，允許該網格填充滿整個網格容器的寬度 space-around：在每個網格項之間放置一個均勻的空間，左右兩端放置一半的空間 space-between：在每個網格項之間放置一個均勻的空間，左右兩端沒有空間 space-evenly：在每個柵格項目之間放置一個均勻的空間，左右兩端放置一個均勻的空間 1234567891011121314151617181920.warp14, .warp15, .warp16, .warp17, .warp18, .warp19, .warp20 &#123; display:grid; grid-template-columns: auto 50px auto; grid-template-areas: &quot;head head head&quot; &quot;foot &quot;; justify-content:start; justify-content:end; justify-content:center; justify-content:stretch; justify-content:space-around; justify-content:space-between; justify-content:space-evenly; height: 100px; width: 150px; margin: 0 5px; border: 2px solid #f76707;&#125; align-content - 網格區域 在 網格容器內 的「垂直對齊」位置 1234567891011121314151617181920.warp21, .warp22, .warp23, .warp24, .warp25, .warp26, .warp27 &#123; display:grid; grid-template-columns: auto 50px auto; grid-template-areas: &quot;head head head&quot; &quot;foot &quot;; align-content:start; align-content:end; align-content:center; align-content:stretch; align-content:space-around; align-content:space-between; align-content:space-evenly; height: 100px; width: 150px; margin: 0 5px; border: 2px solid #f76707;&#125; 內容器 grid-column-start | grid-column-end | grid-row-start | grid-row-end 物件所佔的空間位置，column 及 row 所到的起始點及終點 通過指定網格線（grid lines）來確定網格內網格項（grid item）的位置 number | name | span number | span name | auto span number - 物件所佔用的欄位數 span name - 物件所在的 grid 名稱 auto - 自動 12345678910111213.item-boxIn &#123; grid-column-start: 2; grid-column-end: 4; grid-row-start: 2; grid-row-end: 3; height: 100%; width: 100%; border: 2px solid #f76707; background-color: #fff4e6; text-align:center;&#125; grid-column = grid-column-start + grid-column-end grid-row = grid-row-start + grid-row-end 1234567891011.item-boxIn2 &#123; grid-column: 2 / span 3; grid-row: 3 / auto; height: 100%; width: 100%; border: 2px solid #f76707; background-color: #fff4e6; text-align:center;&#125; grid-area: &lt;row-start&gt; / &lt;column-start&gt; / &lt;row-end&gt; / &lt;column-end&gt; 為網格項提供一個名稱，以便可以被使用網格容器 grid-template-areas 屬性創建的模板進行引用 12345678910.item-boxIn3&#123; display:grid; grid-area: header; grid-area: 1 / 2 / 4 / 5; border: 2px solid #f76707; background-color: #fff4e6; text-align:center;&#125; justify-self: start | end | center | stretch 沿著行軸線（row axis）對齊網格項的內容 此值適用於單個網格項目的內容 控制自己在網格中的位置 123456789101112131415.item-boxIn4, .item-boxIn5, .item-boxIn6&#123; display:grid; justify-self:start; justify-self:end; justify-self:center; justify-self:stretch; height: 30px; width: 60px; grid-area: 1 / 1 / 3 / 3; border: 2px solid #f76707; background-color: #fff4e6; text-align:center;&#125; align-self: start | end | center | stretch 沿著列軸線（列軸）對齊網格項內的內容 此值適用於單個網格項目的內容 控制自己在網格中的位置 123456789101112131415.item-boxIn8, .item-boxIn9, .item-boxIn10&#123; display:grid; align-self:start; align-self:end; align-self:center; align-self:stretch; height: 30px; width: 60px; grid-area: 1 / 1 / 3 / 3; border: 2px solid #f76707; background-color: #fff4e6; text-align:center;&#125; 自動響應式排列 auto-fill 不隨容器區域改變 minmax 最小和最大尺寸 12345678.warp30 &#123; display: grid; grid-gap: 5px; grid-template-columns: repeat(auto-fill, minmax(50px, 1fr)); grid-auto-rows: 50px;&#125; auto-fit 隨容器區域改變 12345678.warp31 &#123; display: grid; grid-gap: 5px; grid-template-columns: repeat(auto-fit, minmax(50px, 1fr)); grid-auto-rows: 50px;&#125;","categories":[{"name":"CSS","slug":"CSS","permalink":"https://jimmywei01.github.io/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://jimmywei01.github.io/tags/CSS/"},{"name":"grid","slug":"grid","permalink":"https://jimmywei01.github.io/tags/grid/"}]},{"title":"CSS-flex","slug":"CSS-flex","date":"2019-05-19T09:35:39.000Z","updated":"2019-05-27T05:50:35.472Z","comments":true,"path":"2019/05/19/CSS-flex/","link":"","permalink":"https://jimmywei01.github.io/2019/05/19/CSS-flex/","excerpt":"CSS flex 排版缺點 - 無法跨行跨列排版","text":"CSS flex 排版缺點 - 無法跨行跨列排版 可參考 -&gt; https://codepen.io/Jimmywei01/pen/wbemBx?editors=1100 flex 排版方向位置flex - 依照 排版方向(row column) 決定 分布位置( justify-content-主軸 align-items-副軸) 水平的起點與終點 ( main start、main end ) 垂直的起點與終點 ( cross start、cross end ) 水平軸與垂直軸 ( main axis、cross axis ) 元素具有水平尺寸與垂直尺寸 ( main size、cross size ) flex 外容器屬性 display flex-direction justify-content flex-wrap align-items align-content flex 內元件屬性 flex flex-grow flex-shrink flex-basis align-self order 外容器display flex inline-flex flex-direction - 分布方向 column：從上到下 column-reverse：與 column 相反 row：預設值，由左到右 row-reverse：與 row 相反 justify-content - 主軸 flexbox 的「水平對齊」位置 flex-start：預設值，對齊最左邊的 main start flex-end：對齊最左邊的 main end center：水平置中 space-between：平均分配內容元素，左右元素將會與 main start 和 main end 貼齊 space-around：平均分配內容元素，兩旁間距平均分配 space-evenly(空間均勻)：平均分配全部內容元素 flex-wrap - 超出範圍時是否換行的屬性，分為換行、不換行、換行時反轉 nowrap：預設值，單行 wrap：多行 wrap-reverse：多行，但內容元素反轉 align-items - 副軸(單行元素) Flexbox 的「垂直對齊」位置無效屬性: space-between , space-around , space-evenly flex-start：預設值，對齊最上面的 cross start flex-end：對齊最下面的 cross end center：垂直置中 stretch：將內容元素全部撐開至 flexbox 的高度 在高度被限制的情況下不會正常伸展 baseline：以所有元素內容的基線作為對齊標準 物件排列: justify-content + align-items align-content - 副軸(多行元素) flexbox 的「垂直對齊」位置 flex-start：預設值，對齊最上面的 cross start flex-end：對齊最下面的 cross end center：垂直置中 space-between：將第一行與最後一行分別對齊最上方與最下方 space-around：每行平均分配間距 stretch：內容元素全部撐開 內元件flex 由三個屬性組合而成，flex-grow、flex-shrink、flex-basis，如果 flex 只填了一個數值(無單位)，那麼預設就是以 flex-grow 的方式呈現 flex-grow : 指定 flex 項目的放大比例，按照數字做相對應的「伸展」比例分配，預設值為 0，不會進行彈性變化，不可為負值，設為 1 則會進行彈性變化 flex-shrink：指定 flex 項目的縮小比例，按照數字做相對應的「壓縮」比例分配(值越大壓縮越小)，預設值為 1，設為 0 的話不會進行彈性變化，不可為負值 flex-basis： 元件的基準值，可使用不同的單位值，子元素的基本大小作為父元素的大小比較基準，預設值為 0，沒有設定的時候會以直接採用 flex-grow 屬性 align-self - 和 align-items 相同，但目的不同(多行元素處理) align-self 的作用在於覆寫已經套用 align-items 的屬性 flex-start：預設值，對齊最上面的 cross start flex-end：對齊最下面的 cross end center：垂直置中 stretch：將內容元素全部撐開至 flexbox 的高度 baseline：以所有元素內容的基線作為對齊標準 order - 控制 flex 容器中 flex 項目的排列順序，默認值為 0 CSS 設定 排列順序：-1、flex:2、0、1、2","categories":[{"name":"CSS","slug":"CSS","permalink":"https://jimmywei01.github.io/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://jimmywei01.github.io/tags/CSS/"},{"name":"flex","slug":"flex","permalink":"https://jimmywei01.github.io/tags/flex/"}]},{"title":"CSS 紀錄","slug":"CSS-紀錄","date":"2019-05-16T05:40:41.000Z","updated":"2019-05-27T05:50:35.470Z","comments":true,"path":"2019/05/16/CSS-紀錄/","link":"","permalink":"https://jimmywei01.github.io/2019/05/16/CSS-紀錄/","excerpt":"紀錄常用的CSS -&gt; Cascading Style Sheet 層疊樣式表","text":"紀錄常用的CSS -&gt; Cascading Style Sheet 層疊樣式表 CSS - 塊級元素(block) &amp; 行內元素(inline) 塊級元素 自動換行 能設置寬高 margin 和 padding 上下左右的值都可以設定 &lt;div&gt;、&lt;p&gt;、&lt;ul&gt;、&lt;table&gt; 行內元素 不自動換行 設置寬高無效 padding 上下左右都可以設置；但 margin 左右值有效，上下值無效 &lt;a&gt;、&lt;span&gt;、&lt;img&gt;、&lt;button&gt;、 偽元素、label CSS - 選擇器 選擇器 表示方式 子孫 空格 孩子 &gt; 兄弟姊妹 ~/+ 元素 a{} 偽元素 ::before{} class .link{} 屬性 [type=radio]{} 偽類 :hover{} id #id{} 組合 [type=checkbox]+label{} 否定 :not(.link){} 通用 *{} CSS - 選擇器優先級!important(10000) &gt; 行內樣式(1000) &gt; id 選擇器(100) &gt; class 選擇器(10) &gt; tag 選擇器(1) CSS - 前綴詞 Chrome與Safari正是用webkit核心 -moz-則是Mozilla公司的縮寫(Gecko核心)，代表瀏覽器為Firefox -o-是Opera瀏覽器的縮寫(Presto核心) -ms-微軟的縮寫代表瀏覽器是ie 1234567.class&#123; -webkit-border-radius: 5px; -moz-border-radius: 5px; -ms-border-radius: 5px; -o-border-radius: 5px; border-radius: 5px;&#125; CSS - reset &amp; normalize reset 使用時機 - 設計師針對畫面樣式的規定不一定會與瀏覽器的預設相符的時候 把所有瀏覽器最不一致的地方強制歸 0 優點是統整、重置了各個瀏覽器的樣式設定 缺點是必須全部重新做設定，比較沒有彈性 normalize 最大的特色就是保留原本預設 HTML 標籤的樣式，僅針對不同瀏覽器與各版本間不相容的標籤進行些微調整 修正瀏覽器的 Bug 與不一致 CSS - 語法display - 常用的元件顯示類別屬性 block inline inline-block flex grid table none initial - 讓屬性恢復預設值 inherit black - 佔據一整行的方塊有自己的寬高，其他內容都會被擠走 123.block &#123; display :block; &#125; inline - 內容有多大就多大 沒辦法設定長寬 (符合內容長寬) 123456&lt;div class=&quot;block&quot;&gt;Lorem ipsum dolor&lt;/div&gt;.block &#123; display: inline; border: 1px solid red;&#125; inline-block - 可以設定寬高但又不會佔據一整行 123456789101112131415&lt;div class=&quot;block&quot;&gt;Lorem ipsum dolor&lt;/div&gt;&lt;div class=&quot;block2&quot;&gt;Lorem ipsum dolor&lt;/div&gt;.block &#123; display: inline-block; border: 1px solid red; width:50px; height:50px;&#125;.block2 &#123; display:inline-block; border: 1px solid red; width:50px; height:50px;&#125; display:none &amp; visibility:hidden &amp; overflow:hidden 差異 display:none - 使用此屬性之後元素不存在了，元素佔據的位置也不存在 visibility:hidden - 使用此屬性之後元素不存在了，元素佔據的位置依然存在 overflow:hidden - 對行內元素無效，必須是塊級元素，並且設置寬度高度，隱藏之後元素依然佔據著位置 display: flex 下 overflow: hidden 失效 在父元素設定 12min-width: 0; 或 min-height: 0;overflow: hidden; position - 用來設定”位子”的特性statice 定位元素 - 元件按照自然排列無法調整位置 1position: static; relative 相對定位元素 - 可調整元件的位置 123position: relative;top: 40px; left: 40px; absoult 絕對定位元素 - 找最近有設定過 position 的祖先 , 若沒有則去找 body 123position: absolute; top: 40px; left: 40px; fixed 固定定位 - 元件會固定在畫面上，不會隨捲軸滾動而移動 12position: fixed; top: 20px; sticky 黏性定位 - relative + fixed 混合 123position: -webkit-sticky; position: sticky; top: 20px; float - 文繞圖可參考 -&gt; https://developer.mozilla.org/zh-CN/docs/CSS/float 1float: none; 1float: left; 1float: right; CSS - 清除浮動元件codePen -&gt; https://codepen.io/Jimmywei01/pen/vwxzxE?editors=1100 float 浮動元素的父元素高度塌陷問題 clearfix 作法 建立假的元素，設定塊級元素(table or block)，左側和右側均不允許出現浮動元素 BFC (Block Formatting Contexts 塊級格式化上下文) 作法 (W3C CSS2.1 規範中的一個概念) 具有 BFC 特性的元素可以看作是隔離了的獨立容器，容器裡面的元素不會在佈局上影響到外面的元素，並且 BFC 具有普通容器所沒有的一些特性 可以把 BFC 理解為一個封閉的大箱子，箱子內部的元素無論如何設定都不會影響到外部元素 觸發BFC 特性： body 根元素 浮動元素：float 除 none 以外的值 絕對定位元素：position (absolute、fixed) display 為 inline-block、table-cells、flex overflow 除了 visible 以外的值(hidden、auto、scroll) BFC 作法 與 clearfix 擇一使用12345678910111213141516171819&lt;div class=“content clearfix&quot;&gt; &lt;div class=&quot;box&quot;&gt;box&lt;/div&gt; &lt;div class=&quot;box2&quot;&gt;box2&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;box3&quot;&gt;box3&lt;/div&gt;.content&#123; background-color:black; width:500px;/* BFC 作法 */ overflow:hidden;&#125;/* clearfix 作法 */.clearfix:after &#123; content: &quot;&quot;; display: table; clear: both;&#125; CSS - margin collapsing(崩塌) 兩個元件之間的 margin 重疊 讓父元素形成 BFC來接管自己的高度 在父元素增加 overflow:hidden 或在子元素增加 display:inline-hidden 等等 123456789101112131415161718192021.towBox&#123; /* overflow:hidden; */&#125;.box4 &#123; /* display:inline-block; */ margin:50px; background-color: pink; width: 100px; height:100px; text-align:center; line-height:100px;&#125;.box5 &#123; margin:50px; background-color: yellow; width: 100px; height:100px; text-align:center; line-height:100px;&#125; CSS - z-index 疊層樣式 可參考 https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Understanding_z_index/The_stacking_context https://codepen.io/Jimmywei01/pen/XwRYmQ?editors=1100 設定 HTML 元素定位屬性和 z-index 屬性創建一個層疊上下文 (opacity 值不為1 也會創建疊層) Root DIV #1 DIV #2 DIV #3 DIV #4 DIV #5 DIV #6 DIV #2、DIV #3 是 DIV #1 的子元素，它們的層疊和渲染完全在 DIV #1 中處理處理完成，DIV #1 元素作為一個整體並與 DIV #4、DIV #5 、DIV #6 元素進行層疊處理 CSS - box-model margin / border / padding / width / height max-width max-height 可參考 -&gt; https://codepen.io/Jimmywei01/pen/eaWNda box-sizing: content-box 元素的寬為 160px，那麼這個元素的內容區會有 160px 寬，並且任何邊框和內邊距的寬度都會被增加到最後繪製出來的元素寬度中 box-sizing: border-box 元素的 width 設為160px,那麼這160px 會包含其它的 border 和 padding，內容區的實際寬度會是width 減去 border + padding 的計算值 表示盒子模型的寬度和高度將包含其內邊距和邊框 更容易去設定元素的寬高 1234567891011121314151617181920&lt;div class=&quot;content-box&quot;&gt;Content box&lt;/div&gt;&lt;div class=&quot;border-box&quot;&gt;Border box&lt;/div&gt;div &#123; width: 160px; height: 80px; padding: 20px; border: 8px solid red; background: yellow;&#125;.content-box &#123; box-sizing: content-box; /* Total width: 160px + (2 * 20px) + (2 * 8px) = 216px Total height: 80px + (2 * 20px) + (2 * 8px) = 136px */&#125;.border-box &#123; box-sizing: border-box; /* Total width: 160px Total height: 80px */&#125; CSS 提問 CSS 的 class 和 id 差異？ id 權重 &gt; class 權重 同一個頁面上的兩個元素不能有相同的 id 屬性值 怎麼實現水平置中 &amp; 垂直置中 可參考 -&gt; https://ithelp.ithome.com.tw/users/20112550/ironman/2092 行內元素 12text-align: center;line-height: 100px; 塊級元素 1margin: 0 auto; 未知高度和寬度元素的水平垂直居中 被置中的元素是 inline 或者 inline-block 元素 1234567.container&#123; width: 600px; height: 600px; display: table-cell; text-align: center; vertical-align: middle;&#125; CSS3 的 transform 屬性 1234567891011.container&#123; width: 100%; height: 600px; position: relative;&#125;.center&#123; position:absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);&#125; flex 1234567.container&#123; width: 100%; height: 600px; display: flex; justify-content: center; align-items: center;&#125; 實現左邊定寬，右邊自適應佈局 左盒子左浮動，右盒子 width=100% 左盒子左浮動，右盒子 margin-left=左盒子寬度 左盒子左浮動，右盒子右浮動，設置 width: calc（100 % - 左盒子寬度） 父容器設置 display：flex，右盒子 flex：1","categories":[{"name":"CSS","slug":"CSS","permalink":"https://jimmywei01.github.io/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://jimmywei01.github.io/tags/CSS/"}]},{"title":"cookie、session、local storage、session storage 差異","slug":"cookie、session、local-storage、session-storage-差異","date":"2019-05-14T07:56:55.000Z","updated":"2019-05-27T06:02:47.624Z","comments":true,"path":"2019/05/14/cookie、session、local-storage、session-storage-差異/","link":"","permalink":"https://jimmywei01.github.io/2019/05/14/cookie、session、local-storage、session-storage-差異/","excerpt":"重要的傳遞手法","text":"重要的傳遞手法 session Storage 和 local Storage 的差別 可參考 https://developer.mozilla.org/zh-CN/docs/Web/API/Window/localStorage https://developer.mozilla.org/zh-CN/docs/Web/API/Window/sessionStorage JSON.stringify - 轉字串儲存 JSON.parse - 轉物件取出 寫入 local Storage (session Storage 亦同) 1234// 設定 local storagelet todo = [ ]todo.push(&apos;Mario red’,&apos;Mario blue’,&apos;Mario black’,&apos;Mario pink’,&apos;Mario yellow&apos;)localStorage.setItem(&apos;todolist&apos;,JSON.stringify(todo)) 12345678910// 取出 local storagelet data = JSON.parse(localStorage.getItem(&apos;todolist’))-&gt; [&quot;Mario red&quot;, &quot;Mario blue&quot;, &quot;Mario black&quot;, &quot;Mario pink&quot;, &quot;Mario yellow”]// 資料操作data.splice(data2.indexOf(&apos;Mario blue&apos;),1)-&gt; [&quot;Mario red&quot;, &quot;Mario black&quot;, &quot;Mario pink&quot;, &quot;Mario yellow”]// 刪除整個 local storagelocalStorage.removeItem(&apos;todolist&apos;) Storage sessionStorage localStorage 存儲大小限制 5M或更大，不會把數據發給服務器僅在本地保存 5M或更大，不會把數據發給服務器僅在本地保存 數據有效期 僅在當前瀏覽器窗口關閉前有效 始終有效，窗口或瀏覽器關閉也一直保存 作用域 不在不同的瀏覽器窗口中共享，即使是同一個頁面 在所有同源瀏覽器窗口中都是共享的 安全性 比 cookie 高一點 比 cookie 高一點 舉例 session Storage 傳送頁面 例如購物流程，加入購物車 &gt; 填寫購物資料 &gt; 進入結帳畫面 &gt; 成功 假設填寫購物資料時回到上一頁按加入購物車的時候， JS 就可透過 sessionStorage 傳遞即時資訊，而頁面關閉時購物資料的 sessionStorage 也會跟著關閉，以減少機敏資訊外流的風險 session 和 cookie 的差別 session：帳號登錄驗證過後，後端所發的識別證 cookie：是瀏覽器存放資料的地方，可以存放 seesion 之類的資料 後端可以要求前端要設置 cookie 來存放 seesion，這樣在換頁的時候，每發送一次 request 時順便也會把 seesion 送到後端，這樣後端都可以知道是同一個人（而不是每次都要送一次帳號密碼去做驗證） 建議在後端進行寫 cookie 操作，並通過 session 來控制 cookie 的過期時間 cookie 欄位 說明 name 名稱 key 鍵 value 內容 value 值 Domin 網域 取得該 cookie 的網域 path 路徑 設定可以存取該 cookie 路徑 secure 傳送連線類型 設定 cookie 是否要 https 才可以進行傳送 Expires 建立時間 限制 cookie 有效時間 httpOnly 此 cookie 只能從 web server 訪問，以避免不正確的進入來取得竄改 clint 端寫入 cookie 1document.cookie = &quot;myName=jimmy&quot; 12345// 寫入 cookie，並加入過期時間document.cookie=&quot;username=bob; expires=Mon, 04 Dec 2017 08:18:32 GMT; path=/&quot;// 寫入 cookie，設定 10 秒後失效document.cookie=&quot;username=bob; max-age=10; path=/&quot; server session cookie 儲存大小限制 與 cookie 共用，利用 session Id 來判定＆記錄資料 ex. 會員網站登入 cookie 在瀏覽器和服務器間來回傳遞，可以限制 cookie 只屬於某個路徑下。cookie 數據不能超過 4k，每次 http 請求都會攜帶 cookie 數據有效期 僅在當前瀏覽器窗口關閉前有效 在設置的 cookie 過期時間之前一直有效，即使窗口或瀏覽器關閉作用域 作用域 無 在所有同源瀏覽器窗口中都是共享的 安全性 比 cookie 高 低 舉例 cookie、session 登錄流程 客戶端使用用戶名跟密碼請求登錄 服務端收到請求，去驗證用戶名和密碼（後台根據請求去數據庫查找是否有該用戶） 驗證成功後，服務端會簽發一個 API token（進行 API 路徑存取時先 JWT 驗證 -&gt; 驗證成功才允許訪問該 API，該 token 值一般都會存入資料庫中，並設置過期時間），再把這個 token 發送給客戶端 客戶端收到 token 之後，再用 js 塞到 cookie 或 storage 裡面 客戶端每次向服務端請求資源的時候需要帶著服務端簽發的 token 服務端收到請求，然後去驗證客戶端請求裡面帶著的 token（token 是否為該用戶的令牌以及 token 是否有效等），如果驗證成功就向客戶端返回請求的數據","categories":[{"name":"HTTP","slug":"HTTP","permalink":"https://jimmywei01.github.io/categories/HTTP/"}],"tags":[{"name":"cookie","slug":"cookie","permalink":"https://jimmywei01.github.io/tags/cookie/"},{"name":"web storage","slug":"web-storage","permalink":"https://jimmywei01.github.io/tags/web-storage/"}]},{"title":"HTML 紀錄","slug":"HTML-紀錄","date":"2019-05-12T15:19:06.000Z","updated":"2019-05-27T06:02:47.627Z","comments":true,"path":"2019/05/12/HTML-紀錄/","link":"","permalink":"https://jimmywei01.github.io/2019/05/12/HTML-紀錄/","excerpt":"紀錄常用的HTML -&gt; Hyper Text Markup Language (超文本標記語言)","text":"紀錄常用的HTML -&gt; Hyper Text Markup Language (超文本標記語言) HTML - table 表格 thead table 頭 tbody table 身體 tfoot table 腳 th 預設是粗體置中，主要用在表格標題 td 單格 tr 整行 (整列) colspan 水平合併 rowspan 垂直合併 html1234567891011121314151617181920212223242526&lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;table標題&lt;/th&gt; &lt;th&gt;table標題2&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot;&gt;這裡是第一行&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;這裡是第二行的第一個欄位&lt;/td&gt; &lt;td rowspan=&quot;2&quot;&gt;這裡是第二行的第二個欄位&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;這裡是第三行的第一個欄位&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;tfoot&gt; &lt;tr&gt; &lt;td&gt;這裡是第四行的第一個欄位&lt;/td&gt; &lt;td rowspan=&quot;2&quot;&gt;這裡是第四行的第二個欄位&lt;/td&gt; &lt;/tr&gt; &lt;/tfoot&gt;&lt;/table&gt; HTML - form 表單可參考 -&gt; https://www.w3schools.com/html/html_form_input_types.asp display 預設為 inline 屬性 html1234&lt;form action=&quot;/searchList&quot; method=&apos;post&apos; enctype=&quot;application/x-www-form-urlencoded&quot;&gt; &lt;input type=&quot;text&quot; name=&apos;searchText&apos; id=&apos;text&apos; value = &apos;&apos;&gt; &lt;input type=&quot;submit&quot; id=&apos;send&apos; value=&apos;送出&apos;&gt;&lt;/form&gt; 屬性 值 描述 enctype application/x-www-form-urlencoded 在發送前編碼所有字元（預設） multipart/form-data 不對字元編碼在使用包含文件上傳控件的表單時，必須使用該值 text/plain 空格轉換為”+” 加號，但不對特殊字元編碼 application/json json 傳送物件資料 要轉成 ‘字串’ 傳送 accept MIME_type HTML 5 中不支持 可以用副檔名來指定可接受的檔案類型 accept-charset charset_list 規定服務器可處理的表單數據字符集 action URL 提交表單時向何處發送表單數據(詢問後端工程師要在哪驗證) autocomplete on、off 規定是否啟用表單的自動完成功能 method get、post 用於發送 form-data 的 HTTP 方法 name form_name 傳送給後台串連的名子 novalidate novalidate 如果使用該屬性 則提交表單時不進行驗證 target _blank、_self、_parent、_top、framename 規定在何處打開 action URL value form_value 傳送給後台的值 form 常用操作 input type required 自動驗證 pattern=”[A-z]{3}” 自訂驗證規則 html123&lt;input type=&quot;text&quot; name=&apos;searchText&apos; id=&apos;text&apos; value = &apos;&apos; required pattern=&quot;[A-z]&#123;3&#125;&quot;&gt;&lt;input type=&quot;submit&quot; id=&apos;send&apos; value=&apos;送出’&gt;&lt;input type=&quot;file&quot; accept=&quot;.pdf&quot; /&gt; radio 單選題 html12&lt;input type=&quot;radio&quot; name=&quot;gander&quot; value=&quot;male&quot;&gt;Male&lt;input type=&quot;radio&quot; name=&quot;gander&quot; value=&quot;female&quot;&gt;Female checkbox 多選題 html123&lt;input type=&quot;checkbox&quot; name=&quot;intersts&quot; value=&quot;reade&quot;&gt;read&lt;input type=&quot;checkbox&quot; name=&quot;intersts&quot; value=&quot;sleep&quot;&gt;sleep&lt;input type=&quot;checkbox&quot; name=&quot;intersts&quot; value=&quot;eat&quot;&gt;eat label (label for) 可用在點選文字 提升UX體驗 用 id 來對應 label 標籤的特性包在任何 input 標籤外面，點擊 label 就等於點擊 input 利用這個特性，將 label 標籤包在 input 上傳按鈕外，再將 input 上傳按鈕隱藏起來，點擊依然有效 使用圖片代替 input 上傳按鈕，可在 label 裡面放圖片 input 無法設定的任何 CSS，此時可設定在 label 上 html12&lt;label for=&quot;email&quot;&gt;email&lt;/label&gt;&lt;input type=&quot;email&quot; id=&quot;email&quot;&gt; select 下拉式選單html1234&lt;select name=&quot;month&quot;&gt; &lt;option value=&quot;1&quot;&gt;1&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;2&lt;/option&gt;&lt;/select&gt; button submit 傳送資料給後台 reset 將資料重整 button 單純按鈕無動作 可與 javascript 搭配完成特殊動作 html1234&lt;input type=&quot;text&quot;&gt;&lt;button type=&quot;submit&quot;&gt;submit&lt;/button&gt;&lt;button type=&quot;reset&quot;&gt;reset&lt;/button&gt;&lt;button type=&quot;button&quot;&gt;no action&lt;/button&gt; multiple 可同時選擇多個選項 html1234567&lt;select multiple=&quot;multiple&quot;size=&quot;4&quot;&gt; &lt;option value =&quot;volvo&quot;&gt;Volvo&lt;/option&gt; &lt;option value =&quot;saab&quot;&gt;Saab&lt;/option&gt; &lt;option value=&quot;opel&quot;&gt;Opel&lt;/option&gt; &lt;option value=&quot;audi&quot;&gt;Audi&lt;/option&gt; &lt;option value=&quot;bmw&quot;&gt;BMW&lt;/option&gt;&lt;/select&gt; textarea html12345678910// 限制 輸入內容文字長度&lt;textarea cols=&quot;30&quot; rows=&quot;10&quot;&gt;&lt;/textarea&gt;// 限制 textarea 被拉大的區域&lt;textarea cols=&quot;30&quot; rows=&quot;10&quot;&gt;&lt;/textarea&gt;textarea&#123; max-width: 300px; resize: none;&#125; HTML - 常犯的錯誤 塊級元素放入了行內元素內 html123&lt;a href=&quot;#&quot;&gt;&lt;h1&gt;wrong&lt;/h1&gt;&lt;/a&gt;&lt;h1&gt;&lt;a href=&quot;#&quot;&gt;right&lt;/a&gt;&lt;/h1&gt; 圖片 img 沒有包含設定 alt 屬性 幫助使用者以及搜尋引擎瞭解這張圖片有什麼意義 html12345不會顯示圖片&lt;img src=&quot;wrong.png&quot; alt=“”&gt; 會顯示圖片&lt;img src=&quot;right.png&quot; alt=&quot;right picture&quot;&gt; 用＜b＞和＜i＞標籤來達到字體加粗和斜體字的效果 ‘效果’ 就用 CSS ‘文章中的重要性’，則使用＜strong＞和＜em＞標籤 html123&lt;b&gt;粗體&lt;/b&gt; &lt;i&gt;斜體&lt;/i&gt;&lt;strong&gt;粗體&lt;/strong&gt; &lt;em&gt;斜體&lt;/em&gt; 使用太多的換行符號(斷行)＜br/＞ 不要使用 &lt;br/&gt; 來增加文字間距，應該用 CSS 的 margin 屬性、或改用 &lt;p&gt; 完成這件事 https://developer.mozilla.org/zh-TW/docs/Web/HTML/Element/br html1234567休息是為了走更長遠的路 &lt;br/&gt;&lt;br/&gt;真的嗎？&lt;p&gt;休息是為了走更長遠的路&lt;/p&gt;&lt;p&gt;真的嗎？&lt;/p&gt; 沒有使用標籤標題(如H1,H2,H3..) 常用 H1、H2、H3 和 &lt;strong&gt; 和 &lt;em&gt;，H4~H6 是我比較少用到 html123&lt;h1&gt;oh&lt;/h1&gt;&lt;h2&gt;oh&lt;/h2&gt;&lt;h3&gt;oh&lt;/h3&gt; HTML - 提問 DOCTYPE 有什麼作用？標準模式與混雜模式如何區分？它們有何意義?告訴瀏覽器使用哪個版本的 HTML 規範來渲染文件，DOCTYPE 不存在或形式不正確會導致 HTML 文件以混雜模式呈現 標準模式（Standards mode）以瀏覽器支援的最高標準執行 混雜模式（Quirks mode）中頁面是一種比較寬鬆的向後相容的方式顯示 HTML5 為什麼只需要寫 &lt;!DOCTYPE HTML&gt;？ HTML5 不基於 SGML（Standard Generalized Markup Language 標準通用標記語言),因此不需要對 DTD（DTD 文件型別定義）進行引用，但是需要 DOCTYPE 來規範瀏覽器行為 HTML4.01 基於 SGML，所以需要引用 DTD。才能告知瀏覽器文件所使用的文件型別，如下：&lt;!DOCTYPE HTML PUBLIC “-//W3C//DTD HTML 4.01//EN” “http://www.w3.org/TR/html4/strict.dtd”&gt; 行內元素有哪些？塊級元素有哪些？ 空(void)元素有那些？ 塊級元素：&lt;div&gt; &lt;ul&gt; &lt;ol&gt; &lt;li&gt; &lt;dl&gt; &lt;dt&gt; &lt;dd&gt; &lt;h1&gt; &lt;p&gt; 行內元素：&lt;a&gt; &lt;span&gt; &lt;img&gt; &lt;input&gt; &lt;select&gt; 空元素：&lt;hr&gt; &lt;link&gt; &lt;meta&gt; 頁面匯入樣式時，使用 link 和 @import 有什麼區別？ 都是外部引用 CSS 方式 @import 屬於 CSS 範疇，只能載入 CSS @import 需要在頁面完全載入以後載入，而且被 @import 引用的 CSS 會等到引用它的 CSS 檔案被載入完才載入 link 引用 CSS 時候，頁面載入時同時載入 link 方式的樣式的權重高於 @import 的權重 import 在 html 使用時候需要 &lt;style type=&quot;text/css&quot;&gt;標籤 介紹一下瀏覽器核心的理解？ 可參考 https://developers.google.com/web/fundamentals/performance/rendering/ https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction 渲染引擎 HTML 經過 HTML parser 產生 HTML DOM tree CSS 經過 CSS parser 產生 CSS rules 進入 style 將 rules 賦予 DOM tree 產生 style tree 的元素 進入 layout 將 style tree 元素進行排版產生 layout tree 進入 渲染顯示在應用程式上 JS 引擎 javascript 來實現網頁動態效果的解析和執行 每解析和執行渲染引擎會重新渲染 每個動作最好在 16 ms 內完成，因為多數裝置會以 每秒 60 次 重新整理螢幕 HTML 語義化的理解？ 去掉或丟失樣式的時候能夠讓頁面呈現出清晰的結構 有利於 SEO 和搜尋引擎建立良好溝通，有助於爬蟲抓取更多的資訊，爬蟲依賴於標籤來確定上下文和各個關鍵字的權重 方便其它裝置解析 便於團隊開發和維護 &lt;script&gt; 放置的位置？ 可參考 https://developer.mozilla.org/zh-TW/docs/Web/HTML/Element/script https://html.spec.whatwg.org/multipage/scripting.html 將 &lt;script&gt; 放置在 &lt;head&gt; 瀏覽器在解析過程中，發現 &lt;script&gt; 會阻斷頁面上其他 HTML 的解析，下載完所有 &lt;script&gt; 在往下解析 HTML，這會導致使用者感到不順感 將 &lt;script&gt; 放置在 &lt;body&gt; 尾端 瀏覽器在整個 HTML 解析完成之前都不能下載 &lt;script&gt;，如果 HTML 很大解析完HTML，使用者依然要等待 &lt;script&gt; 下載並執行完成之後才能操作這個網站 async - asynchronous(非同步) 以非同步的方法執行 如果沒有 src 屬性的話，就不能用這個屬性在這種情況下，它將失去作用 只要下載完就執行，有可能會導致 script2.js 可能先於 script1.js 執行(載完的先跑) 12&lt;script src=&quot;script1.js&quot; async&gt;&lt;/script&gt;&lt;script src=&quot;script2.js&quot; async&gt;&lt;/script&gt; defer - deferred(延遲) 與 async 相同在 HTML 在解析時下載 &lt;script&gt;， &lt;script&gt; 會等到 HTML 載完才開始工作，而且會按照順序一個一個來，也就是說 script1.js 永遠優先於 script2.js 12&lt;script src=&quot;script1.js&quot; defer&gt;&lt;/script&gt;&lt;script src=&quot;script2.js&quot; defer&gt;&lt;/script&gt;","categories":[{"name":"HTML","slug":"HTML","permalink":"https://jimmywei01.github.io/categories/HTML/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://jimmywei01.github.io/tags/HTML/"},{"name":"HTML5","slug":"HTML5","permalink":"https://jimmywei01.github.io/tags/HTML5/"}]},{"title":"HTML Meta tages 屬性設定","slug":"HTML-Meta-tages-的屬性設定","date":"2019-05-10T13:15:54.000Z","updated":"2019-05-27T06:02:47.623Z","comments":true,"path":"2019/05/10/HTML-Meta-tages-的屬性設定/","link":"","permalink":"https://jimmywei01.github.io/2019/05/10/HTML-Meta-tages-的屬性設定/","excerpt":"SEO 網頁優化必備的 Meta 標籤","text":"SEO 網頁優化必備的 Meta 標籤 meta 存放位置在 head 之間 告訴瀏覽器 HTML5 網頁的編碼1&lt;meta charset=&quot;UTF-8&quot;&gt; 控制用戶的 viewport (可見區域)的方法1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no&quot;&gt; viewport 設定 屬性 說明 width 設定畫面寬度 height 設定畫面高度 initial-scale 設定畫面的初始縮放比例 minimum-scale 設定畫面的最小縮放比例 maximum-scale 設定畫面的最大縮放比例 user-scalable 設定是否允許使用者改變縮放比例 width=device-width 可以自動符合所有不同手機螢幕預設的最佳解析度 initial-scale=1 設定手機螢幕畫面的初始縮放比例為 100% user-scalable=no 不允許使用者改變縮放比例，則會將值設為 no 網頁相容模式，沒指定會依照使用者所使用的瀏覽器的版本為主，因此可利用此語法跟瀏覽器說用哪個版本來作瀏覽1&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;/&gt; 網站頁面 icon1&lt;link rel=&quot;shortcut icon&quot; href=&quot;favicon.ico&quot;&gt; 關鍵字 - 用逗號(,)隔開，最好不要有空白1&lt;meta name=&quot;keywords&quot; content=&quot;程式,哲學&quot; /&gt; meta name 的屬性值 屬性 說明 meta name=”author” content=”作者姓名” 記錄網頁的作者名稱 meta name=”description” content=”網頁簡短描述” 網頁的簡短描述 meta name=”generator” content=”編輯器名稱” 記錄網頁編輯器名稱 meta name=”keywords” content=”網頁關鍵字” 放置網頁關鍵字 meta name=”distribution” content=”網頁發佈地區” 記錄網頁的發佈地區 網頁隱私用來告知搜尋引擎該網頁是否可被搜尋，並且有幾個參數可作設定 noindex：不要檢索 nofollow：只檢索該頁，不檢索該頁裡的鏈結 noindex, nofollow：搜尋引擎的小蜘蛛到這裡時，就會停止，不作任何的檢索1234&lt;meta name=&quot;robots&quot; content=&quot;index,follow&quot; /&gt;&lt;meta name=&quot;robots&quot; content=&quot;noindex,follow&quot; /&gt;&lt;meta name=&quot;robots&quot; content=&quot;index,nofollow&quot; /&gt;&lt;meta name=&quot;robots&quot; content=&quot;noindex,nofollow&quot; /&gt; 社群平台 mets tages可用 -&gt; https://metatags.io/ 1234567891011121314151617181920212223242526272829&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;/&gt; &lt;title&gt;HTML meta tages 介紹&lt;/title&gt; &lt;link rel=&quot;shortcut icon&quot; href=&quot;favicon.ico&quot;&gt; &lt;meta name=&quot;keywords&quot; content=&quot;程式,哲學&quot; /&gt; &lt;meta name=&quot;title&quot; content=&quot;Jimmy&apos;s Notes&quot;&gt; &lt;meta name=&apos;description&apos; content=&apos;網站描述文字&apos; /&gt; &lt;meta name=&quot;robots&quot; content=&quot;index,follow&quot; /&gt; &lt;meta name=&quot;robots&quot; content=&quot;noindex,follow&quot; /&gt; &lt;meta name=&quot;robots&quot; content=&quot;index,nofollow&quot; /&gt; &lt;meta name=&quot;robots&quot; content=&quot;noindex,nofollow&quot; /&gt; &lt;meta property=&quot;og:title&quot; content=&quot;FB的標題&quot; /&gt; &lt;meta property=&quot;og:description&quot; content=&quot;FB的描述&quot;&gt; &lt;meta property=&quot;og:type&quot; content=&quot;website&quot; /&gt; &lt;meta property=&quot;og:url&quot; content=&quot;FB上的網址&quot; /&gt; &lt;meta property=&quot;og:image&quot; content=&quot;FB的圖片&quot; /&gt; &lt;link href=&quot;圖片路徑&quot; rel=&quot;apple-touch-icon&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;CSS檔案路徑&quot;&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;JS檔案路徑&quot;&gt;&lt;/script&gt;&lt;/head&gt;","categories":[{"name":"HTML","slug":"HTML","permalink":"https://jimmywei01.github.io/categories/HTML/"}],"tags":[{"name":"Analytics","slug":"Analytics","permalink":"https://jimmywei01.github.io/tags/Analytics/"},{"name":"HTML","slug":"HTML","permalink":"https://jimmywei01.github.io/tags/HTML/"},{"name":"HTML5","slug":"HTML5","permalink":"https://jimmywei01.github.io/tags/HTML5/"}]},{"title":"使用Google_Search_Console和sitemap進行SEO優化","slug":"使用Google-Search-Console和sitemap進行SEO優化","date":"2019-05-09T15:11:41.000Z","updated":"2019-05-27T06:02:47.626Z","comments":true,"path":"2019/05/09/使用Google-Search-Console和sitemap進行SEO優化/","link":"","permalink":"https://jimmywei01.github.io/2019/05/09/使用Google-Search-Console和sitemap進行SEO優化/","excerpt":"讓你的網站更親近 Google","text":"讓你的網站更親近 Google 前言為了讓文章可以被 Google 搜尋到所以設定 sitemap &amp; Google_Search_Console 流程sitemap使用 npm 自動生成網站的 sitemap，然後將生成的 sitemap 提交 Google 1npm install hexo-generator-sitemap --save 修改文件設定將 sitemap 加到站點設定文件 _config.yml 中，並修改 url 為自己的網址 路徑：/_config.yml 123# sitmapsitemap: path: sitemap.xml 重新部署到 GitHub \b選擇性增加 \brobots.txt\b\b主要行為就是在搜尋引擎檢索網站時，告訴它網站哪些內容可以被檢索，哪些內容可以不用被檢索\b可參考 \b-&gt; robots.txt用途與使用範例教學，釐清SEO收錄觀念 在站點 source 文件夾下新建 robots.txt 文件，文件內容如下 Allow 字段的值即為允許搜索引擎爬區的內容，可以對應到主題配置文件中的 menu 目錄配置，如果還有其他選項都可以按照格式自行添加 需要將 https://hoxis.github.io 改成自己的域名 1234567891011121314User-agent: *Allow: /Allow: /archives/Allow: /categories/Allow: /tags/ Allow: /resources/ Disallow: /vendors/Disallow: /js/Disallow: /css/Disallow: /fonts/Disallow: /vendors/Disallow: /fancybox/Sitemap: https://hoxis.github.io/sitemap.xml Google_Search_Consolehttps://www.google.com/webmasters/#?modal_active=none 可參考 -&gt; 新版Google Search Console基礎介紹，透析新舊版介面、功能差異 登入後，會顯示你沒有存取這項資源的權限 點擊驗證擁有權可以發現有多種驗證方式，我們用\b上一篇埋好的 GA 進行驗證如果失敗就回去 &lt;head&gt; 確認有沒有正確埋入 成功後進入 sitemap \b面板選項再加入 sitemap.xml 加入網址索引 點擊 網址審查加入網頁 點擊右上方的測試線上網址可以即時測試網頁是否能夠讓 Google 進行索引 點擊 加入索引 完成後 最後可以用 site:你的網址 來看有沒有被 Google 搜尋到","categories":[{"name":"Analytics","slug":"Analytics","permalink":"https://jimmywei01.github.io/categories/Analytics/"}],"tags":[{"name":"Analytics","slug":"Analytics","permalink":"https://jimmywei01.github.io/tags/Analytics/"},{"name":"hexo","slug":"hexo","permalink":"https://jimmywei01.github.io/tags/hexo/"}]},{"title":"使用GA替網站作分析","slug":"使用GA替網站作分析","date":"2019-05-09T11:24:15.000Z","updated":"2019-05-27T06:02:47.625Z","comments":true,"path":"2019/05/09/使用GA替網站作分析/","link":"","permalink":"https://jimmywei01.github.io/2019/05/09/使用GA替網站作分析/","excerpt":"Google Analytics SEO 的工具之一","text":"Google Analytics SEO 的工具之一 前言為什麼會寫這篇？因為建立好 Hexo NexT 的 theme 之後， 加入 GA 分析可以讓自己了解到哪些屬於熱門文章，but 沒想到加入 GA 後 GA 無效，只好將 網站追蹤碼 貼入 \b&lt;head&gt; 而非使用原先 NexT 的方法，流程如下 流程GA \b申請點擊這個連結進入申請 -&gt; Google Analytics 輸入相關資料 Account Name: 輸入自己可以辨別的名稱 網站名稱: 網站名稱 網站網址: 需注意 http 及 https 產類類別: 依照相關選取即可 取得追蹤 ID 跳出同意視窗，打勾同意送出 成功後進入畫面 埋入 GAGA埋入使用 網站追蹤碼紅色框部分貼入 &lt;head&gt; Hexo 埋入 GA複製追蹤 ID(管理 &gt; 追蹤資訊 &gt; 追蹤程式碼) 將追蹤 ID \b貼入 themes/next/_config.yml 第 758 行123google_analytics: tracking_id: UA-XXXXXX-1 localhost_ignored: true 修改 google-analytics.swig 檔案檔案路徑 \b: themes/next/layout/_third-party/analytics/google-analytics.swig NexT 模板預設的 src 路徑不正確所導致需要加上 https://1234567加入前&lt;script async src=&quot;//www.googletagmanager.com/gtag/js?id=&#123;&#123; theme.google_analytics.tracking_id &#125;&#125;&quot;&gt;&lt;/script&gt;加入後&lt;script async src=&quot;https://www.googletagmanager.com/gtag/js?id=&#123;&#123; theme.google_analytics.tracking_id &#125;&#125;&quot;&gt;&lt;/script&gt; 測試埋入結果回到追蹤程式碼頁面，然後上面有一個傳送測試瀏覽按鈕，按下可以看結果，but 都沒回傳結果 將 網站追蹤碼 貼入 \b&lt;head&gt;檔案路徑 \b: themes/next/layout/_partials/head/head.swig 重新部署到 GitHub 開啟 GitHub Pages 確認 GA 是否在 &lt;head&gt; 中 回到追蹤程式碼頁面，按下測試瀏覽按鈕看結果，測試成功 下篇介紹\b利用 GA 認證 Google Search Console 更有利於 Google 搜尋","categories":[{"name":"Analytics","slug":"Analytics","permalink":"https://jimmywei01.github.io/categories/Analytics/"}],"tags":[{"name":"Analytics","slug":"Analytics","permalink":"https://jimmywei01.github.io/tags/Analytics/"},{"name":"hexo","slug":"hexo","permalink":"https://jimmywei01.github.io/tags/hexo/"}]},{"title":"MarkDown、Hexo、NexT 常用寫法","slug":"MarkDown、Hexo、NexT-常用寫法","date":"2019-05-09T03:43:00.000Z","updated":"2019-05-27T06:02:47.621Z","comments":true,"path":"2019/05/09/MarkDown、Hexo、NexT-常用寫法/","link":"","permalink":"https://jimmywei01.github.io/2019/05/09/MarkDown、Hexo、NexT-常用寫法/","excerpt":"記\b不下來就寫下來","text":"記\b不下來就寫下來 MarkDown 常用寫法 字體基本設定 階層式區塊語法&gt;text 、 \b&gt;&gt;text 、 &gt;&gt;&gt;text 粗體 **your text**斜體 *your text*刪除線 ~~your text~~超連結 [超連結](https://jimmywei01.github.io/) 小區塊`your text` 大區塊前後三個反引號 標題123456# H1## H2### H3#### H4##### H5###### H6 文字增加顏色20px的字15px的字 12&lt;font style=\"color:#f90;font-size:20px;\"&gt;20px的字&lt;/font&gt;&lt;font style=\"color:red;font-size:10px;\"&gt;10px的字&lt;/font&gt; 列表 Item 1 Item 2 Item 2a Item 2b 1234* Item 1* Item 2 * Item 2a * Item 2b 表格冒號（Colons）是用來對齊的（擺左齊左、擺右齊右，都擺就置中） Markdown Less Pretty Still renders nicely 1 2 3 1234Markdown | Less | Pretty--- | :---: | ---:*Still* | `renders` | nicely1 | 2 | 3: Hexo 標籤外掛 hexo 標籤外掛參考連結https://hexo.io/zh-tw/docs/tag-plugins hexo 指令 啟動 serverhexo server 建立新文章hexo new post [title] s →啟動伺服器 -g →生成靜態頁面hexo s -g d →部屬模式 -g →生成靜態頁面hexo d -g 刪除已生成的靜態頁面及快取檔案hexo clean 程式碼區塊寫法 [language] 是代碼語言的名稱，用來設置代碼塊顏色高亮，非必須 [title] 是頂部左邊的說明，非必須 [url] 是頂部右邊的超鏈接地址，非必須 [link text] 如它的字面意思，超鏈接的名稱，非必須 使用 代碼塊語法123&#123;% codeblock [language] [title] [url] [link text] %&#125; your code&#123;% endcodeblock %&#125; css css /index 首頁12345.container &#123; max-width: 960px; margin: 0 auto; margin-top: 10px;&#125; 加上說明 123&#123;% codeblock Array.map %&#125;array.map(callback[, thisArg])&#123;% endcodeblock %&#125; Array.map1array.map(callback[, thisArg]) 加上說明和網址 1234&#123;% codeblock _.compact http://underscorejs.org/#compact Underscore.js %&#125;_.compact([0, 1, false, 2, &apos;&apos;, 3]);=&gt; [1, 2, 3]&#123;% endcodeblock %&#125; _.compactUnderscore.js12_.compact([0, 1, false, 2, &apos;&apos;, 3]);=&gt; [1, 2, 3] 使用\b 大區塊(前後三個反引號)123``` [language] [title] [url] [link text] your code ``` css首頁 123456.container &#123; max-width: 960px; margin: 0 auto; /* 起手式 */ margin-top: 10px;&#125; NexT 無需路徑名插入圖片 新建文章在相同目錄下創建同名文件夾（便於圖片管理） 打開站點配置文件_config.yml/post_asset_folder，設置值為true 安裝hexo-asset-image：npm install hexo-asset-image –save 此時hexo new “fileName”會在/source/_posts目錄下創建同名的文件夾 12只需在md文件裡使用 無需路徑名就可以插入圖片![title](圖片名.jpg) 文章頁面顯示繼續閱讀1&lt;!-- more —&gt;","categories":[{"name":"other","slug":"other","permalink":"https://jimmywei01.github.io/categories/other/"}],"tags":[{"name":"other","slug":"other","permalink":"https://jimmywei01.github.io/tags/other/"}]}]}