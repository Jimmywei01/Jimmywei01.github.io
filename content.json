{"meta":{"title":"Jimmy's Notes","subtitle":"你可以沒有熱情，但不應該自我設限","description":"光電/程式/工藝/設計/哲學","author":"Jimmy Wei","url":"https://jimmywei01.github.io","root":"/"},"pages":[{"title":"標籤","date":"2019-05-08T02:59:20.000Z","updated":"2019-05-08T03:09:06.786Z","comments":true,"path":"tags/index.html","permalink":"https://jimmywei01.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2019-05-07T09:18:08.761Z","updated":"2019-05-07T09:18:08.760Z","comments":true,"path":"css/insight.css","permalink":"https://jimmywei01.github.io/css/insight.css","excerpt":"","text":".ins-section-container { position: relative; background: #f7f7f7; } .ins-section { font-size: 14px; line-height: 16px; } .ins-section .ins-section-header, .ins-section .ins-search-item { padding: 8px 15px; } .ins-section .ins-section-header { color: #9a9a9a; border-bottom: 1px solid #e2e2e2; } .ins-section .ins-slug { margin-left: 5px; color: #9a9a9a; } .ins-section .ins-slug:before { content: '('; } .ins-section .ins-slug:after { content: ')'; } .ins-section .ins-search-item header, .ins-section .ins-search-item .ins-search-preview { overflow: hidden; white-space: nowrap; text-overflow: ellipsis; } .ins-section .ins-search-item header .ins-title { margin-left: 8px; } .ins-section .ins-search-item .ins-search-preview { height: 15px; font-size: 12px; color: #9a9a9a; margin: 5px 0 0 20px; } .ins-section .ins-search-item:hover, .ins-section .ins-search-item.active { color: #fff; background: #3273dc; } .ins-section .ins-search-item:hover .ins-slug, .ins-section .ins-search-item.active .ins-slug, .ins-section .ins-search-item:hover .ins-search-preview, .ins-section .ins-search-item.active .ins-search-preview { color: #fff; }"},{"title":"","date":"2019-05-07T09:18:08.759Z","updated":"2019-05-07T09:18:08.752Z","comments":true,"path":"css/back-to-top.css","permalink":"https://jimmywei01.github.io/css/back-to-top.css","excerpt":"","text":"#back-to-top { position: fixed; padding: 8px 0; transition: 0.4s ease opacity, 0.4s ease width, 0.4s ease transform, 0.4s ease border-radius; opacity: 0; line-height: 24px; outline: none; transform: translateY(120px); } #back-to-top.fade-in { opacity: 1; } #back-to-top.rise-up { transform: translateY(0); }"},{"title":"分類","date":"2019-05-08T03:05:56.000Z","updated":"2019-05-08T03:09:44.415Z","comments":true,"path":"categories/index.html","permalink":"https://jimmywei01.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2019-05-07T09:18:08.762Z","updated":"2019-05-07T09:18:08.762Z","comments":true,"path":"css/progressbar.css","permalink":"https://jimmywei01.github.io/css/progressbar.css","excerpt":"","text":".pace { -webkit-pointer-events: none; pointer-events: none; -webkit-user-select: none; -moz-user-select: none; user-select: none; } .pace-inactive { display: none; } .pace .pace-progress { background: #3273dc; position: fixed; z-index: 2000; top: 0; right: 100%; width: 100%; height: 2px; }"},{"title":"","date":"2019-05-07T09:18:08.763Z","updated":"2019-05-07T09:18:08.763Z","comments":true,"path":"css/search.css","permalink":"https://jimmywei01.github.io/css/search.css","excerpt":"","text":".searchbox { display: none; perspective: 50em; top: 0; left: 0; width: 100%; height: 100%; z-index: 100; background: rgba(0, 0, 0, 0.7); transform-origin: 0%; perspective-origin: top center; } .searchbox.show { display: block; } .searchbox, .searchbox .searchbox-container { position: fixed; } .searchbox .searchbox-container { overflow: hidden; } .searchbox .searchbox-selectable { cursor: pointer; } .searchbox .searchbox-input-wrapper { position: relative; } .searchbox .searchbox-input-wrapper .searchbox-input { width: 100%; border: none; outline: none; font-size: 16px; box-shadow: none; font-weight: 200; border-radius: 0; background: #fff; line-height: 20px; box-sizing: border-box; padding: 12px 28px 12px 20px; border-bottom: 1px solid #e2e2e2; } .searchbox .searchbox-input-wrapper .searchbox-close { top: 50%; right: 6px; width: 20px; height: 20px; line-height: 20px; font-size: 16px; margin-top: -11px; position: absolute; text-align: center; display: inline-block; } .searchbox .searchbox-input-wrapper .searchbox-close:hover { color: #3273dc; } .searchbox .searchbox-result-wrapper { left: 0; right: 0; top: 45px; bottom: 0; overflow-y: auto; position: absolute; } .searchbox .searchbox-container { left: 50%; top: 100px; width: 540px; z-index: 101; bottom: 100px; margin-left: -270px; box-sizing: border-box; } @media screen and (max-width: 559px), screen and (max-height: 479px) { .searchbox .searchbox-container { top: 0; left: 0; margin: 0; width: 100%; height: 100%; background: #f7f7f7; } }"},{"title":"","date":"2019-05-11T11:48:33.093Z","updated":"2019-05-11T11:48:33.093Z","comments":true,"path":"js/back-to-top.js","permalink":"https://jimmywei01.github.io/js/back-to-top.js","excerpt":"","text":"$(document).ready(function () { var $button = $('#back-to-top'); var $footer = $('footer.footer'); var $mainColumn = $('.column-main'); var $leftSidebar = $('.column-left'); var $rightSidebar = $('.column-right'); var lastScrollTop = 0; var rightMargin = 20; var bottomMargin = 20; var lastState = null; var state = { base: { classname: 'card has-text-centered', left: '', width: 64, bottom: bottomMargin, 'border-radius': 4 } }; state['desktop-hidden'] = Object.assign({}, state.base, { classname: state.base.classname + ' rise-up', }); state['desktop-visible'] = Object.assign({}, state['desktop-hidden'], { classname: state['desktop-hidden'].classname + ' fade-in', }); state['desktop-dock'] = Object.assign({}, state['desktop-visible'], { classname: state['desktop-visible'].classname + ' fade-in', width: 40, 'border-radius': '50%' }); state['mobile-hidden'] = Object.assign({}, state.base, { classname: state.base.classname + ' fade-in', right: rightMargin }); state['mobile-visible'] = Object.assign({}, state['mobile-hidden'], { classname: state['mobile-hidden'].classname + ' rise-up', }); function isStateEquals(prev, next) { for (var prop in prev) { if (!next.hasOwnProperty(prop) || next[prop] !== prev[prop]) { return false; } } for (var prop in next) { if (!prev.hasOwnProperty(prop) || prev[prop] !== prev[prop]) { return false; } } return true; } function applyState(state) { if (lastState !== null && isStateEquals(lastState, state)) { return; } $button.attr('class', state.classname); for (let prop in state) { if (prop === 'classname') { continue; } $button.css(prop, state[prop]); } lastState = state; } function isDesktop() { return window.innerWidth >= 1078; } function isTablet() { return window.innerWidth >= 768 && !isDesktop(); } function isScrollUp() { return $(window).scrollTop() < lastScrollTop && $(window).scrollTop() > 0; } function hasLeftSidebar() { return $leftSidebar.length > 0; } function hasRightSidebar() { return $rightSidebar.length > 0; } function getRightSidebarBottom() { if (!hasRightSidebar()) { return 0; } return Math.max.apply(null, $rightSidebar.find('.widget').map(function () { return $(this).offset().top + $(this).outerHeight(true); })); } function getScrollTop() { return $(window).scrollTop(); } function getScrollBottom() { return $(window).scrollTop() + $(window).height(); } function getButtonWidth() { return $button.outerWidth(true); } function getButtonHeight() { return $button.outerHeight(true); } function updateScrollTop() { lastScrollTop = $(window).scrollTop(); } function update() { // desktop mode or tablet mode with only right sidebar enabled if (isDesktop() || (isTablet() && !hasLeftSidebar() && hasRightSidebar())) { var nextState; var padding = ($mainColumn.outerWidth() - $mainColumn.width()) / 2; var maxLeft = $(window).width() - getButtonWidth() - rightMargin; var maxBottom = $footer.offset().top + getButtonHeight() / 2 + bottomMargin; if (getScrollTop() == 0 || getScrollBottom() < getRightSidebarBottom() + padding + getButtonHeight()) { nextState = state['desktop-hidden']; } else if (getScrollBottom() < maxBottom) { nextState = state['desktop-visible']; } else { nextState = Object.assign({}, state['desktop-dock'], { bottom: getScrollBottom() - maxBottom + bottomMargin }); } var left = $mainColumn.offset().left + $mainColumn.outerWidth() + padding; nextState = Object.assign({}, nextState, { left: Math.min(left, maxLeft) }); applyState(nextState); } else { // mobile and tablet mode if (!isScrollUp()) { applyState(state['mobile-hidden']); } else { applyState(state['mobile-visible']); } updateScrollTop(); } } update(); $(window).resize(update); $(window).scroll(update); $('#back-to-top').on('click', function () { $('body, html').animate({ scrollTop: 0 }, 400); }); });"},{"title":"","date":"2019-05-07T09:18:08.759Z","updated":"2019-05-07T09:18:08.754Z","comments":true,"path":"js/animation.js","permalink":"https://jimmywei01.github.io/js/animation.js","excerpt":"","text":"(function () { function $() { return Array.prototype.slice.call(document.querySelectorAll.apply(document, arguments)); } $('body > .navbar, body > .section, body > .footer').forEach(function (element) { element.style.transition = '0s'; element.style.opacity = '0'; }); document.querySelector('body > .navbar').style.transform = 'translateY(-100px)'; ['.column-main > .card', '.column-left > .card, .column-right-shadow > .card', '.column-right > .card'].map(function (selector) { $(selector).forEach(function (element) { element.style.transition = '0s'; element.style.opacity = '0'; element.style.transform = 'scale(0.8)'; element.style.transformOrigin = 'center top'; }); }); setTimeout(function () { $('body > .navbar, body > .section, body > .footer').forEach(function (element) { element.style.opacity = '1'; element.style.transition = 'opacity 0.3s ease-out, transform 0.3s ease-out'; }); document.querySelector('body > .navbar').style.transform = 'translateY(0)'; ['.column-main > .card', '.column-left > .card, .column-right-shadow > .card', '.column-right > .card'].map(function (selector) { var i = 1; $(selector).forEach(function (element) { setTimeout(function () { element.style.opacity = '1'; element.style.transform = ''; element.style.transition = 'opacity 0.3s ease-out, transform 0.3s ease-out'; }, i * 100); i++; }); }); }); })();"},{"title":"","date":"2019-05-07T12:54:51.550Z","updated":"2019-05-07T12:54:51.550Z","comments":true,"path":"css/style.css","permalink":"https://jimmywei01.github.io/css/style.css","excerpt":"","text":"/* --------------------------------- * Override CSS Framework * --------------------------------- */ html { font-size: 14px; } body { background-color: #f7f7f7; } body, button, input, select, textarea { font-family: \"Ubuntu\", \"Roboto\", \"Open Sans\", \"Microsoft YaHei\", sans-serif; } @media screen and (min-width: 1280px) { .is-1-column .container, .is-2-column .container { max-width: 960px; width: 960px; } } @media screen and (min-width: 1472px) { .is-2-column .container { max-width: 1152px; width: 1152px; } .is-1-column .container { max-width: 960px; width: 960px; } } @media screen and (max-width: 768px) { .section { padding: 1.5rem 1rem; } } @media screen and (min-width: 769px) { .column-main.is-sticky, .column-left.is-sticky, .column-right.is-sticky, .column-right-shadow.is-sticky { align-self: flex-start; position: -webkit-sticky; position: sticky; top: 0.75rem; } .column-right-shadow.is-sticky { top: 1.5rem; } } .tag.is-grey { background: #e7e7e7; } .card { border-radius: 4px; box-shadow: 0 4px 10px rgba(0,0,0,0.05), 0 0 1px rgba(0,0,0,0.1); } .card + .card, .card + .column-right-shadow { margin-top: 1.5rem; } .card.card-transparent { box-shadow: none; background: transparent; } .card .card-image { overflow: hidden; border-top-left-radius: 4px; border-top-right-radius: 4px; } img.thumbnail { object-fit: cover; width: 100%; height: 100%; } .navbar-logo img, .footer-logo img { max-height: 1.75rem; } .navbar-main { box-shadow: 0 4px 10px rgba(0,0,0,0.05); } .navbar-main .navbar-menu, .navbar-main .navbar-start, .navbar-main .navbar-end { align-items: stretch; display: flex; padding: 0; flex-shrink: 0; } .navbar-main .navbar-menu { flex-grow: 1; flex-shrink: 0; overflow-x: auto; } .navbar-main .navbar-start { justify-content: flex-start; margin-right: auto; } .navbar-main .navbar-end { justify-content: flex-end; margin-left: auto; } .navbar-main .navbar-item { display: flex; align-items: center; padding: 1.25rem 0.75rem; } .navbar-main .navbar-item.is-active { color: #3273dc; background-color: transparent; } @media screen and (max-width: 1087px) { .navbar-main .navbar-menu { justify-content: center; box-shadow: none; } .navbar-main .navbar-start { margin-right: 0; } .navbar-main .navbar-end { margin-left: 0; } } .footer { background: #fff; } .footer .field .button { background: transparent; } .widget .media { border: none; } .widget .media + .media { margin-top: 0; } .widget .menu-list li ul { margin-right: 0; } .widget .menu-list a.level { display: flex; } .pagination .pagination-link:not(.is-current), .pagination .pagination-previous, .pagination .pagination-next { background: #fff; border: none; } .pagination .pagination-link, .pagination .pagination-previous, .pagination .pagination-next { box-shadow: 0 4px 10px rgba(0,0,0,0.05); } .post-navigation { justify-content: space-around; } .post-navigation .level-item { margin-bottom: 0; } .timeline { margin-left: 1rem; padding-left: 1.5rem; padding-top: 1rem; border-left: 1px solid #dbdbdb; } .timeline .media { position: relative; } .timeline .media:before, .timeline .media:last-child:after { content: ''; display: block; position: absolute; left: calc(-5px - 1.5rem); } .timeline .media:before { width: 9px; height: 9px; top: 1.3rem; background: #dbdbdb; border-radius: 50%; } .timeline .media:first-child:before { top: 0.3rem; } .timeline .media:last-child:after { top: calc(1.3rem + 9px); width: 9px; bottom: 0; background: #fff; } .timeline .media:first-child:last-child:after { top: calc(0.3rem + 9px); } .article .article-meta { margin-bottom: 0.5rem !important; } .article .content { font-size: 1.1rem; } .article .content blockquote.pullquote { float: right; max-width: 50%; font-size: 1.15rem; position: relative; } .rtl { direction: rtl; } .rtl .level .level-item:not(:last-child), .rtl .level.is-mobile .level-item:not(:last-child) { margin-left: 0.75rem; margin-right: 0; } .donate { position: relative; } .donate .qrcode { display: none; position: absolute; z-index: 99; bottom: 2.5em; line-height: 0; overflow: hidden; border-radius: 4px; box-shadow: 0 4px 10px rgba(0,0,0,0.1), 0 0 1px rgba(0,0,0,0.2); overflow: hidden; } .donate .qrcode img { max-width: 280px; } .donate:hover .qrcode { display: block; } .donate:first-child:not(:last-child) .qrcode { left: -0.75rem; } .donate:last-child:not(:first-child) .qrcode { right: -0.75rem; } @media screen and (max-width: 768px) { #toc { display: none; position: fixed; margin: 1rem; left: 0; right: 0; bottom: 0; z-index: 100; max-height: calc(100vh - 2rem); overflow-y: auto; } #toc-mask { display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; z-index: 99; background: rgba(0,0,0,0.7); } #toc.is-active, #toc-mask.is-active { display: block; } } /* --------------------------------- * Custom modifiers * --------------------------------- */ .is-borderless { border: none; } .is-size-7 { font-size: 0.85rem !important; } .is-7by1 { padding-top: 42.8%; } .is-7by1 img { bottom: 0; left: 0; position: absolute; right: 0; top: 0; } .is-overflow-x-auto { overflow-x: auto !important; } .is-flex-grow { flex-grow: 1 !important; } .is-flex-wrap { flex-wrap: wrap !important; } .is-flex-start { justify-content: start !important; } .is-flex-center { justify-content: center !important; } .is-flex-middle { align-items: center !important; } .has-order-1 { order: 1; } .has-order-2 { order: 2; } .has-order-3 { order: 3; } .has-mr-6 { margin-right: 0.5em !important; } .has-mb-6 { margin-bottom: 0.5em !important; } .has-mr-7 { margin-right: 0.25em !important; } .has-link-grey, .has-link-black-ter { transition: 0.2s ease; } .has-link-grey:hover, .has-link-black-ter:hover { color: #3273dc !important; } .has-link-grey { color: #7a7a7a !important; } .has-link-black-ter { color: #242424 !important; } @media screen and (max-width: 768px) { .has-text-centered-mobile { text-align: center !important; } .is-flex-center-mobile { justify-content: center !important; } .has-mt-5-mobile { margin-top: 1em !important; } } /* --------------------------------- * Font icon fixes * --------------------------------- */ .fa, .fab, .fal, .far, .fas { line-height: inherit; } /* --------------------------------- * Fix content elements * --------------------------------- */ .content h1, .content h2, .content h3, .content h4, .content h5, .content h6 { font-weight: 400; } .content h1 { font-size: 1.75em; } .content h2 { font-size: 1.5em; } .content h3 { font-size: 1.25em; } .content h4 { font-size: 1.125em; } .content h5 { font-size: 1em; } .content code, .content pre { font-size: 0.85em; font-family: \"Source Code Pro\", monospace, \"Microsoft YaHei\"; } .content code { color: #ff3860; background: transparent; padding: 0; } .content blockquote footer strong + cite { margin-left: 0.5em; } /* --------------------------------- * Fix code highlight * --------------------------------- */ figure.highlight { padding: 0; width: 100%; position: relative; margin: 1em 0 1em !important; } figure.highlight pre, figure.highlight table tr:hover { color: inherit; background: transparent; } figure.highlight table { width: auto; } figure.highlight pre { padding: 0; overflow: visible; } figure.highlight pre .line { line-height: 1.5rem; } figure.highlight figcaption, figure.highlight .gutter { background: rgba(200,200,200,0.15); } figure.highlight figcaption { padding: 0.3em 0.75em; text-align: left; font-style: normal; font-size: 0.8em; } figure.highlight figcaption span { font-weight: 500; font-family: \"Source Code Pro\", monospace, \"Microsoft YaHei\"; } figure.highlight figcaption a { float: right; color: #9a9a9a; } figure.highlight .gutter { text-align: right; } figure.highlight .tag, figure.highlight .title, figure.highlight .number, figure.highlight .section { display: inherit; font: inherit; margin: inherit; padding: inherit; background: inherit; height: inherit; text-align: inherit; vertical-align: inherit; min-width: inherit; border-radius: inherit; } figure.highlight .copy { display: none; position: absolute; bottom: 0; right: 0; color: #fff; background: rgba(0,0,0,0.5); } figure.highlight:hover .copy { display: block; } /* --------------------------------- * Fix Video * --------------------------------- */ .video-container { position: relative; padding-bottom: 56.25%; padding-top: 25px; height: 0; } .video-container iframe { position: absolute; top: 0; left: 0; width: 100%; height: 100%; } /* --------------------------------- * Fix Gist Snippet * --------------------------------- */ .gist table tr:hover { background: transparent; } .gist table td { border: none; } .gist .file { all: initial; }"},{"title":"","date":"2019-05-07T09:18:08.856Z","updated":"2019-05-07T09:18:08.856Z","comments":true,"path":"js/main.js","permalink":"https://jimmywei01.github.io/js/main.js","excerpt":"","text":"(function($){ $('.article img:not(\".not-gallery-item\")').each(function () { // wrap images with link and add caption if possible if ($(this).parent('a').length === 0) { $(this).wrap(''); if (this.alt) { $(this).after('' + this.alt + ''); } } }); if (typeof(moment) === 'function') { $('.article-meta time').each(function () { $(this).text(moment($(this).attr('datetime')).fromNow()); }); } function adjustNavbar() { const navbarWidth = $('.navbar-main .navbar-start').outerWidth() + $('.navbar-main .navbar-end').outerWidth(); if ($(document).outerWidth() < navbarWidth) { $('.navbar-main .navbar-menu').addClass('is-flex-start'); } else { $('.navbar-main .navbar-menu').removeClass('is-flex-start'); } } adjustNavbar(); $(window).resize(adjustNavbar); var $toc = $('#toc'); if ($toc.length > 0) { var $mask = $(''); $mask.attr('id', 'toc-mask'); $('body').append($mask); function toggleToc() { $toc.toggleClass('is-active'); $mask.toggleClass('is-active'); } $toc.on('click', toggleToc); $mask.on('click', toggleToc); $('.navbar-main .catalogue').on('click', toggleToc); } })(jQuery);"},{"title":"","date":"2019-05-07T09:18:08.763Z","updated":"2019-05-07T09:18:08.762Z","comments":true,"path":"js/clipboard.js","permalink":"https://jimmywei01.github.io/js/clipboard.js","excerpt":"","text":"document.addEventListener('DOMContentLoaded', function () { if (typeof(ClipboardJS) !== 'undefined') { $('figure.highlight').each(function () { var id = 'code-' + Date.now() + (Math.random() * 1000 | 0); $(this).attr('id', id); $(this).prepend($(``)); }); new ClipboardJS('.highlight .copy'); } });"},{"title":"","date":"2019-05-07T09:18:08.772Z","updated":"2019-05-07T09:18:08.771Z","comments":true,"path":"js/gallery.js","permalink":"https://jimmywei01.github.io/js/gallery.js","excerpt":"","text":"document.addEventListener('DOMContentLoaded', function () { if (typeof ($.fn.lightGallery) === 'function') { $('.article').lightGallery({ selector: '.gallery-item' }); } if (typeof ($.fn.justifiedGallery) === 'function') { $('.justified-gallery').justifiedGallery(); } });"},{"title":"","date":"2019-05-07T09:18:08.818Z","updated":"2019-05-07T09:18:08.773Z","comments":true,"path":"js/insight.js","permalink":"https://jimmywei01.github.io/js/insight.js","excerpt":"","text":"/** * Insight search plugin * @author PPOffice { @link https://github.com/ppoffice } */ (function ($, CONFIG) { var $main = $('.ins-search'); var $input = $main.find('.ins-search-input'); var $wrapper = $main.find('.ins-section-wrapper'); var $container = $main.find('.ins-section-container'); $main.parent().remove('.ins-search'); $('body').append($main); function section (title) { return $('').addClass('ins-section') .append($('').addClass('ins-section-header').text(title)); } function searchItem (icon, title, slug, preview, url) { return $('').addClass('ins-selectable').addClass('ins-search-item') .append($('').append($('').addClass('fa').addClass('fa-' + icon)) .append($('').addClass('ins-title').text(title != null && title !== '' ? title : CONFIG.TRANSLATION['UNTITLED'])) .append(slug ? $('').addClass('ins-slug').text(slug) : null)) .append(preview ? $('').addClass('ins-search-preview').text(preview) : null) .attr('data-url', url); } function sectionFactory (type, array) { var sectionTitle; var $searchItems; if (array.length === 0) return null; sectionTitle = CONFIG.TRANSLATION[type]; switch (type) { case 'POSTS': case 'PAGES': $searchItems = array.map(function (item) { // Use config.root instead of permalink to fix url issue return searchItem('file', item.title, null, item.text.slice(0, 150), item.link); }); break; case 'CATEGORIES': case 'TAGS': $searchItems = array.map(function (item) { return searchItem(type === 'CATEGORIES' ? 'folder' : 'tag', item.name, item.slug, null, item.link); }); break; default: return null; } return section(sectionTitle).append($searchItems); } function parseKeywords (keywords) { return keywords.split(' ').filter(function (keyword) { return !!keyword; }).map(function (keyword) { return keyword.toUpperCase(); }); } /** * Judge if a given post/page/category/tag contains all of the keywords. * @param Object obj Object to be weighted * @param Array fields Object's fields to find matches */ function filter (keywords, obj, fields) { var keywordArray = parseKeywords(keywords); var containKeywords = keywordArray.filter(function (keyword) { var containFields = fields.filter(function (field) { if (!obj.hasOwnProperty(field)) return false; if (obj[field].toUpperCase().indexOf(keyword) > -1) return true; }); if (containFields.length > 0) return true; return false; }); return containKeywords.length === keywordArray.length; } function filterFactory (keywords) { return { POST: function (obj) { return filter(keywords, obj, ['title', 'text']); }, PAGE: function (obj) { return filter(keywords, obj, ['title', 'text']); }, CATEGORY: function (obj) { return filter(keywords, obj, ['name', 'slug']); }, TAG: function (obj) { return filter(keywords, obj, ['name', 'slug']); } }; } /** * Calculate the weight of a matched post/page/category/tag. * @param Object obj Object to be weighted * @param Array fields Object's fields to find matches * @param Array weights Weight of every field */ function weight (keywords, obj, fields, weights) { var value = 0; parseKeywords(keywords).forEach(function (keyword) { var pattern = new RegExp(keyword, 'img'); // Global, Multi-line, Case-insensitive fields.forEach(function (field, index) { if (obj.hasOwnProperty(field)) { var matches = obj[field].match(pattern); value += matches ? matches.length * weights[index] : 0; } }); }); return value; } function weightFactory (keywords) { return { POST: function (obj) { return weight(keywords, obj, ['title', 'text'], [3, 1]); }, PAGE: function (obj) { return weight(keywords, obj, ['title', 'text'], [3, 1]); }, CATEGORY: function (obj) { return weight(keywords, obj, ['name', 'slug'], [1, 1]); }, TAG: function (obj) { return weight(keywords, obj, ['name', 'slug'], [1, 1]); } }; } function search (json, keywords) { var WEIGHTS = weightFactory(keywords); var FILTERS = filterFactory(keywords); var posts = json.posts; var pages = json.pages; var tags = json.tags; var categories = json.categories; return { posts: posts.filter(FILTERS.POST).sort(function (a, b) { return WEIGHTS.POST(b) - WEIGHTS.POST(a); }).slice(0, 5), pages: pages.filter(FILTERS.PAGE).sort(function (a, b) { return WEIGHTS.PAGE(b) - WEIGHTS.PAGE(a); }).slice(0, 5), categories: categories.filter(FILTERS.CATEGORY).sort(function (a, b) { return WEIGHTS.CATEGORY(b) - WEIGHTS.CATEGORY(a); }).slice(0, 5), tags: tags.filter(FILTERS.TAG).sort(function (a, b) { return WEIGHTS.TAG(b) - WEIGHTS.TAG(a); }).slice(0, 5) }; } function searchResultToDOM (searchResult) { $container.empty(); for (var key in searchResult) { $container.append(sectionFactory(key.toUpperCase(), searchResult[key])); } } function scrollTo ($item) { if ($item.length === 0) return; var wrapperHeight = $wrapper[0].clientHeight; var itemTop = $item.position().top - $wrapper.scrollTop(); var itemBottom = $item[0].clientHeight + $item.position().top; if (itemBottom > wrapperHeight + $wrapper.scrollTop()) { $wrapper.scrollTop(itemBottom - $wrapper[0].clientHeight); } if (itemTop < 0) { $wrapper.scrollTop($item.position().top); } } function selectItemByDiff (value) { var $items = $.makeArray($container.find('.ins-selectable')); var prevPosition = -1; $items.forEach(function (item, index) { if ($(item).hasClass('active')) { prevPosition = index; return; } }); var nextPosition = ($items.length + prevPosition + value) % $items.length; $($items[prevPosition]).removeClass('active'); $($items[nextPosition]).addClass('active'); scrollTo($($items[nextPosition])); } function gotoLink ($item) { if ($item && $item.length) { location.href = $item.attr('data-url'); } } $.getJSON(CONFIG.CONTENT_URL, function (json) { if (location.hash.trim() === '#ins-search') { $main.addClass('show'); } $input.on('input', function () { var keywords = $(this).val(); searchResultToDOM(search(json, keywords)); }); $input.trigger('input'); }); var touch = false; $(document).on('click focus', '.navbar-main .search', function () { $main.addClass('show'); $main.find('.ins-search-input').focus(); }).on('click touchend', '.ins-search-item', function (e) { if (e.type !== 'click' && !touch) { return; } gotoLink($(this)); touch = false; }).on('click touchend', '.ins-close', function (e) { if (e.type !== 'click' && !touch) { return; } $('.navbar-main').css('pointer-events', 'none'); setTimeout(function(){ $('.navbar-main').css('pointer-events', 'auto'); }, 400); $main.removeClass('show'); touch = false; }).on('keydown', function (e) { if (!$main.hasClass('show')) return; switch (e.keyCode) { case 27: // ESC $main.removeClass('show'); break; case 38: // UP selectItemByDiff(-1); break; case 40: // DOWN selectItemByDiff(1); break; case 13: //ENTER gotoLink($container.find('.ins-selectable.active').eq(0)); break; } }).on('touchstart', function (e) { touch = true; }).on('touchmove', function (e) { touch = false; }); })(jQuery, window.INSIGHT_CONFIG);"}],"posts":[{"title":"JS 紀錄3 - event、iterator","slug":"JS-紀錄3-event、iterator","date":"2019-05-29T14:56:50.000Z","updated":"2019-05-29T15:01:52.428Z","comments":true,"path":"2019/05/29/JS-紀錄3-event、iterator/","link":"","permalink":"https://jimmywei01.github.io/2019/05/29/JS-紀錄3-event、iterator/","excerpt":"JavaScript event、iterator 紀錄","text":"JavaScript event、iterator 紀錄","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jimmywei01.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jimmywei01.github.io/tags/JavaScript/"}]},{"title":"JS 紀錄2 - 包裹物件、自動轉型","slug":"JS-紀錄2-包裹物件、自動轉型","date":"2019-05-28T14:06:30.000Z","updated":"2019-05-29T14:59:22.083Z","comments":true,"path":"2019/05/28/JS-紀錄2-包裹物件、自動轉型/","link":"","permalink":"https://jimmywei01.github.io/2019/05/28/JS-紀錄2-包裹物件、自動轉型/","excerpt":"JavaScript 轉型觀念紀錄","text":"JavaScript 轉型觀念紀錄 原始型別(Primitive Type) - 不允許自由擴增屬性 但卻有屬性 &amp; 方法可以使用，因為有原始型別包裹物件 (primititve type wrapper type) ＆ 父元素的關係 null, undefined 沒有原始型別包裹物件 string, number, boolean 物件型別(Object Type) - 可以自由擴增屬性 原始型別包裹物件 (primititve type wrapper type) 主要用途 透過包裹物件的 toPrimitive 中的 valueOf() ＆ toString() 將原始型別產生物件型別的特性，自由擴增屬性與方法 toPrimitive toPrimitive(input [, PreferredType]) input 代入的值 PreferredType 會依照設定的首選的類型，決定要先後呼叫 valueOf 與 toString 的順序 valueOf() 取得物件內部的原始型別的值 (Primitive Value) toString() 取得物件內部的原始型別的值 (Primitive Value) 並轉換成字串型別 沒有提供這個值也就是預設情況，則會設定轉換的 hint 值為 “default” 轉換方式 如果 input 是原始資料類型，則直接回傳 input PreferredType 為 Number 首選類型時，優先使用 valueOf，然後再呼叫 toString PreferredType 為 String 首選類型時，優先使用 toString，然後再呼叫 valueOf 預設呼叫方式則是先呼叫 valueOf 再呼叫 toString，否則，拋出TypeError錯誤 兩個例外，一個是 Date 物件預設首選類型是字串(String)，另一是 Symbol物件，它們覆蓋了原來的 PreferredType 行為 簡略規則 undefined -&gt; undefined（基本型別值，不轉換） null -&gt; null（基本型別值，不轉換） boolean -&gt; boolean（基本型別值，不轉換） number -&gt; number（基本型別值，不轉換） string -&gt; string（基本型別值，不轉換） object：使用 [[DefaultValue]] 內部方法，依照傳入的參數決定要使用 toString 或 valueOf 取得原始型別值 Date 首選類型為 String，它優先使用 toString 來進行轉換，最後字串連接運算 11 + (new Date()) // &quot;1Sun Nov 27 2016 01:09:03 GMT+0800 (CST)&quot; Date 物件中的 valueOf 回傳值，需要使用一元加號(+)，來強制轉換它為數字類 1+new Date() // 1480180751492 Object valueOf() 回傳值: 物件本身 toString() 回傳值: “[object Object]” 字串值，不同的內建物件的回傳值是 “[object type]”字串，”type” 指的是物件本身的類型識別 123var a = &#123;age:20&#125;a.valueOf() // &#123;age: 20&#125;a.toString() // &quot;[object Object]&quot; Array valueOf() 回傳值: 物件本身 toString() 回傳值: 相當於用陣列值呼叫 join(‘,’) 所回傳的字串,也就是 [1,2,3].toString() 會是 “1,2,3”，這點要特別注意 123var b = [&apos;hot&apos;,&apos;cold’]b.valueOf() // [&quot;hot&quot;, &quot;cold”]b.toString() // &quot;hot,cold&quot; Function valueOf() 回傳值: 物件本身 toString () 回傳值: 函式中包含的程式碼轉為字串值 1234567891011121314function Person (name,age)&#123; this.name = name this.age = age &#125;var p1 = new Person1(&apos;Jim&apos;,20)Person.prototype.valueOf = function () &#123; return this.age;&#125;;Person.prototype.toString = function () &#123; return this.name;&#125;;p1.valueOf() // 20p1.toString() // &quot;Jim&quot; 轉型過程的抽象值運算 toPrimitive 賦予 String, Number, Boolean 有 valueOf() ＆ toString() 方法 JSON.stringify JSON 的字串化 無法轉為 JSON 字串的非法值有 undefined、function、symbol、具有循環參考（circular reference）的物件 1234JSON.stringify(42) // &quot;42&quot;JSON.stringify(true) // &quot;true&quot;JSON.stringify(null) // &quot;null&quot;JSON.stringify(&apos;Hello World&apos;) // &quot;&quot;Hello World&quot;&quot;，字串會在外面再包一層引號 String 任何非字串的值被強制轉型為字串 1234String([1,2,3]) // “1,2,3&quot;String([&#123;&#125;]) // &quot;[object Object]”String(false) // “false&quot;String(0) // &quot;0&quot; Number 將非數字值當成數字來操作 1234567Number(undefined) // NaNNumber(null) // 0Number(true) // 1Number(false) // 0Number(&apos;12345&apos;) // 12345Number(&apos;Hello World&apos;) // NaNNumber(&#123; name: &apos;Jack&apos; &#125;&#125;) // NaN Boolean Truthy 與 Falsy 的概念 1234Boolean(false) // falseBoolean(&apos;1’) // trueBoolean([]) // trueBoolean(&#123;&#125;) // true 自動轉型 物件型別來比較原始型別，所有的物件型別物件，一定會透過 toPrimitive 裡面的 valueOf() 或 toString() 先轉成原始型別物件，然後才進行比較，這就是「自動型別轉換」 強制轉型（coercion）分為兩種「明確的」強制轉型 (explicit coercion) 程式碼中刻意寫出來的型別轉換的動作123456789String(123) // &quot;123&quot;(123).toString() // &quot;123&quot;Number(&apos;123&apos;) // 123+(&apos;123’) // 123-(&apos;-123&apos;) // 123String(123) // “123&quot;Math.floor(-29.8) // -30~~-29.8 // -29-29.8 | 0 // -29 「隱含的」強制轉型 (implicit coercion) 程式碼中沒有明確指出要轉換型別卻轉型的123456&quot;0&quot; == false; // true，字串轉數字、布林再轉數字false == 0; // true，布林轉數字false == “”; // true，字串轉數字、布林再轉數字false == []; // true，布林轉數字、陣列取 toString 得到空字串再轉數字false == &#123;&#125;; // false，布林轉數字、物件取 valueOf 得到空物件&quot;&quot; == 0; // true，字串轉數字 + 運算子是數字的相加，還是字串的串接？ 兩運算元的型別不同，當其中一方是字串時，+ 所代表的就是字串運算子，而會將另外一個運算元強制轉型為字串，並連接兩個字串 [] + {} 中，[] 會轉為空字串，而 {} 會轉為字串 “[object Object]” {} + [] 中，{} 被當成空區塊而無作用， +[] 被當成強制轉型為數字 Number([]) （由於陣列是物件，中間會先使用 toString 轉成字空串，導致變成 Number(‘’)）而得到 0 12345678910111213const a = &apos;1&apos;;const b = 1;const c = [1, 2];const d = [3, 4];a + 1 // &quot;11&quot;b + 1 // 2b + &apos;&apos; // &quot;1&quot;c + d // “1,23,4&quot;[] + &#123;&#125; // &quot;[object Object]&quot;&#123;&#125; + [] // 0-&gt; [].toString() // “” 在什麼狀況下會隱含地將值強制轉為布林呢？ if 述句中的條件判斷 for 述句中的條件判斷，意即測試運算式的第二個子句 while 與 do…while 中檢測條件是否成立的測試運算式 三元運算式 條件 ? 值1 : 值2 中的條件運算，意即測試運算式的第一個子句 邏輯運算子的 ||（or) 和 &amp;&amp;（and）左手邊的運算元會被當成測試運算式 12345678910111213141516171819var a = 12345;var b = &apos;Hello World&apos;;var c; // undefinedvar d = null;if (a) &#123; // true console.log(&apos;a 是真的&apos;); // a 是真的&#125;while (c) &#123; // false console.log(&apos;從來沒跑過&apos;);&#125;c = d ? a : b;console.log(c) // &quot;Hello World&quot;if ((a &amp;&amp; d) || c) &#123; // true console.log(&apos;結果是真的&apos;); // 結果是真的&#125; 比較運算 大家都知道 兩個等號 ( == ) 比對兩邊物件時，JavaScript 會自動轉型，然後才進行比對 怎麼自動轉型？ 它是透過 toPrimitive 的 valueOf() 或 toString() 轉換 除此之外，可以自訂 valueOf() 或 toString() 所以結果 當 JavaScript 任意物件在進行 比較運算 時，都會先執行 valueOf() 或 toString() ，取回該物件相對應原始型別的值，看當下兩邊比較的是甚麼原始型別，然後再進行比較 若有任一值轉型後的結果不是字串，就使用 Number 的規則轉為數字，來做數字上的比較 種類相等比較 可分為 ==（寬鬆相等）、===（嚴格相等）、!=（寬鬆不相等）、!==（嚴格不相等），主要差異是在做值的比較時是否會做強制轉型 == 和 === 其實都會做型別的檢查，只是當面對型別不同時的反應是不一樣 12345const a = &apos;100&apos;;const b = 100;a == b // true，強制轉型，將字串 &apos;100&apos; 轉為數字 100a === b // false 簡略規則 型別相同，就會以同一型做比較，但要注意 NaN 不等於自己（其實，NaN 不大於、不小於也不等於任何數字，所以當然也不等於它自己） +0、-0 彼此相等 物件（含 function 和 array）的相等是比較參考（reference），若參考相等才是相等 型別不同，將其中一個或兩個值先做強制轉型，再用型別相同的做比較 字串轉為數字 布林轉為數字 null 與 undefined 在寬鬆相等下會強制轉型為彼此，因此是相等的但不等於其他值， 若比較的對象是物件，使用 valueOf()（優先）或 toString() 將物件取得基本型別的值，再做比較 而 != 和 !== 就是先分別做 == 和 === 再取否定（!） 123456789101112131415161718192021222324252627282930null === undefined // falsenull == undefined // true// 在 a == b 當中，字串 a 優先轉為數字後，此時就可比較 123 == 123，因此是相等的（true）const a = &apos;123&apos;;const b = 123;a === b // falsea == b // true// 在 a == b 當中，布林 a 優先轉為數字（Numer(true) 得到 1）後，此時就可比較 1 == 123，因此是不相等的（false）const a = true;const b = 123;a === b // falsea == b // false// 在 a == b 當中其實比較的是 null == 123，因此是不相等的（false）const a = null;const b = 123;a === b // falsea == b // false//在 a == b 當中，陣列 a 由於沒有 valueOf()，只好使用 toString() 取得其基型值而得到字串 &apos;1,2,3&apos;，此時就可比較 &apos;1,2,3&apos; == &apos;1,2,3&apos;，因此是相等的（true）const a = [1,2,3];const b = &apos;1,2,3&apos;;a === b // falsea == b // true 大小比較 &lt;（小於）、 &gt;（大於）、&lt;=（小於等於）、&gt;=（大於等於） 例如：a &gt; b 表示比較 a 是否大於 b 簡略規則 若兩個運算元皆為字串時，就直接依照字典字母順序做比較 注意 由於規格只定義了 a &lt; b 的演算法，因此 a &gt; b 會以 b &lt; a 的方式做比較 由於沒有「嚴格關係比較」(===)，所以一定會遇到強制轉型的狀況 123456789101112131415161718// 由於 a 和 b 都不是字串且陣列沒有 valueOf，因此先用 toString 取得基型值，得到 a 為 &apos;12&apos;、b 為 &apos;13&apos;，型別都是字串，接著做字母順序的比較const a = [12];const b = [&apos;13&apos;];a &lt; b // true，&apos;12&apos; &lt; &apos;13&apos;a &gt; b // false，其實是比較 b &lt; a，即 &apos;13&apos; &lt; ’12&apos;// 先用 valueOf 取得基型值（只取到原來的物件），再用 toString 而得到兩個字串 [object Object]，因此比較 [object Object] 與 [object Object]// a == b 比較的是兩物件存值的所在的記憶體位置，也就是參考（reference）const a = &#123; b: 12 &#125;;const b = &#123; b: 13 &#125;;a &lt; b // false，&apos;[object Object]&apos; &lt; &apos;[object Object]&apos;a &gt; b // false，其實是比較 b &lt; a，即 &apos;[object Object]&apos; &lt; &apos;[object Object]&apos;a == b // false，其實是比較兩物件的 referencea &gt;= b // truea &lt;= b // true 例外 null 與 undefined 沒有其物件包裹形式，因此 Object(null) 與 Object(undefiend) 等同於 Object()，也就是空物件 {} Number(NaN) 得到 NaN，且 NaN 不等於自己 1234567891011var a = null;var b = Object(a); // 等同於 Object()a == b; // falsevar c = undefined;var d = Object(c); // 等同於 Object()c == d; // falsevar e = NaN;var f = Object(e); // 等同於 new Number(e)e == f; object 在 JavaScript 裡，所有的物件都是不相等的，每一個都是獨立的物件實體，即便實作了 valueOf 或 toString 方法，還是無法對使用者定義物件進行任何相等比較運算 任何兩個物件相比都是 false 12345&#123;&#125; = &#123;&#125; // &#123;&#125;&#123;&#125; == &#123;&#125; // false&#123;&#125; === &#123;&#125; // false 兩個相同物件比較都是 true 12345678let a = &#123;&#125;a.name = &#123;&#125;let b = &#123;&#125;b.name = &#123;&#125;a == b // falsea === b // true 運算子 || (or) 與 &amp;&amp; (and) 在兩個運算元當中「選擇」其中一個運算元的值作為結果 簡略規則 ||（or） 和 &amp;&amp;（and）會將第一個運算元做布林測試或強制轉型為布林以便測試 對 ||（or）來說，若結果為 true，則取第一個運算元為結果；若結果為 false，則取第二個運算元為結果 對 &amp;&amp;（and）來說，若結果為 true，則取第二個運算元為結果；若結果為 false，則取第一個運算元為結果 可應用於 ||（or） 可用來設定變數的初始值 &amp;&amp;（and）可用來執行「若特定條件成立，才做某件事情」，功能近似 if 述句 12345678910111213141516const a = &apos;Hello World!&apos;const b = 777;const c = null;a &amp;&amp; c // 測試 a 為 true，選 c，結果是 nulla &amp;&amp; b // 測試 a 為 true，選 b，結果是 777undefined &amp;&amp; b // 測試 undefined 為 false，選 undefined，結果是 undefineda || b // 測試 a 為 true，選 a，結果是 &quot;Hello World!&quot;c || &apos;foo&apos; // 測試 c 為 false，選 &apos;foo&apos;，結果是 &quot;foo&quot;const flag = true;function foo() &#123; console.log(&apos;try me&apos;);&#125;flag &amp;&amp; foo(); // try me Symbol 強制轉型 屬性名現在可以有兩種類型，一種是原來就有的字串，另一種就是新增的 Symbol 類型 凡是屬性名屬於 Symbol 類型，可以保證不會與其他屬性名產生衝突 123let a = 33let a2 = Symbol(33)console.log(a===a2) // false 簡略規則 在轉為 string 方面，將 Symbol 明確的強制轉型是允許的，但隱含的強制轉型是被禁止的，並且會丟出錯誤訊息 12345var s1 = Symbol(&apos;Hello World&apos;);console.log(String(s1)); // &quot;Symbol(Hello World)&quot;var s2 = Symbol(&apos; World Hello&apos;);console.log(s2 + &apos;&apos;); // TypeError: Cannot convert a Symbol value to a string 在轉為 number 方面，無論是明確或隱含都是禁止的，並且會丟出錯誤訊息 12345const n1 = Symbol(777);console.log(Number(s1)); // TypeError: Cannot convert a Symbol value to a numberconst n2 = Symbol(999);console.log(+n2); // TypeError: Cannot convert a Symbol value to a number 在轉為 boolean 方面，無論是明確或隱含都是可以的，並且結果都是 true 123456789101112131415const b1 = Symbol(true);const b2 = Symbol(false);Boolean(b1); // trueBoolean(b2); // trueconst b3 = Symbol(true);const b4 = Symbol(false);if (b3) &#123; console.log(&apos;b3 是真的&apos;); // b3 是真的&#125;if (b4) &#123; console.log(&apos;b4 是真的&apos;); // b4 是真的&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jimmywei01.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jimmywei01.github.io/tags/JavaScript/"}]},{"title":"JS 紀錄1 - 物件、變數、型別","slug":"JS-紀錄1-物件、變數、型別","date":"2019-05-27T05:57:39.000Z","updated":"2019-05-27T12:19:48.128Z","comments":true,"path":"2019/05/27/JS-紀錄1-物件、變數、型別/","link":"","permalink":"https://jimmywei01.github.io/2019/05/27/JS-紀錄1-物件、變數、型別/","excerpt":"JavaScript 基本觀念紀錄","text":"JavaScript 基本觀念紀錄 執行時期 - 在準備資料開發時期 - 開始實作 JavaScript 物件 可以指派給一個 變數 並會在執行時期擁有 型別 物件(Object) 這裡的物件代表存在於記憶體中的資料 僅存於執行時期 變數(Variable) 記憶體指標特性（可以指向任何資料) 只能在開發時期宣告 var , let , const 在執行時期只會用來儲存物件的記憶體位置 型別(Type) 僅存於執行時期，並用來標示物件的種類(類型) 不同型別之間可能會有不同的屬性與方法 12345678var a a = 1a = ‘a’a = ‘a’+ a // 1個變數 var a// 3個型別 undefind,number,string// 5個記憶體物件 JavaScript 都是物件 number string boolean null - (此變數可能曾經有值，可能沒有值) 現在沒有值 undefind - 此變數還沒有給值，所以不知道是什麼 symbol array object regexp 變數建立方式先建立物件 在建立型別，型別 用來標示物件的種類 1var a = “5” a = 變數 , 5 = 物件 , “” = (字串)型別 1a.name = “jimmy&quot; a = 變數物件 , name = 屬性 , jimmy = 物件 , “” = (字串)型別 屬性1a.name = &#123;&#125; 可以被刪除 內含記憶體指標特性（可以指向任何資料） 任何一個 JavaScript 只有屬性 變數(也可能是屬性)1let a = &#123;&#125; 絕對無法刪除（除非去 prototye 刪除父連結） 內含記憶體指標特性（可以指向任何資料） 沒有型別 在記憶體裡指向別人 var , let , const 進行宣告 宣告變數 var let const 作用域 Function scope Block scope Block scope 注意事項 盡量不用 var，會汙染 window(全域變數) 造成一堆變數在 window var 宣告過的變數，不能再使用 let 宣告一次 宣告一個唯讀的變數 (變數無法再指向其他物件) hosting undefined is not defined is not defined 注意事項 var 污染全域(window) 12345678910111213141516var a = 1window[‘a’] = 2delete window.a // false 是變數也是屬性console.log(a) // 2// var 宣告更改屬性值(index)var a = ‘well’ // ‘well&apos;a[0] // ‘w&apos;a[0] = ‘j’ // ‘j&apos;a[0] // ‘w’a // ‘well’delete a // falsewindow.a // ‘well’ 污染全域(window)window.a = &apos;jj&apos; // ‘jj’ window 可重新賦值a[0] // ‘j&apos;delete window.a // false 是變數也是屬性 let 不會污染全域(window) 12345678910111213141516var a = 1window[‘a’] = 2delete window.a // false 是變數也是屬性console.log(a) // 2// 改用 let 宣告不會污染全域(window)let a = ‘jimmy’ // ‘jimmy’a[0] // ‘j’a[0] = ‘m’ // ‘m’a[0] // ‘j&apos;a // ‘jimmy’delete a // falsewindow.a // undefined 不會污染全域(window)window.a= ‘mm’ // ‘mm’ window.a[0] // ‘m’delete window.a // false hosting 當 function 與變數/常數同名稱而提升時，function 的優先程度高於變數/常數 12345678a()function a()&#123; console.log(&apos;hello&apos;);&#125;// 優先 hostingfunction a()&#123; console.log(&apos;he’); // he&#125; var undefind 12console.log (myVar) // undefined var myVar = 2 let TDZ 程式碼中某個部份變數的參考動作還不能執行，這是因為該變數尚未被初始化 12console.log (myVar) // ReferenceError: myVar is not definedlet myVar = 2 ; const TDZ 12console.log (myVar) // ReferenceError: myVar is not definedconst myVar = 2 ; 變數指派差異 var 一般變數下 可以重新修改變數值 可以重新宣告變數 在 object 和 array 下 可以重新修改 object 和 array 的變數值 可以重新宣告 object 和 array 變數 12345678910111213141516171819202122var myVar = 2 ;myVar = 6console.log(myVar) // 6var myVar = 3console.log(myVar) // 3// arrayvar son = [&apos;John&apos;]son.push(&apos;jimmy’)console.log(son) // [&quot;john&quot;, &quot;jimmy”]son =‘marry&apos;console.log(son) // marry// objectlet q = &#123;r:0&#125;q.r = 3console.log(q) // 3let q = &#123;f:0&#125;console.log(q.f) // 0 let 一般變數下 可以重新修改變數值 不能重新宣告變數 在 object 和 array 下 可以重新修改 object 和 array 的變數值 不能重新宣告 object 和 array 變數 12345678910111213141516171819202122let myVar = 2 ;myVar = 6console.log(myVar) // 6let myVar = 3 ; console.log(myVar) // SyntaxError: Identifier &apos;myVar&apos; has already been declared// arraylet q = &#123;r:0&#125;q.r = 3console.log(q.r) // 3let q = &#123;f:0&#125; console.log(q.f) // SyntaxError: Identifier &apos;q&apos; has already been declared//objectlet person = [‘John’]person.push(‘Jimmy’)console.log(person) // [‘John’,’Jimmy’]let person = [‘Peater’] console.log(person) // SyntaxError: Identifier &apos;person&apos; has already been declared const 一般變數下 不能重新修改變數值 不能重新宣告變數 在 object 和 array 下 可以重新修改 object 和 array 的變數值 不能重新宣告 object 和 array 變數 12345678910111213141516171819202122const myVar = 2 ;myVar = 6 // SyntaxError: Identifier &apos;myVar&apos; has already been declaredconst myVar = 3 ; // SyntaxError: Identifier &apos;myVar&apos; has already been declared//arrayconst person = &#123; name : &apos; Nick &apos;&#125;;person.name = &apos; John &apos; console.log ( person.name ) // &quot;John&quot; person = &quot;Sandra”//跳出錯誤，因為重新指派時是不允許使用const宣告出來的變數的console.log(person) // TypeError: Assignment to constant variable//objectconst person = [];person.push ( &apos; John &apos; ); console.log (person[ 0 ]) // &quot;John&quot; person = [ &quot; Nick &quot; ] console.log(person) // TypeError: Assignment to constant variable 型別型別分類 原始型別(Primitive Type) - 不允許自由擴增屬性 但卻有屬性 &amp; 方法可以使用，因為有原始型別包裹物件 (primititve type wrapper type) ＆ 父元素的關係 1&apos;abc&apos;.charAt === String.prototype.charAt // true 運算元 型別 Number (數值) number String (字串) string Boolean (布林) boolean Null (空值) object Undefind (未定義) undefind Symbol (符號) function 物件型別(Object Type) - 可以自由擴增屬性 運算元 型別 Array (陣列) object Object (物件) object 型別判斷typeof null 是基本型別之一，得到 object，而非 null function 是物件的子型別，但 typeof function() {} 是得到 function ，而非 object NaN 表示是無效的數字，但依舊還是數字，因此結果就是 number，而非「不是數字」(not a number) NaN 與任何數字運算都會得到 NaN，並且 NaN 不大於、不小於也不等於任何數字，包含 NaN 它自己 12345678910typeof &apos;Hello World!&apos; // &apos;string&apos;typeof true // &apos;boolean&apos;typeof 1234567 // &apos;number&apos;typeof null // &apos;object&apos;typeof undefined // &apos;undefined&apos;typeof &#123; name: &apos;Jack&apos; &#125; // &apos;object&apos;typeof Symbol() // &apos;symbol&apos;typeof function() &#123;&#125; // &apos;function&apos;typeof [1, 2, 3] // &apos;object&apos;typeof NaN // &apos;number&apos; instanceof 檢查物件是否為指定的建構子所建立的實體 用來測試一個 object 在原型鏈中是否存在一個構造函數的 prototype 屬性 涉及的構造函數 基礎類型：string、number、boolean、undefined、null、symbol 複雜類型：array，object 其他類型：function、regExp、date 語法 [對象] instanceof [構造函數]， 回傳 boloon 值 注意左側必須是對象（object），如果不是，直接返回 false 12let obj = new Object()obj instanceof Object // true 基礎類型 檢測的一定要是對象（object） 12345678910111213141516171819// 第一個不是 object，是基本類型，返回 falselet num = 1num instanceof Number // false// 第二個是封裝成 object，所以 truenum = new Number(1)num instanceof Number // true// 檢測目標的 __proto__ 與構造函數的 prototype 相同即返回 true，這是不嚴謹的let num = 1num.__proto__ === Number.prototype // truenum instanceof Number // false// 一定要封裝成 objectnum = new Number(1)num.__proto__ === Number.prototype // truenum instanceof Number // truenum.__proto__ === (new Number(1)).__proto__ // true 複雜類型 直接生成構造函數，所以不會像基本類型一樣兩種情況 1234let arr = [ ]arr instanceof Array // truearr instanceof Object // trueArray.isArray(arr) // true 其他類型 除了 function，都一樣是 object 123456789// 這裡要注意，function A() &#123;&#125;相當於 let A; A = function()&#123;&#125;// a 是 new 出來的，所以是經過構造，因此已經是對象，不再是函數，所以 falsefunction A() &#123;&#125;let a = new A()a instanceof Function // falsea instanceof Object // trueA instanceof Function // trueA instanceof Object // true 型別參數傳遞 參數傳遞 Call by reference Call by value Object String Array Number Function Boolean RegExp Null Date Undefined Math Symbol Call by value 佔用不同記憶體位置 123456let age = 100;let age2 = age;console.log(age, age2); // 100,100age = 200;console.log(age, age2); // 200,100 Call by reference 使用相同記憶體位置 記憶體「路徑位置」會被複製 1234567891011121314let superTeam = [&apos;Otree&apos;, &apos;Penguin&apos;, &apos;Frog&apos;, &apos;Jim&apos;];let fakeTeam = superTeam;console.log(fakeTeam, superTeam)// 兩個變數值相同// [&apos;Otree&apos;, &apos;Penguin&apos;, &apos;Frog&apos;, &apos;Jim’];// [&apos;Otree&apos;, &apos;Penguin&apos;, &apos;Frog&apos;, &apos;Jim&apos;];fakeTeam[3] = &apos;Chris’;console.log( fakeTeam, superTeam);// 值也跟著變了// [&apos;Otree&apos;, &apos;Penguin&apos;, &apos;Frog&apos;, ‘Chris’];// [&apos;Otree&apos;, &apos;Penguin&apos;, &apos;Frog&apos;, ‘Chris&apos;]; Call by Sharing （共享參考） 變數值被呼叫時，會直接把該變數所在的記憶體位置做為參考，傳遞給呼叫它的對象 但當對象被賦予新值時，對象會被指定一個新的記憶體位置，值也跟著變了 12345678910111213let superTeam = [&apos;Otree&apos;, &apos;Penguin&apos;, &apos;Frog&apos;, &apos;Jim&apos;];let fakeTeam = superTeam;console.log(fakeTeam, superTeam)// 兩個變數值相同// [&apos;Otree&apos;, &apos;Penguin&apos;, &apos;Frog&apos;, &apos;Jim’];// [&apos;Otree&apos;, &apos;Penguin&apos;, &apos;Frog&apos;, &apos;Jim&apos;];fakeTeam = [&apos;Otree&apos;, &apos;Penguin&apos;, &apos;Frog&apos;, &apos;Chris’];console.log( fakeTeam, superTeam);// 值也跟著變了// [&apos;Otree&apos;, &apos;Penguin&apos;, &apos;Frog&apos;, ‘Chris’];// [&apos;Otree&apos;, &apos;Penguin&apos;, &apos;Frog&apos;, &apos;Jim&apos;]; 為何會產生不同傳遞方式的錯覺？ 在 JavaScript 中所有的 Call by value 型別皆為不可變動的(Immutable) 永遠只能藉由賦予新值的方式將值傳遞給新的變數 物件物件取屬性值 “ . “ […] 可取出 number 屬性的屬性值 12345678910111213141516// 建立物件var car = &#123;// 擴增屬性 name:&apos;Tesla&apos;, star:function()&#123; return &apos;ok&apos; &#125;, &apos;001&apos;:&apos;log&apos;&#125;car.name // “Tesla&quot;car[&apos;name’] // “Tesla&quot;car.star // f()&#123;return ok&#125;car[&apos;star’] // f()&#123;return ok&#125;car.001 // Uncaught SyntaxError: Unexpected numbercar[&apos;001’] // &quot;log&quot; 物件複製 物件複製的內容，儲存在不同的記憶區塊，讓彼此不會影響 ? Object.assign(target, …sources) Shallow Copy 只能處理深度只有一層的物件，沒辦法做到真正的 Deep Copy target - 目標物件 sources - 來源目標 123456789101112131415161718192021222324252627const person = &#123; name:&#123; firstname:&apos;wei&apos;, lastname:&apos;ck&apos; &#125;, age:80&#125;// 物件裡面還有一個子物件的話,這個子物件是無法被複製const person2 = Object.assign(&#123;&#125;,person)person2.name.firstname=&apos;chi&apos;console.log(person,person2)// [object Object] &#123; age: 80, name: [object Object] &#123; firstname: “chi&quot;, lastname: &quot;ck&quot; &#125;&#125;// [object Object] &#123; age: 80, name: [object Object] &#123; firstname: &quot;chi&quot;, lastname: &quot;ck&quot; &#125;&#125; JSON.parse(JSON.stringify(obj)) Deep Copy JSON.stringify 序列化(轉成字串) JSON.parse 物件化(轉成物件) function、regExp、undefind 過不去 123456789101112131415161718192021222324252627const person = &#123; name:&#123; firstname:&apos;wei&apos;, lastname:&apos;ck&apos; &#125;, age:80&#125;// 透過 JSON 將物件序列化(轉成字串)、再物件化(轉成物件)const person3 = JSON.parse(JSON.stringify(person))person3.name.firstname = &apos;chi&apos;console.log(person,person3)// [object Object] &#123; age: 80, name: [object Object] &#123; firstname: &quot;wei&quot;, lastname: &quot;ck&quot; &#125;&#125;// [object Object] &#123; age: 80, name: [object Object] &#123; firstname: &quot;chi&quot;, lastname: &quot;ck&quot; &#125;&#125; jQuery - Deep Copy &amp; Shallow Copy extend 可以複製物件，可以將加入參數使用深度複製 (deep copy) merge object 順序會影響到結果 shallow copy jQuery.extend( target [, object1 ] [, objectN ] ) deep copy jQuery.extend( [(deep)true or false], target, object1 [, objectN ] ) 123456789101112131415161718192021222324252627282930313233var object1 = &#123; apple: 0, banana: &#123; weight: 52, price: 100 &#125;, cherry: 97&#125;;var object2 = &#123;&#125;jQuery.extend(object2, object1);console.log(object2)//[object Object] &#123; apple: 0, banana: [object Object] &#123; price: 100, weight: 52 &#125;, cherry: 97&#125;console.log(object2.banana === object1.banana) // truevar object3 = &#123;&#125;jQuery.extend(true,object3, object1);console.log(object3)// [object Object] &#123; apple: 0, banana: [object Object] &#123; price: 100, weight: 52 &#125;, cherry: 97&#125;console.log(object3.banana === object1.banana) // false 函式庫 lodash - Deep Copy &amp; Shallow Copy shallow copy _.clone() deep copy _.cloneDeep() 1234567var objects = [&#123; &apos;a&apos;: 1 &#125;, &#123; &apos;b&apos;: 2 &#125;]; var shallow = _.clone(objects);console.log(shallow[0] === objects[0]); // truevar deep = _.cloneDeep(objects);console.log(deep[0] === objects[0]); // false","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jimmywei01.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jimmywei01.github.io/tags/JavaScript/"}]},{"title":"瀏覽器兼容性紀錄 (單位、font、CSS 設定、RWD media)","slug":"瀏覽器兼容性紀錄-單位、font、CSS-設定、RWD-media","date":"2019-05-23T15:10:48.000Z","updated":"2019-05-27T05:50:35.475Z","comments":true,"path":"2019/05/23/瀏覽器兼容性紀錄-單位、font、CSS-設定、RWD-media/","link":"","permalink":"https://jimmywei01.github.io/2019/05/23/瀏覽器兼容性紀錄-單位、font、CSS-設定、RWD-media/","excerpt":"紀錄一些不同瀏覽器的做法","text":"紀錄一些不同瀏覽器的做法 目的：解決不同瀏覽器的樣式衝突 CSS Hack 就是指利用不同瀏覽器的一些特殊屬性(非W3C標準)，來對不同瀏覽器進行設定，以達到前台視覺上統一的一種小技巧 無法通過 W3C驗證， 若要使用 CSS Hack 來統一各瀏覽器之間的差異，把他當成是網頁設計時最後的手段 主要分成兩種類型 樣式屬性的密技 ( Attribute Hacks ) 選取器的密技 ( Selector Hacks ) 樣式屬性的密技 ( Attribute Hacks ) 順序性非常重要，比較晚定義的樣式會取代較早定義的樣式，必須把最多瀏覽器版本看的懂的樣式寫在比較上面，這樣才能達到 CSS Hack 的效果 123456.page &#123; color: black; /* 所有瀏覽器 */ color /**/: yellow; /* IE7, IE8, IE9 */ *color: blue; /* IE6, IE7 */ _color: red; /* IE6 */ &#125; 樣式屬性的密技 符號 example IE6 底線 ( _ ) #style { _color: red } IE6, IE7 星號 ( * ) ｜井號 ( # ) #style { *color: red } ｜#style { #color: red } IE7, IE8, IE9 空白與一個註解 ( /**/ ) #style { color /**/: red } IE6, IE7, IE8, IE9 \\9 字串 #style { color: red\\9 } IE8, IE9 \\0/ 字串 #style {color: red\\0/} 選取器的密技 ( Selector Hacks ) autoprefixer - 加入各家瀏覽器的前綴詞（prefix） -webkit- Chrome 與 Safari 正是用核心 -moz- 則是 Mozilla 公司的縮寫(Gecko核心)，代表瀏覽器為Firefox -o- 是 Opera 瀏覽器的縮寫(Presto核心) -ms- 微軟的縮寫代表瀏覽器是 IE 1234567.class&#123; -webkit-border-radius: 5px; -moz-border-radius: 5px; -ms-border-radius: 5px; -o-border-radius: 5px; border-radius: 5px;&#125; IE 條件式註解 該功能只能用於 IE9 以下的瀏覽器裡 讓 IE 根據判斷的語法，來決定要不要執行註解中的內容，而其他的瀏覽器例如(Firefox,Google Chome,Safari…)都還是一樣視為註解，來達到區分 IE 瀏覽器版本及不同瀏覽器的效果 利用 html 的註解形式，在註解中加入一些判斷的語法 1234567&lt;!doctype html&gt;&lt;!--[if lt IE 7 ]&gt; &lt;html lang=&quot;en&quot; class=“no ie6&quot;&gt; &lt;![endif]--&gt;&lt;!--[if IE 7 ]&gt; &lt;html lang=&quot;en&quot; class=&quot;no ie7&quot;&gt; &lt;![endif]--&gt;&lt;!--[if IE 8 ]&gt; &lt;html lang=&quot;en&quot; class=&quot;no ie8&quot;&gt; &lt;![endif]--&gt;&lt;!--[if IE 9 ]&gt; &lt;html lang=&quot;en&quot; class=&quot;no ie9&quot;&gt; &lt;![endif]--&gt;&lt;!--[if (gt IE 9)|!(IE)]&gt;&lt;!--&gt; &lt;html lang=&quot;en&quot; class=&quot;no&quot;&gt; &lt;!--&lt;![endif]--&gt;&lt;head&gt; 可以用來載入不同的 CSS 檔 1234&lt;!--[if lte IE 9]&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;lte-ie-9.css&quot;&gt;&lt;![endif]--&gt;&lt;!--[if lte IE 8]&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;lte-ie-8.css&quot;&gt;&lt;![endif]--&gt;&lt;!--[if lte IE 7]&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;lte-ie-7.css&quot;&gt;&lt;![endif]--&gt;&lt;!--[if lte IE 6]&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;lte-ie-6.css&quot;&gt;&lt;![endif]—&gt; 透過條件式類別名稱的技巧，CSS 內容可以寫成這樣，也可以有效避免使用 CSS Hacks 1234.style &#123; color: black; &#125; /* 所有瀏覽器 */.ie8 .style &#123; color: yellow; &#125; /* IE8 */.ie7 .style &#123; color: blue; &#125; /* IE7 */.ie6 .style &#123; color: red; &#125; /* IE6 */ 參數 說明 if 是或不是 lt less-than，版本小於，例如 [if lt IE 7] 表示版本小於 IE7，不包含 IE7 lte than or equal，版本小於或等於，例如 [if lte IE 7] 表示版本小於IE7，包含 IE7 gt greater-than，版本大於，例如 [if gt IE 7] 表示版本大於 IE7，不包含 IE7 gte greater-than or equal，版本大於或等於，例如 [if gte IE 7] 表示版本大於 IE7，包含 IE7 ! NOT，否定的意思，例如 [if !IE7] 表示不是 IE7 &amp; AND，且的意思，例如 [if (gt IE 7)&amp;(lt IE 9)]，表示要大於 IE7 且小於 IE9 ｜ OR，或的意思，例如 [if (IE 6)｜(IE 7)]，表示 IE6 或 IE7 都會符合條件 不同單位可參考 -&gt; https://codepen.io/Jimmywei01/pen/wbpeqd?editors=1100 px：絕對單位，代表螢幕中每個「點」( pixel ) 縮放螢幕的時候，不會隨著變動 多大 px 字體就會多大 123456789&lt;div class=&quot;a&quot; style=&quot;font-size:16px;&quot;&gt;16px &lt;div style=&quot;font-size:20px;&quot;&gt;20px &lt;div style=&quot;font-size:24px;&quot;&gt;24px &lt;div style=&quot;font-size:16px;&quot;&gt;16px &lt;div style=&quot;font-size:32px;&quot;&gt;32px&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; em：相對單位，每個子元素透過「倍數」乘以父元素的 px 值 每一個 div 都從它上一級父元素繼承了字體大小，並且逐漸增加 最內層是 16px x 1.2 x 1.2 x 1.2 x 1.2 x 1.2 = 39.8px 123456789&lt;div style=&quot;font-size:1.2em;&quot;&gt;1.2em &lt;div style=&quot;font-size:1.2em;&quot;&gt;1.2em &lt;div style=&quot;font-size:1.2em;&quot;&gt;1.2em &lt;div style=&quot;font-size:1.2em;&quot;&gt;1.2em &lt;div style=&quot;font-size:1.2em;&quot;&gt;1.2em&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; rem：相對單位，每個元素透過「倍數」乘以根元素的 px 值 1rem 等於根元素的字體大小 最內層是 16px x 1.2 = 19.2px rem 單位在不同螢幕比例都適用 設定在 html 元素下 font-size 的根元素 px 值當預設值 如何確認 1rem 等於多少 px？ 因為 css 是不會幫忙計算 1rem 是多少 px 的，只能通過自己來計算 計算方式： 假設情境 有一個設計稿 A（ 640*1136 px )，預設的 rem 和 px 的比例 B（ font-size 為10px 即 1rem=10px )，假設切 480px 的圖要放入 320px 總共需要多少 rem ？ 公式 clientWidth 1rem = 預設 font-size * (clientWidth / 設計稿 width) + ‘px’; clientWidth 內設計圖要切的內容尺寸 rem = 設計圖要切的內容尺寸 px / clientWidth 1rem 解 320px 1rem = 10 * ( 320 / 640 ) +’px’ = 5px 320px 內 480px 圖要切的內容尺寸 rem = 480 / 5 = 96 rem 123456789&lt;div style=&quot;font-size:1.2rem;&quot;&gt;1.2rem &lt;div style=&quot;font-size:1.2rem;&quot;&gt;1.2rem &lt;div style=&quot;font-size:1.2rem;&quot;&gt;1.2rem &lt;div style=&quot;font-size:1.2rem;&quot;&gt;1.2rem &lt;div style=&quot;font-size:1.2rem;&quot;&gt;1.2rem&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; %：相對單位，每個子元素透過「百分比」乘以父元素的 px 值 和 em 大同小異 最內層是 16px x 1.2 x 1.2 x 1.2 x 1.2 x 1.2 = 39.8px 123456789&lt;div style=&quot;font-size:120%;&quot;&gt;120% &lt;div style=&quot;font-size:120%;&quot;&gt;120% &lt;div style=&quot;font-size:120%;&quot;&gt;120% &lt;div style=&quot;font-size:120%;&quot;&gt;120% &lt;div style=&quot;font-size:120%;&quot;&gt;120%&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; vh/vm 設計自適應性網頁（RWD）時會希望圖片隨著螢幕的大小而改變，這時候我們就可以利用到這兩個新的單位 vh 代表的是 view height，也就是螢幕可視範圍高度的百分比，1vw = 視窗寬度的 1% vw 表示的是 view width，也就是螢幕可是範圍寬度的百分比，1vh = 視窗高度的 1% 1vw ＝ 1/100th viewport width 如果填的是 30vh 和 30vw，表示這個 div 要占我的可視範圍 30%，因為它會隨著網頁縮放而改變 這個方形的長度會隨著你的視窗而改變，是因為輸入的是 30% vmin | vmax vmin 意思是抓取「長或寬較小的那個的百分比」 vmax 意思是抓取「長或寬較大的那個的百分比」 font-family 先找第一種字體，若不支援或沒有該字體，則採用第二種字體，依此類推，最後使用通用字 1body&#123; font-family:第一種字體, 第二種字體, &quot;第三種字體&quot;, &quot;通用字&quot;; &#125; 引用外部字體方式 CSS link 1&lt;link href=&quot;外部字體超連結&quot; rel=&quot;stylesheet&quot;&gt; @import 1&lt;style&gt; @import url(&apos;外部字體超連結&apos;); &lt;/style&gt; @font-face 1&lt;style&gt; @font-face &#123; font-family: 自定義名稱; src: url(字體檔超連結); &#125; &lt;/style&gt; @font-face 使用方式 local 代表直接抓取使用者電腦中的字型檔 format 標記 同一種字體但分為四種不同格式，format 標記用意在輔助瀏覽器識別，如果瀏覽器不支援該格式，將會直接跳過這個字體，省去下載字體檔案的時間 SVG 的字體，如果有標記 id 在其中，可在字體名稱後方加上 # 來指定特定 id 字體 可以使用 font-weight、font-style 定義字體特性，讓瀏覽器在解析字體時，只下載有在網頁上被使用的字體檔 12345678910111213@font-face &#123; font-family: ’自定義名稱&apos;; src: local(“Helvetica&quot;) ， url(&apos;../fonts/xxx.woff&apos;) format(&quot;woff&quot;), url(&apos;../fonts/xxx.otf&apos;) format(&quot;opentype&quot;), url(&apos;../fonts/xxx.eot&apos;) format(&quot;embedded-opentype”), url(&apos;../fonts/xxx.ttf&apos;) format(&apos;truetype&apos;), url(&apos;../fonts/xxx.svg#hi&apos;) format(&apos;svg’); font-weight: normal; font-style: normal;&#125;h1&#123; font-family:自定義名稱, serif; &#125; 字型格式 副檔名 format( ) 瀏覽器支援 TrueType .ttf “truetype” 舊版 Android (4.4 版以下) 瀏覽器 WOFF .woff “woff” 大多數瀏覽器(包含chrome)在許多較舊的瀏覽器中無法使用 Embed OpenType .eot “embedded-opentype” 舊版 IE (IE9 之下) 瀏覽器 @font-face - unicode-range 讓某些文字顯示不同字體 unicode-range 說明 U+316 單一字元 U+316-3FF 某個字元區間 U+3?? 某個 U+3 開頭的字元 ( U+300~3FF ) U+216-266, U+3?? 用逗號聯集不同區間 1234567891011121314151617@font-face &#123; font-family: font1; src: url(KouzanBrushFont.ttf); unicode-range: U+611B; &#125; @font-face &#123; font-family: font2; src: url(&quot;setofont.ttf&quot;); unicode-range: U+0057,U+0077; &#125; h1 &#123; font-family: font1, font2, sans-serif; font-size: 50px; font-weight: normal;&#125; RWD 使用者體驗 響應式無法讓所有螢幕解析度都最佳化 遵循 80/20 法則，先兼容熱門瀏覽器 動線設計：並非所有內容都要全部塞到網頁內容 斷點時機：設計多欄式佈局的必要觀念 點擊範圍：設計讓人好點選的元素 少即是多：避免資訊量爆炸( 非全部塞滿 ) 載具特性：使用者行為 touch( 手機 click )、hover(手機體驗不好) 不要習慣寫死高度 mobile first 與 desktop first 優先 mobile 寫法 @media (min-width: 768px) desktop 寫法 @media (max-width: 768px) 先做哪個版本，該版本就比較靈活，而被覆蓋後才產生出來的樣式就會因此而受限 mobil first 要建構良好的行動裝置操作體驗，有以下幾點要注意 : 設計網站的時候要考量行動裝置但不是要從手機網站開始設計起，而是過程中要以手機為主要考量 要符合使用者使用行動裝置的方式與動機 (行動中手機查資料、躺在床上滑平板) 明確的內容比設計齊全的導覽功能更重要 (因為行動版的簡化導致更重要內容被刪除) 提供設計良好的導覽選單，方便使用者閒逛或深入閱讀內容 (不要進網站找不到) RWD 圖片設計 不使用 width 圖片堅持呈現原本寬度 ( 所以超出瀏覽器會出現 x 軸 ) 使用 max-width: 100% 圖片保有自己的最大寬度，並自適應父容器 width 縮小 圖片 size 規劃，刻意設計較大張一點的技巧 banner 設計 - 縮放圖片原理 使用兩張圖 mobile 小張 desktop 大張 banner 或網頁中的圖片，呈現方式 : 將圖片在 css 中用背景圖片的方式來呈現 將圖片在 html 中用 img 放入圖片 這兩種方法有什麼不同的適用時機或使用考量？ banner 如果裡面又有放字的話，要考量在手機上會不會過小，是否要把文字拆出來放，那這樣圖片用背景就比較適合，當然純 img 也可以，那就是用絕對定位來設計 如果電子商務上面的產品列表，通常都是直接插入 img，畢竟你不可能在 css 放各種產品背景圖案，但也是有跟後端配合時 在 HTML 標籤上寫 style background ，最後在圖片上面插入文字 怎麼做會比較適合，會依照 文字是否要放在圖內 大小是否要改變 圖片有無要設計兩種 size 以上(PC、Mobile) 思考要怎麼跟後端配合，他要依照什麼規則在後台上圖，前台也會跟著正常 最後再依照設計師提供給的設計稿來決定要怎麼開發 web layout RWD 開發介紹HTML - viewport CSS 還是 CSS framework 開發，都要先加這一行 加這一行的目的是要強迫網頁的內容，以裝置目前的寬度來做呈現，並禁止縮放( 手機與平板的解析度 不會等於載具寬度 ) 1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width; initial-scale=1.0; maximum-scale=1.0; user-scalable=no;&quot;&gt; viewport - 用戶網頁的顯示區域 content - 操作 viewport 123456789&lt;meta name=&quot;viewport&quot;content=&quot;height = [pixel_value | device-height] ,width = [pixel_value | device-width ] ,initial-scale = float_value ,minimum-scale = float_value ,maximum-scale = float_value ,user-scalable = [yes | no] ,target-densitydpi = [dpi_value | device-dpi | high-dpi | medium-dpi | low-dpi]&quot;/&gt; viewport 的參數: width：控制 viewport 的大小，可以指定的一個值或者特殊的值，如 device-width 為設備的寬度（單位為縮放為100% 時的 CSS 的像素） height：和 width 相對應，指定高度 initial-scale：初始縮放 一個浮點值，是頁面大小的一個乘數 例如，如果設置初始縮放為 “1.0”，那麼，web 頁面在展現的時候就會以 target density 分辨率的 1:1 來展現 如果設置為 “2.0”，那麼這個頁面就會放大為 2 倍。 (最小0.25，最大5) minimum-scale：最小縮放 (最小0.25，最大5) maximum-scale：最大縮放 一個浮點值，用指出頁面大小與屏幕大小相比的最大乘數 例如，如果將這個值設置為“2.0”，那麼這個頁面與 target size 相比，最多能放大2倍 (最小0.25，最大5) user-scalable：用戶是否能改變頁面縮放程度 如果設置為 yes 則是允許用戶對其進行改變，反之為 no, 默認值是 yes 如果設置為no，那麼 minimum-scale 和 maximum-scale 都將被忽略，因為根本不可能縮放( 1 或 0 (yes 或 no) ) target-densitydpi：一個屏幕像素密度是由屏幕分辨率決定的，通常定義為每英寸點的數量（dpi） Android 支持三種屏幕像素密度：低像素密度，中像素密度，高像素密度 一個低像素密度的屏幕每英寸上的像素點更少，而一個高像素密度的屏幕每英寸上的像素點更多 Android Browser 和 WebView 默認屏幕為中像素密度(160dpi) target-densitydpi 的取值範圍: device-dpi：使用設備原本的 dpi 作為目標 dpi，不會發生默認縮放 high-dpi：使用 hdpi 作為目標 dpi，中等像素密度和低像素密度設備相應縮小 medium-dpi：使用 mdpi 作為目標 dpi，高像素密度設備相應放大，像素密度設備相應縮小。這是默認的 target density low-dpi：使用 mdp i作為目標 dpi，中等像素密度和高像素密度設備相應放大 value：指定一個具體的 dpi 值作為 target dpi，這個值的範圍必須在 70–400 之間 設置螢幕密度為高頻，中頻，低頻自動縮放，禁止用戶手動調整縮放：123456&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, target-densitydpi=high-dpi, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no&quot;/&gt; CSS - Media Queries123456789@media and|or|not|only and (media feature) &#123; CSS Code;&#125;@media 媒體類型 and (條件) &#123;.css &#123; CSS Code; &#125;&#125; Media Types可參考 W3C -&gt; http://www.w3.org/TR/CSS21/media.html#media-types Value Description all 全部 print 印表機 braille 點字機 screen 視窗螢幕大小 speech 語音合成器 Media Features Value Description width 視窗寬度 height 視窗高度 max-device-height 最大裝置高度 max-device-width 最大裝置寬度 max-height 最大高度 max-width 最大寬度 min-device-width 最小裝置寬度 min-device-height 最小裝置高度 min-height 最小高度 min-width 最小寬度 and 使用者視窗寬度 &lt;= 768px，將字體大小變為 20px 使用者視窗寬度介於 768px ~ 992px，將字體大小變為 30px 使用者視窗寬度 &gt;= 1200px，將字體大小變為 40px 1234567891011121314151617@media screen and (max-width: 768px) &#123;.div1 &#123; font-size: 20px; &#125;&#125;@media screen and (min-width: 768px) and (max-width: 992px) &#123;.div1 &#123; font-size: 30px; &#125; &#125;@media screen and (min-width: 1200px) &#123;.div1 &#123; font-size: 40px; &#125;&#125; or 如果使用者視窗寬度在 XXXpx(含)以下，或 XXXpx(含)以上 將背景變為紅色 123@media screen and (max-width: 600px), screen and (min-width: 800px) &#123; div &#123; background: red; &#125;&#125; not 用來排除符合表達式的設備尺寸 123@media not screen and (max-width: 600px) &#123; div &#123; background: red; &#125;&#125; only 用來針對那些不支援 media queries 卻需要讀取 media type 的設備隱藏樣式用 123456@media only screen and (min-width:480px) &#123; div &#123; background: red; &#125;&#125;media queries 是 CSS3 對於 media type 的一個擴展所以不支援 media queries 的瀏覽器還是要能識別 media type 推薦撰寫方式 使用 CSS media type 區分不同解析度，分別讀入不同 CSS 語法 123&lt;link href=&quot;/css/phone.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;/&gt;&lt;link href=&quot;/css/tablet.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt;&lt;link href=&quot;/css/desktop.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;/&gt; CSS - Fluid Grids 網頁元素以方格式設計 (Grid Design) + 依照視窗大小縮放的流動佈局 (Liquid Layout) Grid Design - 一般網頁 div 排版超過容器最大寬度, div 自動擠到下一行 float (clearfix 來消除 float 的效果) inline-block flex Liquid Layout 把原本用 px 單位製作的版面改成用 %, em, rem PT CSS pt 不等於 iOS pt ，其運作方式也不相同，所以不要放在一起 pt 這個單位詞，其實最早源自於傳統的鉛字印刷，是用來表示鉛字塊的尺寸 1 pt = 1/72 英吋 而 CSS 之所以有 pt 這個單位，其實是要把網頁印刷/列印出來的時候用到的 Retina 螢幕的 iOS 單位 - pt (ppi) 效果：設計稿尺寸 / 2，元素寬度使用百分比實現 ( 比如設計稿上的高度是 200px，則 CSS 中就是 height:100px) 設計稿圖要兩倍大做使用 PPI = Pixels Per Inch 紅點為了維持一樣的大小，他的長/寬就會各涵蓋到 2px，所以原本銀色機上 1pt 等於 1px ，但到了螢幕密度兩倍的地方， 1pt 的大小就會代表 2px CSS - Fluid Image 把原本的 px 單位換成 % ，然後達到依畫面尺寸縮放的功能 要考慮圖片放大後失真 or 可能會有想要針對螢幕大小指定合適圖片的需求 (在設計圖片時把圖解析度設高) RWD 顯示圖片的方式有兩種，一種是傳統 img 標籤，另一種是 CSS 的背景圖 一般圖片 img 標籤，將 width 或 height 設 % 就可以了，另一個設為 auto max-width : 100% 方式防止圖片大到糊掉 1234#banner &#123; width: 100%; | max-width : 100%; height: auto;&#125; 第二種是針對容器(如 div)使用背景圖片 背景圖的方式可彌補 img 但無法針對螢幕大小指定合適圖片 1234567#banner &#123; width: 100%; height: 100px; background-repeat: no-repeat; background-size: 100% auto; background-image: url(&apos;banner.jpg&apos;);&#125; Bootstrap - Fluid Grids 12 欄 Grid System ，以 960px 為基準，因為早期電腦螢幕通常為 1024px，960px 的設計是最為剛好 使用一組 .col-md- *網格類，可以創建一個基本的網格系統，將網格列放置在 .row 中 123456789101112131415161718// 通過製作一個全寬和另一個半寬&lt;div class=&quot;row&quot;&gt;&lt;div class=&quot;col-xs-12 col-md-8&quot;&gt;.col-xs-12 .col-md-8&lt;/div&gt;&lt;div class=&quot;col-xs-6 col-md-4&quot;&gt;.col-xs-6 .col-md-4&lt;/div&gt;&lt;/div&gt;// 移動設備上的列開始為50％，桌面上的列開始為33.3％&lt;div class=&quot;row&quot;&gt;&lt;div class=&quot;col-xs-6 col-md-4&quot;&gt;.col-xs-6 .col-md-4&lt;/div&gt;&lt;div class=&quot;col-xs-6 col-md-4&quot;&gt;.col-xs-6 .col-md-4&lt;/div&gt;&lt;div class=&quot;col-xs-6 col-md-4&quot;&gt;.col-xs-6 .col-md-4&lt;/div&gt;&lt;/div&gt;// 移動和桌面上的列寬50％&lt;div class=&quot;row&quot;&gt;&lt;div class=&quot;col-xs-6&quot;&gt;.col-xs-6&lt;/div&gt;&lt;div class=&quot;col-xs-6&quot;&gt;.col-xs-6&lt;/div&gt;&lt;/div&gt; Bootstrap - Media Queries 當寬度超過該數值以上時會套⽤樣式 1234567891011// Small devices (landscape phones, 576px and up)@media (min-width: 576px) &#123; ... &#125;// Medium devices (tablets, 768px and up)@media (min-width: 768px) &#123; ... &#125;// Large devices (desktops, 992px and up)@media (min-width: 992px) &#123; ... &#125;// Extra large devices (large desktops, 1200px and up)@media (min-width: 1200px) &#123; ... &#125; Bootstrap - Fluid Image bootstrap 要做到 fluid images 只要加上 class=”img-responsive” img-responsive 這個 class 就是下面這幾個 CSS 組成 max-width: 100%; height: auto; display: block; 如果要讓 class=”img-responsive” 的圖片置中可以使用 .center-block","categories":[{"name":"CSS","slug":"CSS","permalink":"https://jimmywei01.github.io/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://jimmywei01.github.io/tags/CSS/"},{"name":"RWD","slug":"RWD","permalink":"https://jimmywei01.github.io/tags/RWD/"},{"name":"瀏覽器","slug":"瀏覽器","permalink":"https://jimmywei01.github.io/tags/瀏覽器/"}]},{"title":"CSS-grid","slug":"CSS-grid","date":"2019-05-21T08:59:10.000Z","updated":"2019-05-27T05:50:35.473Z","comments":true,"path":"2019/05/21/CSS-grid/","link":"","permalink":"https://jimmywei01.github.io/2019/05/21/CSS-grid/","excerpt":"CSS grid 排版透過 grid template 來定義版型的結構，分別由 column 及 row 定義出直排與橫列的格線，內容再依隔線作安排可跨行跨列排版","text":"CSS grid 排版透過 grid template 來定義版型的結構，分別由 column 及 row 定義出直排與橫列的格線，內容再依隔線作安排可跨行跨列排版 可參考 https://css-tricks.com/snippets/css/complete-guide-grid/ https://codepen.io/Jimmywei01/pen/yWodJZ?editors=1100 CSS Grid Terminology grid Line : 分隔元素的線，可以是垂直與水平，如下圖的紅色線 grid Track : 兩條分隔線中間的區域，簡單想就是 Grid 中的 Columns 或 Rows，如下圖的綠色區塊 grid Cell : Grid 中的基本單位，四條線組成的區域，如下圖的藍色區塊。 grid Area : 由數個 Cell 組成的區域，如下圖的紅色區塊。 track-size : fr 單位，通常用於分配 row 或 column 的非彈性尺寸設定完後之剩餘空間。以下圖的 column為例，意思即：將去掉 100px 與 10px 後的剩餘空間，分配為 30% 與 70% line-name: 可自行命名的名稱 grid 外容器屬性 display 網格行列設定 grid-auto-flow : row | column | row dense | column dense grid-template-areas : grid-template-columns | grid-template-rows grid-template : none | subgrid | grid-template-rows / grid-template-columns grid-gap = grid-column-gap + grid-row-gap 網格對齊位址 justify-items align-items justify-content align-content grid 內容器屬性 grid-column-start grid-column-end grid-row-start grid-row-end grid-column grid-row grid-area justify-self align-self 外容器display grid inline-grid 網格行列設定 grid-auto-flow 設定 格線 的長寬度 沒有明確放置在網格上的網格項（grid items），自動放置算法會自動放置這些網格項 row：自動佈局 每行 column：自動佈局 每列 row dense | column dense：自動佈局算法在稍後出現較小的網格項時，嘗試填充網格中較早的空缺，可能導致網格項出現亂序 12345678910111213141516.flow, .flow2&#123; display: grid; grid-template-columns: 60px 60px 60px 60px ; grid-template-rows: 30px 30px; grid-auto-flow: row; height: 100px; width: 450px; margin: 0 10px; border: 2px solid #f76707;&#125;.flow2&#123; grid-auto-flow: column;&#125; grid-template-areas 透過 area 定義區塊在 template 上的位置，概念就是在畫面上登記屬於該元素的空間，此部分要內外元素一起看 外元素 grid-template-areas：定義空間的位置，是透過幾組字串的組合 (名稱會通過區域在排列位置） 內元素 grid-area：定義空間的名稱 .（點號）：代表一個空的網格單元 none：不定義網格區域 1234567891011121314.warp4&#123; display:grid; grid-template-columns: 100px 50px auto 50px 100px; grid-template-rows: 25% auto 100px; grid-template-areas: &quot;head head head head head&quot; &quot;side main main main main&quot; &quot;side foot foot foot foot&quot;; height: 250px; width: 400px; margin: 10px;&#125; grid-template none：將所有三個屬性設置為其初始值 subgrid：將 grid-template-rows，grid-template-columns 的值設為 subgrid，grid-template-areas 設為初始值 grid-template-rows / grid-template-columns： 將 grid-template-columns 和 grid-template-rows 設置為相應地特定的值，並且設置 grid-template-areas 為 none 1234567891011121314.warp5&#123; display:grid; grid-template: 1fr 50px 2fr / 20% 50px 1fr; height: 250px; width: 400px; margin: 10px; border: 2px solid #f76707; grid-template-areas: &quot;header header header&quot; &quot;main main main&quot; &quot;footer footer footer&quot;;&#125; grid-template-columns | grid-template-rows 定義的行列所組成 &lt;line-name&gt; 指定網格線(Grid Line)名稱 123456789101112// &lt;line-name&gt; -&gt; [first],[line2],[line3],[col4-start],[five],[end].warp&#123; display: grid; grid-template-columns: [first] 100px [line2] 50px [line3] auto [col4-start] 50px [five] 100px [end]; grid-template-rows: 25% auto 100px; height: 250px; width: 400px; margin: 10px; border: 2px solid #f76707;&#125; grid-gap = grid-column-gap + grid-row-gap 定義行與列間距 grid-column-gap 左右間距 grid-row-gap 上下間距 1234567891011121314.warp2&#123; display: grid; grid-template-columns: 100px 50px auto 50px 100px; grid-template-rows: 25% auto 100px; grid-column-gap: 10px; grid-row-gap: 20px; grid-gap: 10px 20px; height: 250px; width: 400px; margin: 10px; border: 2px solid #f76707;&#125; fr 是因應 CSS grid 而產生的新單位，全名是 fraction (分數)，是數學分子 + 分母的那個分數 在剩餘空間中所占的比例 可以用 fr 去設定 CSS grid 的相對寬度，以達到 RWD 的縮放效果 如果是跟前面範例一樣使用 px，縮放的時候是不會有 RWD 的 可以混搭單位 repeat(重覆幾次, 重覆的寬度) 重複 grid 的設定 最左邊跟最右邊的 grid 如果不會重覆，可以接在 repeat 的前後 12345678910.warp3&#123; display:grid; grid-template-columns: repeat(2,1fr 2fr 1fr) 50px; height: 250px; width: 400px; margin: 10px; border: 2px solid #f76707;&#125; 網格對齊位址 justify-items - 主軸 「水平對齊」每個網格區域的位置 網格對齊位置 沿著內聯（行）軸對齊網格項（與沿著塊（列）軸對齊的項對齊） start：將內容對齊到網格區域（grid area）的左側 end：將內容對齊到網格區域的右側 center：將內容對齊到網格區域的中間（水平居中） stretch：填滿網格區域寬度（默認值） 1234567891011121314151617.warp6, .warp7, .warp8, .warp9 &#123; display:grid; grid-template-columns: auto 50px auto; grid-template-areas: &quot;head head head&quot; &quot;foot &quot;; justify-items: start; justify-items: end; justify-items: center; justify-items: stretch; height: 50px; width: 200px; margin: 0 5px; border: 2px solid #f76707;&#125; align-items - 主軸 「垂直對齊」每個網格區域的位置 沿著列軸線（列軸）對齊網格項（grid items）內的內容 1234567891011121314151617.warp10, .warp11, .warp12, .warp13 &#123; display:grid; grid-template-columns: auto 50px auto; grid-template-areas: &quot;head head head&quot; &quot;foot &quot;; align-items:start; align-items:end; align-items:center; align-items:stretch; height: 50px; width: 200px; margin: 0 5px; border: 2px solid #f76707;&#125; justify-content - 網格區域 在 網格容器內 的「水平對齊」位置 start：將網格對齊到網格容器（grid container）的左邊 end：將網格對齊到網格容器的右邊 center：將網格對齊到網格容器的中間（水平居中） stretch：調整網格項（grid items）的寬度，允許該網格填充滿整個網格容器的寬度 space-around：在每個網格項之間放置一個均勻的空間，左右兩端放置一半的空間 space-between：在每個網格項之間放置一個均勻的空間，左右兩端沒有空間 space-evenly：在每個柵格項目之間放置一個均勻的空間，左右兩端放置一個均勻的空間 1234567891011121314151617181920.warp14, .warp15, .warp16, .warp17, .warp18, .warp19, .warp20 &#123; display:grid; grid-template-columns: auto 50px auto; grid-template-areas: &quot;head head head&quot; &quot;foot &quot;; justify-content:start; justify-content:end; justify-content:center; justify-content:stretch; justify-content:space-around; justify-content:space-between; justify-content:space-evenly; height: 100px; width: 150px; margin: 0 5px; border: 2px solid #f76707;&#125; align-content - 網格區域 在 網格容器內 的「垂直對齊」位置 1234567891011121314151617181920.warp21, .warp22, .warp23, .warp24, .warp25, .warp26, .warp27 &#123; display:grid; grid-template-columns: auto 50px auto; grid-template-areas: &quot;head head head&quot; &quot;foot &quot;; align-content:start; align-content:end; align-content:center; align-content:stretch; align-content:space-around; align-content:space-between; align-content:space-evenly; height: 100px; width: 150px; margin: 0 5px; border: 2px solid #f76707;&#125; 內容器 grid-column-start | grid-column-end | grid-row-start | grid-row-end 物件所佔的空間位置，column 及 row 所到的起始點及終點 通過指定網格線（grid lines）來確定網格內網格項（grid item）的位置 number | name | span number | span name | auto span number - 物件所佔用的欄位數 span name - 物件所在的 grid 名稱 auto - 自動 12345678910111213.item-boxIn &#123; grid-column-start: 2; grid-column-end: 4; grid-row-start: 2; grid-row-end: 3; height: 100%; width: 100%; border: 2px solid #f76707; background-color: #fff4e6; text-align:center;&#125; grid-column = grid-column-start + grid-column-end grid-row = grid-row-start + grid-row-end 1234567891011.item-boxIn2 &#123; grid-column: 2 / span 3; grid-row: 3 / auto; height: 100%; width: 100%; border: 2px solid #f76707; background-color: #fff4e6; text-align:center;&#125; grid-area: &lt;row-start&gt; / &lt;column-start&gt; / &lt;row-end&gt; / &lt;column-end&gt; 為網格項提供一個名稱，以便可以被使用網格容器 grid-template-areas 屬性創建的模板進行引用 12345678910.item-boxIn3&#123; display:grid; grid-area: header; grid-area: 1 / 2 / 4 / 5; border: 2px solid #f76707; background-color: #fff4e6; text-align:center;&#125; justify-self: start | end | center | stretch 沿著行軸線（row axis）對齊網格項的內容 此值適用於單個網格項目的內容 控制自己在網格中的位置 123456789101112131415.item-boxIn4, .item-boxIn5, .item-boxIn6&#123; display:grid; justify-self:start; justify-self:end; justify-self:center; justify-self:stretch; height: 30px; width: 60px; grid-area: 1 / 1 / 3 / 3; border: 2px solid #f76707; background-color: #fff4e6; text-align:center;&#125; align-self: start | end | center | stretch 沿著列軸線（列軸）對齊網格項內的內容 此值適用於單個網格項目的內容 控制自己在網格中的位置 123456789101112131415.item-boxIn8, .item-boxIn9, .item-boxIn10&#123; display:grid; align-self:start; align-self:end; align-self:center; align-self:stretch; height: 30px; width: 60px; grid-area: 1 / 1 / 3 / 3; border: 2px solid #f76707; background-color: #fff4e6; text-align:center;&#125; 自動響應式排列 auto-fill 不隨容器區域改變 minmax 最小和最大尺寸 12345678.warp30 &#123; display: grid; grid-gap: 5px; grid-template-columns: repeat(auto-fill, minmax(50px, 1fr)); grid-auto-rows: 50px;&#125; auto-fit 隨容器區域改變 12345678.warp31 &#123; display: grid; grid-gap: 5px; grid-template-columns: repeat(auto-fit, minmax(50px, 1fr)); grid-auto-rows: 50px;&#125;","categories":[{"name":"CSS","slug":"CSS","permalink":"https://jimmywei01.github.io/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://jimmywei01.github.io/tags/CSS/"},{"name":"grid","slug":"grid","permalink":"https://jimmywei01.github.io/tags/grid/"}]},{"title":"CSS-flex","slug":"CSS-flex","date":"2019-05-19T09:35:39.000Z","updated":"2019-05-27T05:50:35.472Z","comments":true,"path":"2019/05/19/CSS-flex/","link":"","permalink":"https://jimmywei01.github.io/2019/05/19/CSS-flex/","excerpt":"CSS flex 排版缺點 - 無法跨行跨列排版","text":"CSS flex 排版缺點 - 無法跨行跨列排版 可參考 -&gt; https://codepen.io/Jimmywei01/pen/wbemBx?editors=1100 flex 排版方向位置flex - 依照 排版方向(row column) 決定 分布位置( justify-content-主軸 align-items-副軸) 水平的起點與終點 ( main start、main end ) 垂直的起點與終點 ( cross start、cross end ) 水平軸與垂直軸 ( main axis、cross axis ) 元素具有水平尺寸與垂直尺寸 ( main size、cross size ) flex 外容器屬性 display flex-direction justify-content flex-wrap align-items align-content flex 內元件屬性 flex flex-grow flex-shrink flex-basis align-self order 外容器display flex inline-flex flex-direction - 分布方向 column：從上到下 column-reverse：與 column 相反 row：預設值，由左到右 row-reverse：與 row 相反 justify-content - 主軸 flexbox 的「水平對齊」位置 flex-start：預設值，對齊最左邊的 main start flex-end：對齊最左邊的 main end center：水平置中 space-between：平均分配內容元素，左右元素將會與 main start 和 main end 貼齊 space-around：平均分配內容元素，兩旁間距平均分配 space-evenly(空間均勻)：平均分配全部內容元素 flex-wrap - 超出範圍時是否換行的屬性，分為換行、不換行、換行時反轉 nowrap：預設值，單行 wrap：多行 wrap-reverse：多行，但內容元素反轉 align-items - 副軸(單行元素) Flexbox 的「垂直對齊」位置無效屬性: space-between , space-around , space-evenly flex-start：預設值，對齊最上面的 cross start flex-end：對齊最下面的 cross end center：垂直置中 stretch：將內容元素全部撐開至 flexbox 的高度 在高度被限制的情況下不會正常伸展 baseline：以所有元素內容的基線作為對齊標準 物件排列: justify-content + align-items align-content - 副軸(多行元素) flexbox 的「垂直對齊」位置 flex-start：預設值，對齊最上面的 cross start flex-end：對齊最下面的 cross end center：垂直置中 space-between：將第一行與最後一行分別對齊最上方與最下方 space-around：每行平均分配間距 stretch：內容元素全部撐開 內元件flex 由三個屬性組合而成，flex-grow、flex-shrink、flex-basis，如果 flex 只填了一個數值(無單位)，那麼預設就是以 flex-grow 的方式呈現 flex-grow : 指定 flex 項目的放大比例，按照數字做相對應的「伸展」比例分配，預設值為 0，不會進行彈性變化，不可為負值，設為 1 則會進行彈性變化 flex-shrink：指定 flex 項目的縮小比例，按照數字做相對應的「壓縮」比例分配(值越大壓縮越小)，預設值為 1，設為 0 的話不會進行彈性變化，不可為負值 flex-basis： 元件的基準值，可使用不同的單位值，子元素的基本大小作為父元素的大小比較基準，預設值為 0，沒有設定的時候會以直接採用 flex-grow 屬性 align-self - 和 align-items 相同，但目的不同(多行元素處理) align-self 的作用在於覆寫已經套用 align-items 的屬性 flex-start：預設值，對齊最上面的 cross start flex-end：對齊最下面的 cross end center：垂直置中 stretch：將內容元素全部撐開至 flexbox 的高度 baseline：以所有元素內容的基線作為對齊標準 order - 控制 flex 容器中 flex 項目的排列順序，默認值為 0 CSS 設定 排列順序：-1、flex:2、0、1、2","categories":[{"name":"CSS","slug":"CSS","permalink":"https://jimmywei01.github.io/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://jimmywei01.github.io/tags/CSS/"},{"name":"flex","slug":"flex","permalink":"https://jimmywei01.github.io/tags/flex/"}]},{"title":"CSS 紀錄","slug":"CSS-紀錄","date":"2019-05-16T05:40:41.000Z","updated":"2019-05-27T05:50:35.470Z","comments":true,"path":"2019/05/16/CSS-紀錄/","link":"","permalink":"https://jimmywei01.github.io/2019/05/16/CSS-紀錄/","excerpt":"紀錄常用的CSS -&gt; Cascading Style Sheet 層疊樣式表","text":"紀錄常用的CSS -&gt; Cascading Style Sheet 層疊樣式表 CSS - 塊級元素(block) &amp; 行內元素(inline) 塊級元素 自動換行 能設置寬高 margin 和 padding 上下左右的值都可以設定 &lt;div&gt;、&lt;p&gt;、&lt;ul&gt;、&lt;table&gt; 行內元素 不自動換行 設置寬高無效 padding 上下左右都可以設置；但 margin 左右值有效，上下值無效 &lt;a&gt;、&lt;span&gt;、&lt;img&gt;、&lt;button&gt;、 偽元素、label CSS - 選擇器 選擇器 表示方式 子孫 空格 孩子 &gt; 兄弟姊妹 ~/+ 元素 a{} 偽元素 ::before{} class .link{} 屬性 [type=radio]{} 偽類 :hover{} id #id{} 組合 [type=checkbox]+label{} 否定 :not(.link){} 通用 *{} CSS - 選擇器優先級!important(10000) &gt; 行內樣式(1000) &gt; id 選擇器(100) &gt; class 選擇器(10) &gt; tag 選擇器(1) CSS - 前綴詞 Chrome與Safari正是用webkit核心 -moz-則是Mozilla公司的縮寫(Gecko核心)，代表瀏覽器為Firefox -o-是Opera瀏覽器的縮寫(Presto核心) -ms-微軟的縮寫代表瀏覽器是ie 1234567.class&#123; -webkit-border-radius: 5px; -moz-border-radius: 5px; -ms-border-radius: 5px; -o-border-radius: 5px; border-radius: 5px;&#125; CSS - reset &amp; normalize reset 使用時機 - 設計師針對畫面樣式的規定不一定會與瀏覽器的預設相符的時候 把所有瀏覽器最不一致的地方強制歸 0 優點是統整、重置了各個瀏覽器的樣式設定 缺點是必須全部重新做設定，比較沒有彈性 normalize 最大的特色就是保留原本預設 HTML 標籤的樣式，僅針對不同瀏覽器與各版本間不相容的標籤進行些微調整 修正瀏覽器的 Bug 與不一致 CSS - 語法display - 常用的元件顯示類別屬性 block inline inline-block flex grid table none initial - 讓屬性恢復預設值 inherit black - 佔據一整行的方塊有自己的寬高，其他內容都會被擠走 123.block &#123; display :block; &#125; inline - 內容有多大就多大 沒辦法設定長寬 (符合內容長寬) 123456&lt;div class=&quot;block&quot;&gt;Lorem ipsum dolor&lt;/div&gt;.block &#123; display: inline; border: 1px solid red;&#125; inline-block - 可以設定寬高但又不會佔據一整行 123456789101112131415&lt;div class=&quot;block&quot;&gt;Lorem ipsum dolor&lt;/div&gt;&lt;div class=&quot;block2&quot;&gt;Lorem ipsum dolor&lt;/div&gt;.block &#123; display: inline-block; border: 1px solid red; width:50px; height:50px;&#125;.block2 &#123; display:inline-block; border: 1px solid red; width:50px; height:50px;&#125; display:none &amp; visibility:hidden &amp; overflow:hidden 差異 display:none - 使用此屬性之後元素不存在了，元素佔據的位置也不存在 visibility:hidden - 使用此屬性之後元素不存在了，元素佔據的位置依然存在 overflow:hidden - 對行內元素無效，必須是塊級元素，並且設置寬度高度，隱藏之後元素依然佔據著位置 display: flex 下 overflow: hidden 失效 在父元素設定 12min-width: 0; 或 min-height: 0;overflow: hidden; position - 用來設定”位子”的特性statice 定位元素 - 元件按照自然排列無法調整位置 1position: static; relative 相對定位元素 - 可調整元件的位置 123position: relative;top: 40px; left: 40px; absoult 絕對定位元素 - 找最近有設定過 position 的祖先 , 若沒有則去找 body 123position: absolute; top: 40px; left: 40px; fixed 固定定位 - 元件會固定在畫面上，不會隨捲軸滾動而移動 12position: fixed; top: 20px; sticky 黏性定位 - relative + fixed 混合 123position: -webkit-sticky; position: sticky; top: 20px; float - 文繞圖可參考 -&gt; https://developer.mozilla.org/zh-CN/docs/CSS/float 1float: none; 1float: left; 1float: right; CSS - 清除浮動元件codePen -&gt; https://codepen.io/Jimmywei01/pen/vwxzxE?editors=1100 float 浮動元素的父元素高度塌陷問題 clearfix 作法 建立假的元素，設定塊級元素(table or block)，左側和右側均不允許出現浮動元素 BFC (Block Formatting Contexts 塊級格式化上下文) 作法 (W3C CSS2.1 規範中的一個概念) 具有 BFC 特性的元素可以看作是隔離了的獨立容器，容器裡面的元素不會在佈局上影響到外面的元素，並且 BFC 具有普通容器所沒有的一些特性 可以把 BFC 理解為一個封閉的大箱子，箱子內部的元素無論如何設定都不會影響到外部元素 觸發BFC 特性： body 根元素 浮動元素：float 除 none 以外的值 絕對定位元素：position (absolute、fixed) display 為 inline-block、table-cells、flex overflow 除了 visible 以外的值(hidden、auto、scroll) BFC 作法 與 clearfix 擇一使用12345678910111213141516171819&lt;div class=“content clearfix&quot;&gt; &lt;div class=&quot;box&quot;&gt;box&lt;/div&gt; &lt;div class=&quot;box2&quot;&gt;box2&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;box3&quot;&gt;box3&lt;/div&gt;.content&#123; background-color:black; width:500px;/* BFC 作法 */ overflow:hidden;&#125;/* clearfix 作法 */.clearfix:after &#123; content: &quot;&quot;; display: table; clear: both;&#125; CSS - margin collapsing(崩塌) 兩個元件之間的 margin 重疊 讓父元素形成 BFC來接管自己的高度 在父元素增加 overflow:hidden 或在子元素增加 display:inline-hidden 等等 123456789101112131415161718192021.towBox&#123; /* overflow:hidden; */&#125;.box4 &#123; /* display:inline-block; */ margin:50px; background-color: pink; width: 100px; height:100px; text-align:center; line-height:100px;&#125;.box5 &#123; margin:50px; background-color: yellow; width: 100px; height:100px; text-align:center; line-height:100px;&#125; CSS - z-index 疊層樣式 可參考 https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Understanding_z_index/The_stacking_context https://codepen.io/Jimmywei01/pen/XwRYmQ?editors=1100 設定 HTML 元素定位屬性和 z-index 屬性創建一個層疊上下文 (opacity 值不為1 也會創建疊層) Root DIV #1 DIV #2 DIV #3 DIV #4 DIV #5 DIV #6 DIV #2、DIV #3 是 DIV #1 的子元素，它們的層疊和渲染完全在 DIV #1 中處理處理完成，DIV #1 元素作為一個整體並與 DIV #4、DIV #5 、DIV #6 元素進行層疊處理 CSS - box-model margin / border / padding / width / height max-width max-height 可參考 -&gt; https://codepen.io/Jimmywei01/pen/eaWNda box-sizing: content-box 元素的寬為 160px，那麼這個元素的內容區會有 160px 寬，並且任何邊框和內邊距的寬度都會被增加到最後繪製出來的元素寬度中 box-sizing: border-box 元素的 width 設為160px,那麼這160px 會包含其它的 border 和 padding，內容區的實際寬度會是width 減去 border + padding 的計算值 表示盒子模型的寬度和高度將包含其內邊距和邊框 更容易去設定元素的寬高 1234567891011121314151617181920&lt;div class=&quot;content-box&quot;&gt;Content box&lt;/div&gt;&lt;div class=&quot;border-box&quot;&gt;Border box&lt;/div&gt;div &#123; width: 160px; height: 80px; padding: 20px; border: 8px solid red; background: yellow;&#125;.content-box &#123; box-sizing: content-box; /* Total width: 160px + (2 * 20px) + (2 * 8px) = 216px Total height: 80px + (2 * 20px) + (2 * 8px) = 136px */&#125;.border-box &#123; box-sizing: border-box; /* Total width: 160px Total height: 80px */&#125; CSS 提問 CSS 的 class 和 id 差異？ id 權重 &gt; class 權重 同一個頁面上的兩個元素不能有相同的 id 屬性值 怎麼實現水平置中 &amp; 垂直置中 可參考 -&gt; https://ithelp.ithome.com.tw/users/20112550/ironman/2092 行內元素 12text-align: center;line-height: 100px; 塊級元素 1margin: 0 auto; 未知高度和寬度元素的水平垂直居中 被置中的元素是 inline 或者 inline-block 元素 1234567.container&#123; width: 600px; height: 600px; display: table-cell; text-align: center; vertical-align: middle;&#125; CSS3 的 transform 屬性 1234567891011.container&#123; width: 100%; height: 600px; position: relative;&#125;.center&#123; position:absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);&#125; flex 1234567.container&#123; width: 100%; height: 600px; display: flex; justify-content: center; align-items: center;&#125; 實現左邊定寬，右邊自適應佈局 左盒子左浮動，右盒子 width=100% 左盒子左浮動，右盒子 margin-left=左盒子寬度 左盒子左浮動，右盒子右浮動，設置 width: calc（100 % - 左盒子寬度） 父容器設置 display：flex，右盒子 flex：1","categories":[{"name":"CSS","slug":"CSS","permalink":"https://jimmywei01.github.io/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://jimmywei01.github.io/tags/CSS/"}]},{"title":"cookie、session、local storage、session storage 差異","slug":"cookie、session、local-storage、session-storage-差異","date":"2019-05-14T07:56:55.000Z","updated":"2019-05-27T06:02:47.624Z","comments":true,"path":"2019/05/14/cookie、session、local-storage、session-storage-差異/","link":"","permalink":"https://jimmywei01.github.io/2019/05/14/cookie、session、local-storage、session-storage-差異/","excerpt":"重要的傳遞手法","text":"重要的傳遞手法 session Storage 和 local Storage 的差別 可參考 https://developer.mozilla.org/zh-CN/docs/Web/API/Window/localStorage https://developer.mozilla.org/zh-CN/docs/Web/API/Window/sessionStorage JSON.stringify - 轉字串儲存 JSON.parse - 轉物件取出 寫入 local Storage (session Storage 亦同) 1234// 設定 local storagelet todo = [ ]todo.push(&apos;Mario red’,&apos;Mario blue’,&apos;Mario black’,&apos;Mario pink’,&apos;Mario yellow&apos;)localStorage.setItem(&apos;todolist&apos;,JSON.stringify(todo)) 12345678910// 取出 local storagelet data = JSON.parse(localStorage.getItem(&apos;todolist’))-&gt; [&quot;Mario red&quot;, &quot;Mario blue&quot;, &quot;Mario black&quot;, &quot;Mario pink&quot;, &quot;Mario yellow”]// 資料操作data.splice(data2.indexOf(&apos;Mario blue&apos;),1)-&gt; [&quot;Mario red&quot;, &quot;Mario black&quot;, &quot;Mario pink&quot;, &quot;Mario yellow”]// 刪除整個 local storagelocalStorage.removeItem(&apos;todolist&apos;) Storage sessionStorage localStorage 存儲大小限制 5M或更大，不會把數據發給服務器僅在本地保存 5M或更大，不會把數據發給服務器僅在本地保存 數據有效期 僅在當前瀏覽器窗口關閉前有效 始終有效，窗口或瀏覽器關閉也一直保存 作用域 不在不同的瀏覽器窗口中共享，即使是同一個頁面 在所有同源瀏覽器窗口中都是共享的 安全性 比 cookie 高一點 比 cookie 高一點 舉例 session Storage 傳送頁面 例如購物流程，加入購物車 &gt; 填寫購物資料 &gt; 進入結帳畫面 &gt; 成功 假設填寫購物資料時回到上一頁按加入購物車的時候， JS 就可透過 sessionStorage 傳遞即時資訊，而頁面關閉時購物資料的 sessionStorage 也會跟著關閉，以減少機敏資訊外流的風險 session 和 cookie 的差別 session：帳號登錄驗證過後，後端所發的識別證 cookie：是瀏覽器存放資料的地方，可以存放 seesion 之類的資料 後端可以要求前端要設置 cookie 來存放 seesion，這樣在換頁的時候，每發送一次 request 時順便也會把 seesion 送到後端，這樣後端都可以知道是同一個人（而不是每次都要送一次帳號密碼去做驗證） 建議在後端進行寫 cookie 操作，並通過 session 來控制 cookie 的過期時間 cookie 欄位 說明 name 名稱 key 鍵 value 內容 value 值 Domin 網域 取得該 cookie 的網域 path 路徑 設定可以存取該 cookie 路徑 secure 傳送連線類型 設定 cookie 是否要 https 才可以進行傳送 Expires 建立時間 限制 cookie 有效時間 httpOnly 此 cookie 只能從 web server 訪問，以避免不正確的進入來取得竄改 clint 端寫入 cookie 1document.cookie = &quot;myName=jimmy&quot; 12345// 寫入 cookie，並加入過期時間document.cookie=&quot;username=bob; expires=Mon, 04 Dec 2017 08:18:32 GMT; path=/&quot;// 寫入 cookie，設定 10 秒後失效document.cookie=&quot;username=bob; max-age=10; path=/&quot; server session cookie 儲存大小限制 與 cookie 共用，利用 session Id 來判定＆記錄資料 ex. 會員網站登入 cookie 在瀏覽器和服務器間來回傳遞，可以限制 cookie 只屬於某個路徑下。cookie 數據不能超過 4k，每次 http 請求都會攜帶 cookie 數據有效期 僅在當前瀏覽器窗口關閉前有效 在設置的 cookie 過期時間之前一直有效，即使窗口或瀏覽器關閉作用域 作用域 無 在所有同源瀏覽器窗口中都是共享的 安全性 比 cookie 高 低 舉例 cookie、session 登錄流程 客戶端使用用戶名跟密碼請求登錄 服務端收到請求，去驗證用戶名和密碼（後台根據請求去數據庫查找是否有該用戶） 驗證成功後，服務端會簽發一個 API token（進行 API 路徑存取時先 JWT 驗證 -&gt; 驗證成功才允許訪問該 API，該 token 值一般都會存入資料庫中，並設置過期時間），再把這個 token 發送給客戶端 客戶端收到 token 之後，再用 js 塞到 cookie 或 storage 裡面 客戶端每次向服務端請求資源的時候需要帶著服務端簽發的 token 服務端收到請求，然後去驗證客戶端請求裡面帶著的 token（token 是否為該用戶的令牌以及 token 是否有效等），如果驗證成功就向客戶端返回請求的數據","categories":[{"name":"HTTP","slug":"HTTP","permalink":"https://jimmywei01.github.io/categories/HTTP/"}],"tags":[{"name":"cookie","slug":"cookie","permalink":"https://jimmywei01.github.io/tags/cookie/"},{"name":"web storage","slug":"web-storage","permalink":"https://jimmywei01.github.io/tags/web-storage/"}]},{"title":"HTML 紀錄","slug":"HTML-紀錄","date":"2019-05-12T15:19:06.000Z","updated":"2019-05-27T06:02:47.627Z","comments":true,"path":"2019/05/12/HTML-紀錄/","link":"","permalink":"https://jimmywei01.github.io/2019/05/12/HTML-紀錄/","excerpt":"紀錄常用的HTML -&gt; Hyper Text Markup Language (超文本標記語言)","text":"紀錄常用的HTML -&gt; Hyper Text Markup Language (超文本標記語言) HTML - table 表格 thead table 頭 tbody table 身體 tfoot table 腳 th 預設是粗體置中，主要用在表格標題 td 單格 tr 整行 (整列) colspan 水平合併 rowspan 垂直合併 html1234567891011121314151617181920212223242526&lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;table標題&lt;/th&gt; &lt;th&gt;table標題2&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot;&gt;這裡是第一行&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;這裡是第二行的第一個欄位&lt;/td&gt; &lt;td rowspan=&quot;2&quot;&gt;這裡是第二行的第二個欄位&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;這裡是第三行的第一個欄位&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;tfoot&gt; &lt;tr&gt; &lt;td&gt;這裡是第四行的第一個欄位&lt;/td&gt; &lt;td rowspan=&quot;2&quot;&gt;這裡是第四行的第二個欄位&lt;/td&gt; &lt;/tr&gt; &lt;/tfoot&gt;&lt;/table&gt; HTML - form 表單可參考 -&gt; https://www.w3schools.com/html/html_form_input_types.asp display 預設為 inline 屬性 html1234&lt;form action=&quot;/searchList&quot; method=&apos;post&apos; enctype=&quot;application/x-www-form-urlencoded&quot;&gt; &lt;input type=&quot;text&quot; name=&apos;searchText&apos; id=&apos;text&apos; value = &apos;&apos;&gt; &lt;input type=&quot;submit&quot; id=&apos;send&apos; value=&apos;送出&apos;&gt;&lt;/form&gt; 屬性 值 描述 enctype application/x-www-form-urlencoded 在發送前編碼所有字元（預設） multipart/form-data 不對字元編碼在使用包含文件上傳控件的表單時，必須使用該值 text/plain 空格轉換為”+” 加號，但不對特殊字元編碼 application/json json 傳送物件資料 要轉成 ‘字串’ 傳送 accept MIME_type HTML 5 中不支持 可以用副檔名來指定可接受的檔案類型 accept-charset charset_list 規定服務器可處理的表單數據字符集 action URL 提交表單時向何處發送表單數據(詢問後端工程師要在哪驗證) autocomplete on、off 規定是否啟用表單的自動完成功能 method get、post 用於發送 form-data 的 HTTP 方法 name form_name 傳送給後台串連的名子 novalidate novalidate 如果使用該屬性 則提交表單時不進行驗證 target _blank、_self、_parent、_top、framename 規定在何處打開 action URL value form_value 傳送給後台的值 form 常用操作 input type required 自動驗證 pattern=”[A-z]{3}” 自訂驗證規則 html123&lt;input type=&quot;text&quot; name=&apos;searchText&apos; id=&apos;text&apos; value = &apos;&apos; required pattern=&quot;[A-z]&#123;3&#125;&quot;&gt;&lt;input type=&quot;submit&quot; id=&apos;send&apos; value=&apos;送出’&gt;&lt;input type=&quot;file&quot; accept=&quot;.pdf&quot; /&gt; radio 單選題 html12&lt;input type=&quot;radio&quot; name=&quot;gander&quot; value=&quot;male&quot;&gt;Male&lt;input type=&quot;radio&quot; name=&quot;gander&quot; value=&quot;female&quot;&gt;Female checkbox 多選題 html123&lt;input type=&quot;checkbox&quot; name=&quot;intersts&quot; value=&quot;reade&quot;&gt;read&lt;input type=&quot;checkbox&quot; name=&quot;intersts&quot; value=&quot;sleep&quot;&gt;sleep&lt;input type=&quot;checkbox&quot; name=&quot;intersts&quot; value=&quot;eat&quot;&gt;eat label (label for) 可用在點選文字 提升UX體驗 用 id 來對應 label 標籤的特性包在任何 input 標籤外面，點擊 label 就等於點擊 input 利用這個特性，將 label 標籤包在 input 上傳按鈕外，再將 input 上傳按鈕隱藏起來，點擊依然有效 使用圖片代替 input 上傳按鈕，可在 label 裡面放圖片 input 無法設定的任何 CSS，此時可設定在 label 上 html12&lt;label for=&quot;email&quot;&gt;email&lt;/label&gt;&lt;input type=&quot;email&quot; id=&quot;email&quot;&gt; select 下拉式選單html1234&lt;select name=&quot;month&quot;&gt; &lt;option value=&quot;1&quot;&gt;1&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;2&lt;/option&gt;&lt;/select&gt; button submit 傳送資料給後台 reset 將資料重整 button 單純按鈕無動作 可與 javascript 搭配完成特殊動作 html1234&lt;input type=&quot;text&quot;&gt;&lt;button type=&quot;submit&quot;&gt;submit&lt;/button&gt;&lt;button type=&quot;reset&quot;&gt;reset&lt;/button&gt;&lt;button type=&quot;button&quot;&gt;no action&lt;/button&gt; multiple 可同時選擇多個選項 html1234567&lt;select multiple=&quot;multiple&quot;size=&quot;4&quot;&gt; &lt;option value =&quot;volvo&quot;&gt;Volvo&lt;/option&gt; &lt;option value =&quot;saab&quot;&gt;Saab&lt;/option&gt; &lt;option value=&quot;opel&quot;&gt;Opel&lt;/option&gt; &lt;option value=&quot;audi&quot;&gt;Audi&lt;/option&gt; &lt;option value=&quot;bmw&quot;&gt;BMW&lt;/option&gt;&lt;/select&gt; textarea html12345678910// 限制 輸入內容文字長度&lt;textarea cols=&quot;30&quot; rows=&quot;10&quot;&gt;&lt;/textarea&gt;// 限制 textarea 被拉大的區域&lt;textarea cols=&quot;30&quot; rows=&quot;10&quot;&gt;&lt;/textarea&gt;textarea&#123; max-width: 300px; resize: none;&#125; HTML - 常犯的錯誤 塊級元素放入了行內元素內 html123&lt;a href=&quot;#&quot;&gt;&lt;h1&gt;wrong&lt;/h1&gt;&lt;/a&gt;&lt;h1&gt;&lt;a href=&quot;#&quot;&gt;right&lt;/a&gt;&lt;/h1&gt; 圖片 img 沒有包含設定 alt 屬性 幫助使用者以及搜尋引擎瞭解這張圖片有什麼意義 html12345不會顯示圖片&lt;img src=&quot;wrong.png&quot; alt=“”&gt; 會顯示圖片&lt;img src=&quot;right.png&quot; alt=&quot;right picture&quot;&gt; 用＜b＞和＜i＞標籤來達到字體加粗和斜體字的效果 ‘效果’ 就用 CSS ‘文章中的重要性’，則使用＜strong＞和＜em＞標籤 html123&lt;b&gt;粗體&lt;/b&gt; &lt;i&gt;斜體&lt;/i&gt;&lt;strong&gt;粗體&lt;/strong&gt; &lt;em&gt;斜體&lt;/em&gt; 使用太多的換行符號(斷行)＜br/＞ 不要使用 &lt;br/&gt; 來增加文字間距，應該用 CSS 的 margin 屬性、或改用 &lt;p&gt; 完成這件事 https://developer.mozilla.org/zh-TW/docs/Web/HTML/Element/br html1234567休息是為了走更長遠的路 &lt;br/&gt;&lt;br/&gt;真的嗎？&lt;p&gt;休息是為了走更長遠的路&lt;/p&gt;&lt;p&gt;真的嗎？&lt;/p&gt; 沒有使用標籤標題(如H1,H2,H3..) 常用 H1、H2、H3 和 &lt;strong&gt; 和 &lt;em&gt;，H4~H6 是我比較少用到 html123&lt;h1&gt;oh&lt;/h1&gt;&lt;h2&gt;oh&lt;/h2&gt;&lt;h3&gt;oh&lt;/h3&gt; HTML - 提問 DOCTYPE 有什麼作用？標準模式與混雜模式如何區分？它們有何意義?告訴瀏覽器使用哪個版本的 HTML 規範來渲染文件，DOCTYPE 不存在或形式不正確會導致 HTML 文件以混雜模式呈現 標準模式（Standards mode）以瀏覽器支援的最高標準執行 混雜模式（Quirks mode）中頁面是一種比較寬鬆的向後相容的方式顯示 HTML5 為什麼只需要寫 &lt;!DOCTYPE HTML&gt;？ HTML5 不基於 SGML（Standard Generalized Markup Language 標準通用標記語言),因此不需要對 DTD（DTD 文件型別定義）進行引用，但是需要 DOCTYPE 來規範瀏覽器行為 HTML4.01 基於 SGML，所以需要引用 DTD。才能告知瀏覽器文件所使用的文件型別，如下：&lt;!DOCTYPE HTML PUBLIC “-//W3C//DTD HTML 4.01//EN” “http://www.w3.org/TR/html4/strict.dtd”&gt; 行內元素有哪些？塊級元素有哪些？ 空(void)元素有那些？ 塊級元素：&lt;div&gt; &lt;ul&gt; &lt;ol&gt; &lt;li&gt; &lt;dl&gt; &lt;dt&gt; &lt;dd&gt; &lt;h1&gt; &lt;p&gt; 行內元素：&lt;a&gt; &lt;span&gt; &lt;img&gt; &lt;input&gt; &lt;select&gt; 空元素：&lt;hr&gt; &lt;link&gt; &lt;meta&gt; 頁面匯入樣式時，使用 link 和 @import 有什麼區別？ 都是外部引用 CSS 方式 @import 屬於 CSS 範疇，只能載入 CSS @import 需要在頁面完全載入以後載入，而且被 @import 引用的 CSS 會等到引用它的 CSS 檔案被載入完才載入 link 引用 CSS 時候，頁面載入時同時載入 link 方式的樣式的權重高於 @import 的權重 import 在 html 使用時候需要 &lt;style type=&quot;text/css&quot;&gt;標籤 介紹一下瀏覽器核心的理解？ 可參考 https://developers.google.com/web/fundamentals/performance/rendering/ https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction 渲染引擎 HTML 經過 HTML parser 產生 HTML DOM tree CSS 經過 CSS parser 產生 CSS rules 進入 style 將 rules 賦予 DOM tree 產生 style tree 的元素 進入 layout 將 style tree 元素進行排版產生 layout tree 進入 渲染顯示在應用程式上 JS 引擎 javascript 來實現網頁動態效果的解析和執行 每解析和執行渲染引擎會重新渲染 每個動作最好在 16 ms 內完成，因為多數裝置會以 每秒 60 次 重新整理螢幕 HTML 語義化的理解？ 去掉或丟失樣式的時候能夠讓頁面呈現出清晰的結構 有利於 SEO 和搜尋引擎建立良好溝通，有助於爬蟲抓取更多的資訊，爬蟲依賴於標籤來確定上下文和各個關鍵字的權重 方便其它裝置解析 便於團隊開發和維護 &lt;script&gt; 放置的位置？ 可參考 https://developer.mozilla.org/zh-TW/docs/Web/HTML/Element/script https://html.spec.whatwg.org/multipage/scripting.html 將 &lt;script&gt; 放置在 &lt;head&gt; 瀏覽器在解析過程中，發現 &lt;script&gt; 會阻斷頁面上其他 HTML 的解析，下載完所有 &lt;script&gt; 在往下解析 HTML，這會導致使用者感到不順感 將 &lt;script&gt; 放置在 &lt;body&gt; 尾端 瀏覽器在整個 HTML 解析完成之前都不能下載 &lt;script&gt;，如果 HTML 很大解析完HTML，使用者依然要等待 &lt;script&gt; 下載並執行完成之後才能操作這個網站 async - asynchronous(非同步) 以非同步的方法執行 如果沒有 src 屬性的話，就不能用這個屬性在這種情況下，它將失去作用 只要下載完就執行，有可能會導致 script2.js 可能先於 script1.js 執行(載完的先跑) 12&lt;script src=&quot;script1.js&quot; async&gt;&lt;/script&gt;&lt;script src=&quot;script2.js&quot; async&gt;&lt;/script&gt; defer - deferred(延遲) 與 async 相同在 HTML 在解析時下載 &lt;script&gt;， &lt;script&gt; 會等到 HTML 載完才開始工作，而且會按照順序一個一個來，也就是說 script1.js 永遠優先於 script2.js 12&lt;script src=&quot;script1.js&quot; defer&gt;&lt;/script&gt;&lt;script src=&quot;script2.js&quot; defer&gt;&lt;/script&gt;","categories":[{"name":"HTML","slug":"HTML","permalink":"https://jimmywei01.github.io/categories/HTML/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://jimmywei01.github.io/tags/HTML/"},{"name":"HTML5","slug":"HTML5","permalink":"https://jimmywei01.github.io/tags/HTML5/"}]},{"title":"HTML Meta tages 屬性設定","slug":"HTML-Meta-tages-的屬性設定","date":"2019-05-10T13:15:54.000Z","updated":"2019-05-27T06:02:47.623Z","comments":true,"path":"2019/05/10/HTML-Meta-tages-的屬性設定/","link":"","permalink":"https://jimmywei01.github.io/2019/05/10/HTML-Meta-tages-的屬性設定/","excerpt":"SEO 網頁優化必備的 Meta 標籤","text":"SEO 網頁優化必備的 Meta 標籤 meta 存放位置在 head 之間 告訴瀏覽器 HTML5 網頁的編碼1&lt;meta charset=&quot;UTF-8&quot;&gt; 控制用戶的 viewport (可見區域)的方法1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no&quot;&gt; viewport 設定 屬性 說明 width 設定畫面寬度 height 設定畫面高度 initial-scale 設定畫面的初始縮放比例 minimum-scale 設定畫面的最小縮放比例 maximum-scale 設定畫面的最大縮放比例 user-scalable 設定是否允許使用者改變縮放比例 width=device-width 可以自動符合所有不同手機螢幕預設的最佳解析度 initial-scale=1 設定手機螢幕畫面的初始縮放比例為 100% user-scalable=no 不允許使用者改變縮放比例，則會將值設為 no 網頁相容模式，沒指定會依照使用者所使用的瀏覽器的版本為主，因此可利用此語法跟瀏覽器說用哪個版本來作瀏覽1&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;/&gt; 網站頁面 icon1&lt;link rel=&quot;shortcut icon&quot; href=&quot;favicon.ico&quot;&gt; 關鍵字 - 用逗號(,)隔開，最好不要有空白1&lt;meta name=&quot;keywords&quot; content=&quot;程式,哲學&quot; /&gt; meta name 的屬性值 屬性 說明 meta name=”author” content=”作者姓名” 記錄網頁的作者名稱 meta name=”description” content=”網頁簡短描述” 網頁的簡短描述 meta name=”generator” content=”編輯器名稱” 記錄網頁編輯器名稱 meta name=”keywords” content=”網頁關鍵字” 放置網頁關鍵字 meta name=”distribution” content=”網頁發佈地區” 記錄網頁的發佈地區 網頁隱私用來告知搜尋引擎該網頁是否可被搜尋，並且有幾個參數可作設定 noindex：不要檢索 nofollow：只檢索該頁，不檢索該頁裡的鏈結 noindex, nofollow：搜尋引擎的小蜘蛛到這裡時，就會停止，不作任何的檢索1234&lt;meta name=&quot;robots&quot; content=&quot;index,follow&quot; /&gt;&lt;meta name=&quot;robots&quot; content=&quot;noindex,follow&quot; /&gt;&lt;meta name=&quot;robots&quot; content=&quot;index,nofollow&quot; /&gt;&lt;meta name=&quot;robots&quot; content=&quot;noindex,nofollow&quot; /&gt; 社群平台 mets tages可用 -&gt; https://metatags.io/ 1234567891011121314151617181920212223242526272829&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;/&gt; &lt;title&gt;HTML meta tages 介紹&lt;/title&gt; &lt;link rel=&quot;shortcut icon&quot; href=&quot;favicon.ico&quot;&gt; &lt;meta name=&quot;keywords&quot; content=&quot;程式,哲學&quot; /&gt; &lt;meta name=&quot;title&quot; content=&quot;Jimmy&apos;s Notes&quot;&gt; &lt;meta name=&apos;description&apos; content=&apos;網站描述文字&apos; /&gt; &lt;meta name=&quot;robots&quot; content=&quot;index,follow&quot; /&gt; &lt;meta name=&quot;robots&quot; content=&quot;noindex,follow&quot; /&gt; &lt;meta name=&quot;robots&quot; content=&quot;index,nofollow&quot; /&gt; &lt;meta name=&quot;robots&quot; content=&quot;noindex,nofollow&quot; /&gt; &lt;meta property=&quot;og:title&quot; content=&quot;FB的標題&quot; /&gt; &lt;meta property=&quot;og:description&quot; content=&quot;FB的描述&quot;&gt; &lt;meta property=&quot;og:type&quot; content=&quot;website&quot; /&gt; &lt;meta property=&quot;og:url&quot; content=&quot;FB上的網址&quot; /&gt; &lt;meta property=&quot;og:image&quot; content=&quot;FB的圖片&quot; /&gt; &lt;link href=&quot;圖片路徑&quot; rel=&quot;apple-touch-icon&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;CSS檔案路徑&quot;&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;JS檔案路徑&quot;&gt;&lt;/script&gt;&lt;/head&gt;","categories":[{"name":"HTML","slug":"HTML","permalink":"https://jimmywei01.github.io/categories/HTML/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://jimmywei01.github.io/tags/HTML/"},{"name":"HTML5","slug":"HTML5","permalink":"https://jimmywei01.github.io/tags/HTML5/"},{"name":"Analytics","slug":"Analytics","permalink":"https://jimmywei01.github.io/tags/Analytics/"}]},{"title":"使用Google_Search_Console和sitemap進行SEO優化","slug":"使用Google-Search-Console和sitemap進行SEO優化","date":"2019-05-09T15:11:41.000Z","updated":"2019-05-27T06:02:47.626Z","comments":true,"path":"2019/05/09/使用Google-Search-Console和sitemap進行SEO優化/","link":"","permalink":"https://jimmywei01.github.io/2019/05/09/使用Google-Search-Console和sitemap進行SEO優化/","excerpt":"讓你的網站更親近 Google","text":"讓你的網站更親近 Google 前言為了讓文章可以被 Google 搜尋到所以設定 sitemap &amp; Google_Search_Console 流程sitemap使用 npm 自動生成網站的 sitemap，然後將生成的 sitemap 提交 Google 1npm install hexo-generator-sitemap --save 修改文件設定將 sitemap 加到站點設定文件 _config.yml 中，並修改 url 為自己的網址 路徑：/_config.yml 123# sitmapsitemap: path: sitemap.xml 重新部署到 GitHub \b選擇性增加 \brobots.txt\b\b主要行為就是在搜尋引擎檢索網站時，告訴它網站哪些內容可以被檢索，哪些內容可以不用被檢索\b可參考 \b-&gt; robots.txt用途與使用範例教學，釐清SEO收錄觀念 在站點 source 文件夾下新建 robots.txt 文件，文件內容如下 Allow 字段的值即為允許搜索引擎爬區的內容，可以對應到主題配置文件中的 menu 目錄配置，如果還有其他選項都可以按照格式自行添加 需要將 https://hoxis.github.io 改成自己的域名 1234567891011121314User-agent: *Allow: /Allow: /archives/Allow: /categories/Allow: /tags/ Allow: /resources/ Disallow: /vendors/Disallow: /js/Disallow: /css/Disallow: /fonts/Disallow: /vendors/Disallow: /fancybox/Sitemap: https://hoxis.github.io/sitemap.xml Google_Search_Consolehttps://www.google.com/webmasters/#?modal_active=none 可參考 -&gt; 新版Google Search Console基礎介紹，透析新舊版介面、功能差異 登入後，會顯示你沒有存取這項資源的權限 點擊驗證擁有權可以發現有多種驗證方式，我們用\b上一篇埋好的 GA 進行驗證如果失敗就回去 &lt;head&gt; 確認有沒有正確埋入 成功後進入 sitemap \b面板選項再加入 sitemap.xml 加入網址索引 點擊 網址審查加入網頁 點擊右上方的測試線上網址可以即時測試網頁是否能夠讓 Google 進行索引 點擊 加入索引 完成後 最後可以用 site:你的網址 來看有沒有被 Google 搜尋到","categories":[{"name":"Analytics","slug":"Analytics","permalink":"https://jimmywei01.github.io/categories/Analytics/"}],"tags":[{"name":"Analytics","slug":"Analytics","permalink":"https://jimmywei01.github.io/tags/Analytics/"},{"name":"hexo","slug":"hexo","permalink":"https://jimmywei01.github.io/tags/hexo/"}]},{"title":"使用GA替網站作分析","slug":"使用GA替網站作分析","date":"2019-05-09T11:24:15.000Z","updated":"2019-05-27T06:02:47.625Z","comments":true,"path":"2019/05/09/使用GA替網站作分析/","link":"","permalink":"https://jimmywei01.github.io/2019/05/09/使用GA替網站作分析/","excerpt":"Google Analytics SEO 的工具之一","text":"Google Analytics SEO 的工具之一 前言為什麼會寫這篇？因為建立好 Hexo NexT 的 theme 之後， 加入 GA 分析可以讓自己了解到哪些屬於熱門文章，but 沒想到加入 GA 後 GA 無效，只好將 網站追蹤碼 貼入 \b&lt;head&gt; 而非使用原先 NexT 的方法，流程如下 流程GA \b申請點擊這個連結進入申請 -&gt; Google Analytics 輸入相關資料 Account Name: 輸入自己可以辨別的名稱 網站名稱: 網站名稱 網站網址: 需注意 http 及 https 產類類別: 依照相關選取即可 取得追蹤 ID 跳出同意視窗，打勾同意送出 成功後進入畫面 埋入 GAGA埋入使用 網站追蹤碼紅色框部分貼入 &lt;head&gt; Hexo 埋入 GA複製追蹤 ID(管理 &gt; 追蹤資訊 &gt; 追蹤程式碼) 將追蹤 ID \b貼入 themes/next/_config.yml 第 758 行123google_analytics: tracking_id: UA-XXXXXX-1 localhost_ignored: true 修改 google-analytics.swig 檔案檔案路徑 \b: themes/next/layout/_third-party/analytics/google-analytics.swig NexT 模板預設的 src 路徑不正確所導致需要加上 https://1234567加入前&lt;script async src=&quot;//www.googletagmanager.com/gtag/js?id=&#123;&#123; theme.google_analytics.tracking_id &#125;&#125;&quot;&gt;&lt;/script&gt;加入後&lt;script async src=&quot;https://www.googletagmanager.com/gtag/js?id=&#123;&#123; theme.google_analytics.tracking_id &#125;&#125;&quot;&gt;&lt;/script&gt; 測試埋入結果回到追蹤程式碼頁面，然後上面有一個傳送測試瀏覽按鈕，按下可以看結果，but 都沒回傳結果 將 網站追蹤碼 貼入 \b&lt;head&gt;檔案路徑 \b: themes/next/layout/_partials/head/head.swig 重新部署到 GitHub 開啟 GitHub Pages 確認 GA 是否在 &lt;head&gt; 中 回到追蹤程式碼頁面，按下測試瀏覽按鈕看結果，測試成功 下篇介紹\b利用 GA 認證 Google Search Console 更有利於 Google 搜尋","categories":[{"name":"Analytics","slug":"Analytics","permalink":"https://jimmywei01.github.io/categories/Analytics/"}],"tags":[{"name":"Analytics","slug":"Analytics","permalink":"https://jimmywei01.github.io/tags/Analytics/"},{"name":"hexo","slug":"hexo","permalink":"https://jimmywei01.github.io/tags/hexo/"}]},{"title":"MarkDown、Hexo、NexT 常用寫法","slug":"MarkDown、Hexo、NexT-常用寫法","date":"2019-05-09T03:43:00.000Z","updated":"2019-05-27T06:02:47.621Z","comments":true,"path":"2019/05/09/MarkDown、Hexo、NexT-常用寫法/","link":"","permalink":"https://jimmywei01.github.io/2019/05/09/MarkDown、Hexo、NexT-常用寫法/","excerpt":"記\b不下來就寫下來","text":"記\b不下來就寫下來 MarkDown 常用寫法 字體基本設定 階層式區塊語法&gt;text 、 \b&gt;&gt;text 、 &gt;&gt;&gt;text 粗體 **your text**斜體 *your text*刪除線 ~~your text~~超連結 [超連結](https://jimmywei01.github.io/) 小區塊`your text` 大區塊前後三個反引號 標題123456# H1## H2### H3#### H4##### H5###### H6 文字增加顏色20px的字15px的字 12&lt;font style=\"color:#f90;font-size:20px;\"&gt;20px的字&lt;/font&gt;&lt;font style=\"color:red;font-size:10px;\"&gt;10px的字&lt;/font&gt; 列表 Item 1 Item 2 Item 2a Item 2b 1234* Item 1* Item 2 * Item 2a * Item 2b 表格冒號（Colons）是用來對齊的（擺左齊左、擺右齊右，都擺就置中） Markdown Less Pretty Still renders nicely 1 2 3 1234Markdown | Less | Pretty--- | :---: | ---:*Still* | `renders` | nicely1 | 2 | 3: Hexo 標籤外掛 hexo 標籤外掛參考連結https://hexo.io/zh-tw/docs/tag-plugins hexo 指令 啟動 serverhexo server 建立新文章hexo new post [title] s →啟動伺服器 -g →生成靜態頁面hexo s -g d →部屬模式 -g →生成靜態頁面hexo d -g 刪除已生成的靜態頁面及快取檔案hexo clean 程式碼區塊寫法 [language] 是代碼語言的名稱，用來設置代碼塊顏色高亮，非必須 [title] 是頂部左邊的說明，非必須 [url] 是頂部右邊的超鏈接地址，非必須 [link text] 如它的字面意思，超鏈接的名稱，非必須 使用 代碼塊語法123&#123;% codeblock [language] [title] [url] [link text] %&#125; your code&#123;% endcodeblock %&#125; css css /index 首頁12345.container &#123; max-width: 960px; margin: 0 auto; margin-top: 10px;&#125; 加上說明 123&#123;% codeblock Array.map %&#125;array.map(callback[, thisArg])&#123;% endcodeblock %&#125; Array.map1array.map(callback[, thisArg]) 加上說明和網址 1234&#123;% codeblock _.compact http://underscorejs.org/#compact Underscore.js %&#125;_.compact([0, 1, false, 2, &apos;&apos;, 3]);=&gt; [1, 2, 3]&#123;% endcodeblock %&#125; _.compactUnderscore.js12_.compact([0, 1, false, 2, &apos;&apos;, 3]);=&gt; [1, 2, 3] 使用\b 大區塊(前後三個反引號)123``` [language] [title] [url] [link text] your code ``` css首頁 123456.container &#123; max-width: 960px; margin: 0 auto; /* 起手式 */ margin-top: 10px;&#125; NexT 無需路徑名插入圖片 新建文章在相同目錄下創建同名文件夾（便於圖片管理） 打開站點配置文件_config.yml/post_asset_folder，設置值為true 安裝hexo-asset-image：npm install hexo-asset-image –save 此時hexo new “fileName”會在/source/_posts目錄下創建同名的文件夾 12只需在md文件裡使用 無需路徑名就可以插入圖片![title](圖片名.jpg) 文章頁面顯示繼續閱讀1&lt;!-- more —&gt;","categories":[{"name":"other","slug":"other","permalink":"https://jimmywei01.github.io/categories/other/"}],"tags":[{"name":"other","slug":"other","permalink":"https://jimmywei01.github.io/tags/other/"}]}]}